<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="73d8ba46-8c12-43f6-8c22-24aa21b8d93d" name="onetrust-data-domain" /><meta content="https://tags.tiqcdn.com/utag/vmware/microsites-privacy/prod/utag.js" name="microsites-utag" /><script src="https://d1fto35gcfffzn.cloudfront.net/assets/jquery-1.11.2.min.js"></script><script src="//www.vmware.com/files/templates/inc/utag_data.js"></script><script src="//tags.tiqcdn.com/utag/vmware/microsites-privacy/prod/utag.sync.js"></script><script>function OptanonWrapper() { { window.dataLayer.push({ event: 'OneTrustGroupsUpdated' }); } }</script><script src="/js/gtm.js"></script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="googlebot" content="NOODP" /><meta name="google-site-verification" content="nSYeDgyKM9mw5CWcZuD0xu7iSWXlJijAlg9rcxVOYf4" /><meta name="google-site-verification" content="6UEaC3SWhpGQvqRnSJIEm2swxXpM5Adn4dxZhFsNdw0" /><meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="viewport" name="viewport" /><link href="https://fonts.googleapis.com/css?family=Raleway:400,500,600,700" rel="stylesheet" /><link rel="stylesheet" href="/css/rabbit.css" type="text/css" /><link rel="stylesheet" href="/css/highlightjs_style.css" type="text/css" /><link rel="stylesheet" href="/css/rabbit-next.css" type="text/css" /><!--[if IE 6]>
      <link rel="stylesheet" href="/css/rabbit-ie6.css" type="text/css" />
      <![endif]--><link rel="icon" type="/image/vnd.microsoft.icon" href="/favicon.ico" /><link rel="stylesheet" href="/css/tutorial.css" type="text/css" /><script async="true" type="text/javascript" src="/js/site.js"></script><title> Java Client API Guide
 â€” RabbitMQ</title></head>
  <body id="api-guide"><div id="outerContainer"><div class="container"><div class="rabbit-logo"><a href="./"><img src="./img/logo-rabbitmq.svg" alt="RabbitMQ" /></a></div><a class="btn menubtn" onclick="showHide()">Menu <img src="./img/carrot-down-white.svg" /></a><div class="mobilemenuicon" onclick="showHide()"><img src="./img/mobile-menu-icon.svg" /></div><div id="nav"><ul id="mainNav"><li><a href="./#features">Features</a></li><li><a href="./#getstarted">Get Started</a></li><li><a href="./#support">Support</a></li><li><a href="./#community">Community</a></li><li><a href="./documentation.html">Docs</a></li></ul></div></div><div class="nav-separator"></div><div id="innerContainer" class="container"><div id="left-content"><h1> Java Client API Guide
</h1>


<h2><a id="overview" class="anchor" href="#overview">Overview</a></h2>
<p>This guide covers <a href="./java-client.html">RabbitMQ Java client</a> and its public API.
It assumes that the <a href="http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22amqp-client%22">most recent major version of the client</a> is used
and the reader is familiar with <a href="./getstarted.html">the basics</a>.</p>
<p>Key sections of the guide are:</p>
<ul>
<li><a href="#license">Licensing</a></li>
<li><a href="#jdk-versions">JDK and Android versions</a> supported</li>
<li><a href="#support-timeline">Support Timeline</a></li>
<li><a href="#connecting">Connecting to RabbitMQ</a></li>
<li><a href="#connection-and-channel-lifespan">Connection and Channel Lifespan</a></li>
<li><a href="#client-provided-names">Client-provided connection name</a></li>
<li><a href="#exchanges-and-queues">Using Exchanges and Queues</a></li>
<li><a href="#publishing">Publishing Messages</a></li>
<li><a href="#consuming">Consuming Using a Subscription</a></li>
<li><a href="#concurrency">Concurrency Considerations and Safety</a></li>
<li><a href="#recovery">Automatic Recovery From Network Failures</a></li>
<li><a href="#unhandled-exceptions">Unhandled Exceptions</a> in consumers</li>
<li><a href="#metrics">Metrics and Monitoring</a></li>
<li><a href="#service-discovery-with-address-resolver">Endpoint Resolution with the AddressResolver Interface</a></li>
<li>The <a href="#rpc">Request/Response Pattern</a> ("RPC")</li>
<li><a href="#tls">TLS support</a></li>
<li><a href="#oauth2-support">OAuth 2 support</a></li>
</ul>
<p>An <a href="https://rabbitmq.github.io/rabbitmq-java-client/api/current/">API reference</a> (JavaDoc) is available separately.</p>
<h2><a id="support-timeline" class="anchor" href="#support-timeline">Support Timeline</a></h2>
<p>Please see the <a href="./java-versions.html">RabbitMQ Java libraries support page</a> for the support timeline.</p>
<h2><a id="jdk-versions" class="anchor" href="#jdk-versions">JDK and Android Version Support</a></h2>
<p>5.x release series of this library <a href="./java-versions.html">require JDK 8</a>, both for compilation and at runtime. On Android,
this means only <a href="https://developer.android.com/guide/platform/j8-jack.html">Android 7.0 or later</a> versions are supported.</p>
<p>4.x release series <a href="./java-versions.html">support JDK 6</a> and Android versions prior to 7.0.</p>
<h2><a id="license" class="anchor" href="#license">License</a></h2>
<p>The library is open source, developed <a href="https://github.com/rabbitmq/rabbitmq-java-client/">on GitHub</a>, and is triple-licensed under</p>
<ul>
<li><a href="https://www.apache.org/licenses/LICENSE-2.0.html">Apache Public License 2.0</a></li>
<li><a href="https://www.mozilla.org/MPL/2.0/">Mozilla Public License 2.0</a></li>
<li><a href="http://www.gnu.org/licenses/gpl-2.0.html">GPL 2.0</a></li>
</ul>
<p>This means that the user can consider the library to be licensed under <strong>any of the licenses from the list above</strong>.
For example, the user may choose the Apache Public License 2.0 and include this client into
a commercial product. Codebases that are licensed under the GPLv2 may choose GPLv2, and so on.</p>
<h2><a id="overview" class="anchor" href="#overview">Overview</a></h2>
<p>The client API exposes key entities in the <a href="./tutorials/amqp-concepts.html">AMQP 0-9-1 protocol model</a>,
with additional abstractions for ease of use.</p>
<p>RabbitMQ Java client uses <span class="code ">com.rabbitmq.client</span> as its top-level package.
The key classes and interfaces are:</p>
<ul>
<li>Channel: represents an AMQP 0-9-1 channel, and provides most of the operations (protocol methods).</li>
<li>Connection: represents an AMQP 0-9-1 connection</li>
<li>ConnectionFactory: constructs <span class="code ">Connection</span> instances</li>
<li>Consumer: represents a message consumer</li>
<li>DefaultConsumer: commonly used base class for consumers</li>
<li>BasicProperties: message properties (metadata)</li>
<li>BasicProperties.Builder: builder for <span class="code ">BasicProperties</span></li>
</ul>
<p>Protocol operations are available through the
<span class="code ">Channel</span> interface. <span class="code ">Connection</span> is
used to open channels, register connection lifecycle event
handlers, and close connections that are no longer needed.
<span class="code ">Connection</span>s are instantiated through <span class="code ">ConnectionFactory</span>,
which is how you configure various connection settings, such as the vhost or username.</p>
<h2><a id="connections-and-channels" class="anchor" href="#connections-and-channels">Connections and Channels</a></h2>
<p>The core API classes are <span class="code ">Connection</span>
and <span class="code ">Channel</span>, representing an AMQP 0-9-1 connection and
channel, respectively. They are typically imported before used:</p>
<pre class="lang-java">
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.Channel;
</pre>

<h2><a id="connecting" class="anchor" href="#connecting">Connecting to RabbitMQ</a></h2>
<p>The following code connects to a RabbitMQ node using the given parameters (host name, port number, etc):</p>
<pre class="lang-java">
ConnectionFactory factory = new ConnectionFactory();
// "guest"/"guest" by default, limited to localhost connections
factory.setUsername(userName);
factory.setPassword(password);
factory.setVirtualHost(virtualHost);
factory.setHost(hostName);
factory.setPort(portNumber);

Connection conn = factory.newConnection();
</pre>

<p>All of these parameters have sensible defaults for a RabbitMQ
node running locally.</p>
<p>The default value for a property will be used if the property
remains unassigned prior to creating a connection:</p>
<table>
  <thead>
    <tr>
      <td>Property</td>
      <td>Default Value</td>
    </tr>
  </thead>

  <tr>
    <td>Username</td>
    <td><span class="code ">"guest"</span></td>
  </tr>

  <tr>
    <td>Password</td>
    <td><span class="code ">"guest"</span></td>
  </tr>

  <tr>
    <td>Virtual host</td>
    <td><span class="code ">"/"</span></td>
  </tr>

  <tr>
    <td>Hostname</td>
    <td><span class="code ">"localhost"</span></td>
  </tr>

  <tr>
    <td>port</td>

    <td>
      <span class="code ">5672</span> for regular connections,
      <span class="code ">5671</span> for <a href="./ssl.html">connections that use TLS</a>
    </td>
  </tr>
</table>

<h3><a id="uri" class="anchor" href="#uri">Connecting Using a URI</a></h3>
<p>Alternatively, <a href="uri-spec.html">URIs</a> may be used:</p>
<pre class="lang-java">
ConnectionFactory factory = new ConnectionFactory();
factory.setUri("amqp://userName:password@hostName:portNumber/virtualHost");
Connection conn = factory.newConnection();
</pre>

<p>All of these parameters have sensible defaults for a stock
RabbitMQ server running locally.</p>
<p>Successful and unsuccessful client connection events can be <a href="./logging.html">observed in server node logs</a>.</p>
<p>Note that <a href="./access-control.html">user guest can only connect from localhost</a> by default.
This is to limit well-known credential use in production systems.</p>
<p>Application developers can <a href="#client-provided-names">assign a custom name to a connection</a>. If set,
the name will be mentioned in RabbitMQ node logs as well as <a href="./management.html">management UI</a>.</p>
<p>The <span class="code ">Connection</span> interface can then be used to open a channel:</p>
<pre class="lang-java">
Channel channel = conn.createChannel();
</pre>

<p>The channel can now be used to send and receive messages, as described in subsequent sections.</p>
<h3><a id="endpoints-list" class="anchor" href="#endpoints-list">Using Lists of Endpoints</a></h3>
<p>It is possible to specify a list of endpoints to use when connecting. The first
reachable endpoint will be used. In case of <a href="#recovery">connection failures</a>, using
a list of endpoints makes it possible for the application to connect to a different
node if the original one is down.</p>
<p>To use multiple of endpoint, provide a list of <span class="code ">Address</span>es to <span class="code ">ConnectionFactory#newConnection</span>.
An <span class="code ">Address</span> represents a hostname and port pair.</p>
<pre class="lang-java">
Address[] addrArr = new Address[]{ new Address(hostname1, portnumber1)
                                 , new Address(hostname2, portnumber2)};
Connection conn = factory.newConnection(addrArr);
</pre>

<p>will attempt to connect to <span class="code ">hostname1:portnumber1</span>, and if
that fails to <span class="code ">hostname2:portnumber2</span>. The connection returned is
the first in the array that succeeds (without throwing
<span class="code ">IOException</span>). This is entirely equivalent to repeatedly
setting host and port on a factory, calling
<span class="code ">factory.newConnection()</span> each time, until one of them succeeds.</p>
<p>If an <span class="code ">ExecutorService</span> is provided as well (using the
form <span class="code ">factory.newConnection(es, addrArr)</span>) the thread pool is
associated with the (first) successful connection.</p>
<p>If you want more control over the host to connect to, see
<a href="#service-discovery-with-address-resolver">the support for service discovery</a>.</p>
<h2><a id="disconnecting" class="anchor" href="#disconnecting">Disconnecting from RabbitMQ</a></h2>
<p>To disconnect, simply close the channel and the connection:</p>
<pre class="lang-java">
channel.close();
conn.close();
</pre>

<p>Note that closing the channel may be considered good practice, but is not strictly necessary here - it will be done
automatically anyway when the underlying connection is closed.</p>
<p>Client disconnection events can be <a href="./networking.html#logging">observed in server node logs</a>.</p>
<h2><a id="connection-and-channel-lifespan" class="anchor" href="#connection-and-channel-lifespan">Connection and Channel Lifespan</a></h2>
<p>Client <a href="connections.html">connections</a> are meant to be long-lived. The underlying protocol is designed and optimized for
long running connections. That means that opening a new connection per operation,
e.g. a message published, is unnecessary and strongly discouraged as it will introduce a lot of
network roundtrips and overhead.</p>
<p><a href="channels.html">Channels</a> are also meant to be long-lived but since many recoverable protocol errors will
result in channel closure, channel lifespan could be shorter than that of its connection.
Closing and opening new channels per operation is usually unnecessary but can be
appropriate. When in doubt, consider reusing channels first.</p>
<p><a href="./channels.html#error-handling">Channel-level exceptions</a> such as attempts to consume from a
queue that does not exist will result in channel closure. A closed channel can no
longer be used and will not receive any more events from the server (such
as message deliveries). Channel-level exceptions will be logged by RabbitMQ
and will initiate a shutdown sequence for the channel (see below).</p>
<h2><a id="client-provided-names" class="anchor" href="#client-provided-names">Client-Provided Connection Name</a></h2>
<p>RabbitMQ nodes have a limited amount of information about their clients:</p>
<ul>
<li>their TCP endpoint (source IP address and port)</li>
<li>the credentials used</li>
</ul>
<p>This information alone can make identifying applications and instances problematic, in particular when credentials can be
shared and clients connect over a load balancer but <a href="./networking.html#proxy-protocol">Proxy protocol</a> cannot be enabled.</p>
<p>To make it easier to identify clients in <a href="./logging.html">server logs</a> and <a href="./management.html">management UI</a>,
AMQP 0-9-1 client connections, including the RabbitMQ Java client, can provide a custom identifier.
If set, the identifier will be mentioned in log entries and management UI. The identifier is known as
the <strong>client-provided connection name</strong>. The name can be used to identify an application or a specific component
within an application. The name is optional; however, developers are strongly encouraged to provide one
as it would significantly simplify certain operational tasks.</p>
<p>RabbitMQ Java client's <a href="https://rabbitmq.github.io/rabbitmq-java-client/api/current/com/rabbitmq/client/ConnectionFactory.html#newConnection(java.util.concurrent.ExecutorService,com.rabbitmq.client.Address%5B%5D,java.lang.String)"><span class="code ">ConnectionFactory#newConnection</span> method overrides</a>
accept a client-provided connection name. Here's a modified connection example used above
which provides such a name:</p>
<pre class="lang-java">
ConnectionFactory factory = new ConnectionFactory();
factory.setUri("amqp://userName:password@hostName:portNumber/virtualHost");
// provides a custom connection name
Connection conn = factory.newConnection("app:audit component:event-consumer");
</pre>

<h2><a id="exchanges-and-queues" class="anchor" href="#exchanges-and-queues">Using Exchanges and Queues</a></h2>
<p>Client applications work with [exchanges] and <a href="queues.html">queues</a>,
the high-level <a href="./tutorials/amqp-concepts.html">building blocks of the protocol</a>.
These must be declared before they can be used. Declaring either type of object
simply ensures that one of that name exists, creating it if necessary.</p>
<p>Continuing the previous example, the following code declares an exchange and a <a href="./queues.html#server-named-queues">server-named queue</a>,
then binds them together.</p>
<pre class="lang-java">channel.exchangeDeclare(exchangeName, "direct", true);
String queueName = channel.queueDeclare().getQueue();
channel.queueBind(queueName, exchangeName, routingKey);</pre>

<p>This will actively declare the following objects,
both of which can be customised by using additional parameters.
Here neither of them have any special arguments.</p>
<ul>
<li>a durable, non-autodelete exchange of "direct" type</li>
<li>a non-durable, exclusive, autodelete queue with a generated name</li>
</ul>
<p>The above function calls then bind the queue to the exchange with the
given routing key.</p>
<p>Note that this would be a typical way to declare a queue when only one
client wants to work with it: it doesn't need a well-known name, no
other client can use it (exclusive) and will be cleaned up
automatically (autodelete). If several clients want to share a queue
with a well-known name, this code would be appropriate:</p>
<pre class="lang-java">channel.exchangeDeclare(exchangeName, "direct", true);
channel.queueDeclare(queueName, true, false, false, null);
channel.queueBind(queueName, exchangeName, routingKey);</pre>

<p>This will actively declare:</p>
<ul>
<li>a durable, non-autodelete exchange of "direct" type</li>
<li>a durable, non-exclusive, non-autodelete queue with a well-known name</li>
</ul>
<p>Many <span class="code ">Channel</span> API methods are overloaded.
These convenient short forms of <span class="code ">exchangeDeclare</span>, <span class="code ">queueDeclare</span> and <span class="code ">queueBind</span>
use sensible defaults. There are also longer forms with more parameters, to let you override these defaults
as necessary, giving full control where needed.</p>
<p>This "short form, long form" pattern is used throughout the client API uses.</p>
<h3><a id="passive-declaration" class="anchor" href="#passive-declaration">Passive Declaration</a></h3>
<p>Queues and exchanges can be declared "passively". A passive declare simply checks that the entity
with the provided name exists. If it does, the operation is a no-op. For queues successful
passive declares will return the same information as non-passive ones, namely the number of
consumers and messages in <a href="./confirms.html">ready state</a> in the queue.</p>
<p>If the entity does not exist, the operation fails with a channel level exception. The channel
cannot be used after that. A new channel should be opened. It is common to use one-off (temporary)
channels for passive declarations.</p>
<p><span class="code ">Channel#queueDeclarePassive</span> and <span class="code ">Channel#exchangeDeclarePassive</span> are the
methods used for passive declaration. The following example demonstrates <span class="code ">Channel#queueDeclarePassive</span>:</p>
<pre class="lang-java">
Queue.DeclareOk response = channel.queueDeclarePassive("queue-name");
// returns the number of messages in Ready state in the queue
response.getMessageCount();
// returns the number of consumers the queue has
response.getConsumerCount();
</pre>

<p><span class="code ">Channel#exchangeDeclarePassive</span>'s return value contains no useful information. Therefore
if the method returns and no channel exceptions occurs, it means that the exchange does exist.</p>
<h3><a id="nowait-methods" class="anchor" href="#nowait-methods">Operations with Optional Responses</a></h3>
<p>Some common operations also have a "no wait" version which won't wait for server
response. For example, to declare a queue and instruct the server to not send any
response, use</p>
<pre class="lang-java">channel.queueDeclareNoWait(queueName, true, false, false, null);</pre>

<p>The "no wait" versions are more efficient but offer lower safety guarantees, e.g. they
are more dependent on the <a href="./heartbeats.html">heartbeat mechanism</a> for detection of failed operations.
When in doubt, start with the standard version. The "no wait" versions are only needed in scenarios
with high topology (queue, binding) churn.</p>
<h3><a id="deleting-entities" class="anchor" href="#deleting-entities">Deleting Entities and Purging Messages</a></h3>
<p>A queue or exchange can be explicitly deleted:</p>
<pre class="lang-java">channel.queueDelete("queue-name")</pre>

<p>It is possible to delete a queue only if it is empty:</p>
<pre class="lang-java">channel.queueDelete("queue-name", false, true)</pre>

<p>or if it is not used (does not have any consumers):</p>
<pre class="lang-java">channel.queueDelete("queue-name", true, false)</pre>

<p>A queue can be purged (all of its messages deleted):</p>
<pre class="lang-java">channel.queuePurge("queue-name")</pre>

<h2><a id="publishing" class="anchor" href="#publishing">Publishing Messages</a></h2>
<p>To publish a message to an exchange, use <span class="code ">Channel.basicPublish</span> as follows:</p>
<pre class="lang-java">
byte[] messageBodyBytes = "Hello, world!".getBytes();
channel.basicPublish(exchangeName, routingKey, null, messageBodyBytes);
</pre>

<p>For fine control, use overloaded variants to specify the <span class="code ">mandatory</span> flag,
or send messages with pre-set message properties (see the <a href="./publishers.html">Publishers guide</a> for details):</p>
<pre class="lang-java">
channel.basicPublish(exchangeName, routingKey, mandatory,
                     MessageProperties.PERSISTENT_TEXT_PLAIN,
                     messageBodyBytes);
</pre>

<p>This sends a message with delivery mode 2 (persistent), priority 1
and content-type "text/plain". Use the <span class="code ">Builder</span> class to build a
message properties object with as many properties as needed, for example:</p>
<pre class="lang-java">
channel.basicPublish(exchangeName, routingKey,
             new AMQP.BasicProperties.Builder()
               .contentType("text/plain")
               .deliveryMode(2)
               .priority(1)
               .userId("bob")
               .build(),
               messageBodyBytes);
</pre>

<p>This example publishes a message with custom headers:</p>
<pre class="lang-java">
Map&lt;String, Object&gt; headers = new HashMap&lt;String, Object&gt;();
headers.put("latitude",  51.5252949);
headers.put("longitude", -0.0905493);

channel.basicPublish(exchangeName, routingKey,
             new AMQP.BasicProperties.Builder()
               .headers(headers)
               .build(),
               messageBodyBytes);
</pre>

<p>This example publishes a message with expiration:</p>
<pre class="lang-java">
channel.basicPublish(exchangeName, routingKey,
             new AMQP.BasicProperties.Builder()
               .expiration("60000")
               .build(),
               messageBodyBytes);
</pre>

<p>This is just a brief set of examples that does not demonstrate every
supported property.</p>
<p>Note that <span class="code ">BasicProperties</span> is an inner class of an outer class, <span class="code ">AMQP</span>.</p>
<p>Invocations of <span class="code ">Channel#basicPublish</span> will eventually block if a
<a href="https://www.rabbitmq.com/alarms.html">resource-driven alarm</a> is in effect.</p>
<h2><a id="concurrency" class="anchor" href="#concurrency">Channels and Concurrency Considerations (Thread Safety)</a></h2>
<p>As a rule of thumb, sharing <span class="code ">Channel</span> instances between
threads is something to be avoided. Applications
should prefer using a <span class="code ">Channel</span> per thread
instead of sharing the same <span class="code ">Channel</span> across
multiple threads.</p>
<p>While some operations on channels are safe to invoke
concurrently, some are not and will result in incorrect frame interleaving
on the wire, double acknowledgements and so on.</p>
<p>Concurrent publishing on a shared channel can result in
incorrect frame interleaving on the wire, triggering a
connection-level protocol exception and immediate connection closure by the broker.
It therefore requires explicit synchronization in application
code (<span class="code ">Channel#basicPublish</span> must be invoked in a
critical section). Sharing channels between threads will also
interfere with <a href="confirms.html">Publisher
Confirms</a>. Concurrent publishing on a shared channel is best avoided entirely,
e.g. by using a channel per thread.</p>
<p>It is possible to use channel pooling to avoid concurrent
publishing on a shared channel: once a thread is done working
with a channel, it returns it to the pool, making the
channel available for another thread. Channel pooling can be
thought of as a specific synchronization solution. It is
recommended that an existing pooling library is used
instead of a homegrown solution. For example, <a href="https://projects.spring.io/spring-amqp/">Spring AMQP</a>
which comes with a ready-to-use channel pooling feature.</p>
<p>Channels consume resources and in most cases applications very rarely need more than a few hundreds
open channels in the same JVM process. If we assume that the application
has a thread for each channel (as channel shouldn't be used concurrently), thousands
of threads for a single JVM is already a fair amount of overhead that likely can be avoided.
Moreover a few fast publishers can easily saturate a network interface and a broker node:
publishing involves less work than routing, storing and delivering messages.</p>
<p>A classic anti-pattern to be avoided is opening a channel for each published message. Channels
are supposed to be reasonably long-lived and opening a new one is a network round-trip which
makes this pattern extremely inefficient.</p>
<p>Consuming in one thread and publishing in another thread on a shared channel
can be safe.</p>
<p>Server-pushed deliveries (see the section below) are
dispatched concurrently with a guarantee that per-channel
ordering is preserved.  The dispatch mechanism uses a <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html"><span class="code ">java.util.concurrent.ExecutorService</span></a>,
one per connection.  It is possible to provide a custom
executor that will be shared by all connections produced by a
single <span class="code ">ConnectionFactory</span> using the <span class="code ">ConnectionFactory#setSharedExecutor</span> setter.</p>
<p>When <a href="confirms.html">manual acknowledgements</a> are used, it is important
to consider what thread does the acknowledgement. If it's different from the
thread that received the delivery (e.g. <span class="code ">Consumer#handleDelivery</span>
delegated delivery handling to a different thread), acknowledging
with the <span class="code ">multiple</span> parameter set to <span class="code ">true</span> is unsafe
and will result in double-acknowledgements, and therefore a channel-level protocol
exception that closes the channel. Acknowledging a single message at a time
can be safe.</p>
<h2><a id="consuming" class="anchor" href="#consuming">Receiving Messages by Subscription ("Push API")</a></h2>
<pre class="lang-java">
import com.rabbitmq.client.Consumer;
import com.rabbitmq.client.DefaultConsumer;
</pre>

<p>The most efficient way to receive messages is to set up a
subscription using the <span class="code ">Consumer</span>
interface. The messages will then be delivered
automatically as they arrive, rather than having to be
explicitly requested.</p>
<p>When calling the API methods relating to
<span class="code ">Consumer</span>s, individual subscriptions are
always referred to by their consumer tags. A consumer tag is a consumer
identifier which can be either client- or server-generated. To let
RabbitMQ generate a node-wide unique tag, use a <span class="code ">Channel#basicConsume</span> override
that doesn't take a consumer tag argument or pass an empty string
for consumer tag and use the value returned by <span class="code ">Channel#basicConsume</span>.
Consumer tags are used to cancel consumers.</p>
<p>Distinct <span class="code ">Consumer</span> instances must have distinct
consumer tags. Duplicate consumer tags on a connection is
strongly discouraged and can lead to issues with <a href="#connection-recovery">automatic
connection recovery</a> and confusing monitoring data when
consumers are monitored.</p>
<p>The easiest way to implement a <span class="code ">Consumer</span> is to
subclass the convenience class <span class="code ">DefaultConsumer</span>.
An object of this subclass can be passed on a <span class="code ">basicConsume</span>
call to set up the subscription:</p>
<pre class="lang-java">
boolean autoAck = false;
channel.basicConsume(queueName, autoAck, "myConsumerTag",
     new DefaultConsumer(channel) {
         @Override
         public void handleDelivery(String consumerTag,
                                    Envelope envelope,
                                    AMQP.BasicProperties properties,
                                    byte[] body)
             throws IOException
         {
             String routingKey = envelope.getRoutingKey();
             String contentType = properties.getContentType();
             long deliveryTag = envelope.getDeliveryTag();
             <i>// (process the message components here ...)</i>
             channel.basicAck(deliveryTag, false);
         }
     });
</pre>

<p>Here, since we specified <span class="code ">autoAck = false</span>,
it is necessary to acknowledge messages delivered to the <span class="code ">Consumer</span>,
most conveniently done in the <span class="code ">handleDelivery</span>
method, as illustrated.</p>
<p>More sophisticated <span class="code ">Consumer</span>s will need to override further
methods.  In particular, <span class="code ">handleShutdownSignal</span>
is called when channels and connections close, and
<span class="code ">handleConsumeOk</span> is passed the consumer tag
before any other callbacks to that <span class="code ">Consumer</span> are called.</p>
<p><span class="code ">Consumer</span>s can also implement the
<span class="code ">handleCancelOk</span> and <span class="code ">handleCancel</span>
methods to be notified of explicit and implicit cancellations,
respectively.</p>
<p>You can explicitly cancel a particular <span class="code ">Consumer</span> with
<span class="code ">Channel.basicCancel</span>:</p>
<pre class="lang-java">channel.basicCancel(consumerTag);</pre>

<p>passing the consumer tag.</p>
<p>Just like with publishers, it is important to consider concurrency
hazard safety for consumers.</p>
<p>Callbacks to <span class="code ">Consumer</span>s are dispatched in a thread
pool separate from the thread that instantiated its
<span class="code ">Channel</span>.  This means that <span class="code ">Consumer</span>s
can safely call blocking methods on the
<span class="code ">Connection</span> or <span class="code ">Channel</span>, such as
<span class="code ">Channel#queueDeclare</span> or <span class="code ">Channel#basicCancel</span>.</p>
<p>Each <span class="code ">Channel</span> will dispatch all deliveries to its <span class="code ">Consumer</span> handler methods on it
in order they were sent by RabbitMQ.
Ordering of deliveries between channels is not guaranteed: those
deliveries can be dispatched in parallel.</p>
<p>For the most common use case of one <span class="code ">Consumer</span> per
<span class="code ">Channel</span>, this means <span class="code ">Consumer</span>s do
not hold up other <span class="code ">Consumer</span>s.
With multiple <span class="code ">Consumer</span>s per <span class="code ">Channel</span> be aware that
a long-running <span class="code ">Consumer</span> may hold up dispatch of
callbacks to other <span class="code ">Consumer</span>s on that
<span class="code ">Channel</span>.</p>
<p>Please refer to the <a href="#concurrency">Concurrency Considerations</a> (Thread Safety)
section for other topics related to concurrency and
concurrency hazard safety.</p>
<h2><a id="getting" class="anchor" href="#getting">Retrieving Individual Messages ("Pull API")</a></h2>
<p>It is also possible to retrieve individual messages on demand ("pull API" a.k.a. polling).
This approach to consumption is highly inefficient as it is effectively polling
and applications repeatedly have to ask for results even if the vast majority of the requests
yield no results. Therefore using this approach <strong>is highly discouraged</strong>.</p>
<p>To "pull" a message, use the <span class="code ">Channel.basicGet</span> method.  The returned value is an
instance of <span class="code ">GetResponse</span>, from which the header information (properties)
and message body can be extracted:</p>
<pre class="lang-java">
boolean autoAck = false;
GetResponse response = channel.basicGet(queueName, autoAck);
if (response == null) {
    // No message retrieved.
} else {
    AMQP.BasicProperties props = response.getProps();
    byte[] body = response.getBody();
    long deliveryTag = response.getEnvelope().getDeliveryTag();
    // ...
</pre>

<p>and since this example uses <a href="./confirms.html">manual acknowledgements</a> (the <span class="code ">autoAck = false</span> above),
you must also call <span class="code ">Channel.basicAck</span> to acknowledge that you have successfully received the message:</p>
<pre class="lang-java">
// ...
channel.basicAck(method.deliveryTag, false); // acknowledge receipt of the message
}
</pre>

<h2><a id="returning" class="anchor" href="#returning">Handling unroutable messages</a></h2>
<p>If a message is published with the "mandatory" flags set,
but cannot be routed, the broker will return it to the
sending client (via an <span class="code ">AMQP.Basic.Return</span>
command).</p>
<p>To be notified of such returns, clients can implement the <span class="code ">ReturnListener</span>
interface and call <span class="code ">Channel.addReturnListener</span>.
If the client has not configured a return listener for a particular channel,
then the associated returned messages will be silently dropped.</p>
<pre class="lang-java">
channel.addReturnListener(new ReturnListener() {
    public void handleReturn(int replyCode,
                                  String replyText,
                                  String exchange,
                                  String routingKey,
                                  AMQP.BasicProperties properties,
                                  byte[] body)
    throws IOException {
        ...
    }
});</pre>

<p>A return listener will be called, for example, if the client publishes a message with
the "mandatory" flag set to an exchange of "direct" type which is not bound to a queue.</p>
<h2><a id="shutdown" class="anchor" href="#shutdown">Shutdown Protocol</a></h2>
<h3><a id="shutdown-overview" class="anchor" href="#shutdown-overview">Overview of the Client Shutdown Process</a></h3>
<p>The AMQP 0-9-1 connection and channel share the same general
approach to managing network failure, internal failure,
and explicit local shutdown.</p>
<p>The AMQP 0-9-1 connection and channel have the following lifecycle states:</p>
<ul>
<li><span class="code ">open</span>: the object is ready to use</li>
<li>
<p><span class="code ">closing</span>: the object has been explicitly
   notified to shut down locally, has issued a shutdown
   request to any supporting lower-layer objects, and is
   waiting for their shutdown procedures to complete</p>
</li>
<li>
<p><span class="code ">closed</span>: the object has received all
   shutdown-complete notification(s) from any lower-layer
   objects, and as a consequence has shut itself down</p>
</li>
</ul>
<p>Those objects always end up in the closed state,
regardless of the reason that caused the closure, like
an application request, an internal client library
failure, a remote network request or network failure.</p>
<p>The connection and channel objects possess the
following shutdown-related methods:</p>
<ul>
<li>
<p><span class="code ">addShutdownListener(ShutdownListener listener)</span> and</p>
</li>
<li>
<p><span class="code ">removeShutdownListener(ShutdownListener listener)</span>, to manage any listeners, which will
    be fired when the object transitions to
    <span class="code ">closed</span> state. Note that, adding a
    ShutdownListener to an object that is already closed
    will fire the listener immediately</p>
</li>
<li>
<p><span class="code ">getCloseReason()</span>, to allow the
    investigation of what was the reason of the object's
    shutdown</p>
</li>
<li>
<p><span class="code ">isOpen()</span>, useful for testing whether the
    object is in an open state</p>
</li>
<li>
<p><span class="code ">close(int closeCode, String closeMessage)</span>, to explicitly notify the object
    to shut down</p>
</li>
</ul>
<p>Simple usage of listeners would look like:</p>
<pre class="lang-java">import com.rabbitmq.client.ShutdownSignalException;
import com.rabbitmq.client.ShutdownListener;

connection.addShutdownListener(new ShutdownListener() {
    public void shutdownCompleted(ShutdownSignalException cause)
    {
        ...
    }
});
</pre>

<h3><a id="shutdown-cause" class="anchor" href="#shutdown-cause">Information about the circumstances of a shutdown</a></h3>
<p>One can retrieve the <span class="code ">ShutdownSignalException</span>, which contains all
the information available about the close reason, either
by explicitly calling the <span class="code ">getCloseReason()</span>
method or by using the <span class="code ">cause</span> parameter in
the <span class="code ">service(ShutdownSignalException cause)</span>
method of the <span class="code ">ShutdownListener</span> class.</p>
<p>The <span class="code ">ShutdownSignalException</span> class provides
methods to analyze the reason of the shutdown. By
calling the <span class="code ">isHardError()</span> method we get
information whether it was a connection or a channel
error, and <span class="code ">getReason()</span> returns information
about the cause, in the form an AMQP method - either
<span class="code ">AMQP.Channel.Close</span> or
<span class="code ">AMQP.Connection.Close</span> (or null if the cause
was some exception in the library, such as a network
communication failure, in which case that exception can
be retrieved with <span class="code ">getCause()</span>).</p>
<pre class="lang-java">public void shutdownCompleted(ShutdownSignalException cause)
{
  if (cause.isHardError())
  {
    Connection conn = (Connection)cause.getReference();
    if (!cause.isInitiatedByApplication())
    {
      Method reason = cause.getReason();
      ...
    }
    ...
  } else {
    Channel ch = (Channel)cause.getReference();
    ...
  }
}</pre>

<h3><a id="shutdown-atomicity" class="anchor" href="#shutdown-atomicity">Atomicity and use of the isOpen() method</a></h3>
<p>Use of the <span class="code ">isOpen()</span> method of channel and
 connection objects is not recommended for production
 code, because the value returned by the method is
 dependent on the existence of the shutdown cause.  The
 following code illustrates the possibility of race
 conditions:</p>
<pre class="lang-java">public void brokenMethod(Channel channel)
{
    if (channel.isOpen())
    {
        // The following code depends on the channel being in open state.
        // However there is a possibility of the change in the channel state
        // between isOpen() and basicQos(1) call
        ...
        channel.basicQos(1);
    }
}
</pre>

<p>Instead, we should normally ignore such checking, and
simply attempt the action desired. If during the
execution of the code the channel of the connection is
closed, a <span class="code ">ShutdownSignalException</span> will be
thrown indicating that the object is in an invalid
state. We should also catch for <span class="code ">IOException</span>
caused either by <span class="code ">SocketException</span>, when
broker closes the connection unexpectedly, or
<span class="code ">ShutdownSignalException</span>, when broker
initiated clean close.</p>
<pre class="lang-java">
public void validMethod(Channel channel)
{
    try {
        ...
        channel.basicQos(1);
    } catch (ShutdownSignalException sse) {
        // possibly check if channel was closed
        // by the time we started action and reasons for
        // closing it
        ...
    } catch (IOException ioe) {
        // check why connection was closed
        ...
    }
}
</pre>

<h2><a id="advanced-connection" class="anchor" href="#advanced-connection">Advanced Connection options</a></h2>
<h3><a id="consumer-thread-pool" class="anchor" href="#consumer-thread-pool">Consumer Operation Thread Pool</a></h3>
<p><span class="code ">Consumer</span> threads (see <a href="#consuming">Receiving</a> below) are
automatically allocated in a new <span class="code ">ExecutorService</span> thread pool
by default. If greater control is required supply an <span class="code ">ExecutorService</span> on the
<span class="code ">newConnection()</span> method, so that this pool of threads is
used instead. Here is an example where a larger thread pool is
supplied than is normally allocated:</p>
<pre class="lang-java">
ExecutorService es = Executors.newFixedThreadPool(20);
Connection conn = factory.newConnection(es);
</pre>

<p>Both <span class="code ">Executors</span> and <span class="code ">ExecutorService</span> classes
are in the <span class="code ">java.util.concurrent</span> package.</p>
<p>When the connection is closed a default <span class="code ">ExecutorService</span>
will be <span class="code ">shutdown()</span>, but a user-supplied
<span class="code ">ExecutorService</span> (like <span class="code ">es</span> above) will
<i>not</i> be <span class="code ">shutdown()</span>.
Clients that supply a custom <span class="code ">ExecutorService</span> must ensure
it is shutdown eventually (by calling its <span class="code ">shutdown()</span>
method), or else the pool's threads may prevent JVM termination.</p>
<p>The same executor service may be shared between multiple connections,
or serially re-used on re-connection but it cannot be used after it is
<span class="code ">shutdown()</span>.</p>
<p>Use of this feature should only be considered if there is evidence
that there is a severe bottleneck in the processing of <span class="code ">Consumer</span>
callbacks.
If there are no <span class="code ">Consumer</span> callbacks executed, or very few, the default
allocation is more than sufficient. The overhead is initially minimal and
the total thread resources allocated are bounded, even if a burst of consumer
activity may occasionally occur.</p>
<h3><a id="service-discovery-with-address-resolver" class="anchor" href="#service-discovery-with-address-resolver">Service discovery with the AddressResolver interface</a></h3>
<p>It is possible to use an implementation of <span class="code ">AddressResolver</span> to change the endpoint resolution algorithm
used at connection time:</p>
<pre class="lang-java">
Connection conn = factory.newConnection(addressResolver);
</pre>

<p>The <span class="code ">AddressResolver</span> interface is like the following:</p>
<pre class="lang-java">
public interface AddressResolver {

  List&lt;Address&gt; getAddresses() throws IOException;

}
</pre>

<p>Just like with <a href="#endpoints-list">a list of endpoints</a>,
the first <span class="code ">Address</span> returned will be tried first, then
the second if the client fails to connect to the first, and so on.</p>
<p>If an <span class="code ">ExecutorService</span> is provided as well (using the
form <span class="code ">factory.newConnection(es, addressResolver)</span>) the thread pool is
associated with the (first) successful connection.</p>
<p>The <span class="code ">AddressResolver</span> is the perfect place to implement
custom service discovery logic, which is especially useful in a dynamic
infrastructure. Combined with <a href="#recovery">automatic recovery</a>,
the client can automatically connect to nodes that weren't even up
when it was first started. Affinity and load balancing are other
scenarios where a custom <span class="code ">AddressResolver</span> could be useful.</p>
<p>The Java client ships with the following implementations
(see the javadoc for details):</p>
<ul>
<li>
<p><span class="code ">DnsRecordIpAddressResolver</span>: given the name
   of a host, returns its IP addresses (resolution against
   the platform DNS server). This can be useful for simple
   DNS-based load balancing or failover.</p>
</li>
<li>
<p><span class="code ">DnsSrvRecordAddressResolver</span>: given the name
   of a service, returns hostname/port pairs. The search is
   implemented as a DNS SRV request. This can be useful
   when using a service registry like <a href="https://www.consul.io/">HashiCorp Consul</a>.</p>
</li>
</ul>
<h3><a id="heartbeats-timeout" class="anchor" href="#heartbeats-timeout">Heartbeat Timeout</a></h3>
<p>See the <a href="heartbeats.html">Heartbeats guide</a> for more information about heartbeats and how to configure them in the Java client.</p>
<h3><a id="thread-factories" class="anchor" href="#thread-factories">Custom Thread Factories</a></h3>
<p>Environments such as Google App Engine (GAE) can <a href="https://developers.google.com/appengine/docs/java/#Java_The_sandbox">restrict
direct thread instantiation</a>. To use RabbitMQ Java client in such environments,
it's necessary to configure a custom <span class="code ">ThreadFactory</span> that uses
an appropriate method to instantiate threads, e.g. GAE's <span class="code ">ThreadManager</span>.</p>
<p>Below is an example for Google App Engine.</p>
<pre class="lang-java">
import com.google.appengine.api.ThreadManager;

ConnectionFactory cf = new ConnectionFactory();
cf.setThreadFactory(ThreadManager.backgroundThreadFactory());
</pre>

<h3><a id="java-nio" class="anchor" href="#java-nio">Support for Java non-blocking IO</a></h3>
<p>Version 4.0 of the Java client brings support for Java non-blocking
IO (a.k.a Java NIO). NIO isn't supposed to be faster than blocking IO,
it simply allows to control resources (in this case, threads) more easily.</p>
<p>With the default blocking IO mode, each connection uses a thread to read
from the network socket. With the NIO mode, you can control the number of
threads that read and write from/to the network socket.</p>
<p>Use the NIO mode if your Java process uses many connections (dozens or hundreds).
You should use fewer threads than with the default blocking mode. With the
appropriate number of threads set, you shouldn't
experience any decrease in performance, especially if the connections are
not so busy.</p>
<p>NIO must be enabled explicitly:</p>
<pre class="lang-java">
ConnectionFactory connectionFactory = new ConnectionFactory();
connectionFactory.useNio();
</pre>

<p>The NIO mode can be configured through the <span class="code ">NioParams</span> class:</p>
<pre class="lang-java">
  connectionFactory.setNioParams(new NioParams().setNbIoThreads(4));
</pre>

<p>The NIO mode uses reasonable defaults, but you may need to change them according
to your own workload. Some of the settings are: the total number of IO
threads used, the size of buffers, a service executor to use for the IO loops,
parameters for the in-memory write queue (write requests are enqueued before
being sent on the network). Please read the Javadoc for details and defaults.</p>
<h2><a id="recovery" class="anchor" href="#recovery">Automatic Recovery From Network Failures</a></h2>
<h3><a id="connection-recovery" class="anchor" href="#connection-recovery">Connection Recovery</a></h3>
<p>Network connection between clients and RabbitMQ nodes can fail.
RabbitMQ Java client supports automatic recovery of connections
and topology (queues, exchanges, bindings, and consumers).</p>
<p>The automatic recovery process for many applications follows the following steps:</p>
<ul>
<li>Reconnect</li>
<li>Restore connection listeners</li>
<li>Re-open channels</li>
<li>Restore channel listeners</li>
<li>Restore channel <span class="code ">basic.qos</span> setting, publisher confirms and transaction settings</li>
</ul>
<p>Topology recovery includes the following actions, performed for every channel</p>
<ul>
<li>Re-declare exchanges (except for predefined ones)</li>
<li>Re-declare queues</li>
<li>Recover all bindings</li>
<li>Recover all consumers</li>
</ul>
<p>As of version 4.0.0 of the Java client, automatic recovery is enabled
by default (and thus topology recovery as well).</p>
<p>Topology recovery relies on a per-connection cache of entities (queues, exchanges,
bindings, consumers). When, say, a queue is declared on a connection, it will be added to the cache.
When it is deleted or is scheduled for deletion (e.g. because it is <a href="queues.html">auto-deleted</a>)
it will be removed. This model has some limitations covered below.</p>
<p>To disable or enable automatic connection recovery, use
the <span class="code ">factory.setAutomaticRecoveryEnabled(boolean)</span>
method. The following snippet shows how to explicitly
enable automatic recovery (e.g. for Java client prior 4.0.0):</p>
<pre class="lang-java">
ConnectionFactory factory = new ConnectionFactory();
factory.setUsername(userName);
factory.setPassword(password);
factory.setVirtualHost(virtualHost);
factory.setHost(hostName);
factory.setPort(portNumber);
factory.setAutomaticRecoveryEnabled(true);
// connection that will recover automatically
Connection conn = factory.newConnection();</pre>

<p>If recovery fails due to an exception (e.g. RabbitMQ node is
still not reachable), it will be retried after a fixed time interval (default
is 5 seconds). The interval can be configured:</p>
<pre class="lang-java">
ConnectionFactory factory = new ConnectionFactory();
// attempt recovery every 10 seconds
factory.setNetworkRecoveryInterval(10000);</pre>

<p>When a list of addresses is provided, the list is shuffled and
all addresses are tried, one after the next:</p>
<pre class="lang-java">
ConnectionFactory factory = new ConnectionFactory();

Address[] addresses = {new Address("192.168.1.4"), new Address("192.168.1.5")};
factory.newConnection(addresses);</pre>

<h3><a id="recovery-triggers" class="anchor" href="#recovery-triggers">When Will Connection Recovery Be Triggered?</a></h3>
<p>Automatic connection recovery, if enabled, will be triggered by the following events:</p>
<ul>
<li>An I/O exception is thrown in connection's I/O loop</li>
<li>A socket read operation times out</li>
<li>Missed server <a href="./heartbeats.html">heartbeats</a> are detected</li>
<li>Any other unexpected exception is thrown in connection's I/O loop</li>
</ul>
<p>whichever happens first.</p>
<p>If initial client connection to a RabbitMQ node fails, automatic connection
recovery won't kick in. Applications developers are responsible for retrying
such connections, logging failed attempts, implementing a limit to the number
of retries and so on. Here's a very basic example:</p>
<pre class="lang-java">
ConnectionFactory factory = new ConnectionFactory();
// configure various connection settings

try {
  Connection conn = factory.newConnection();
} catch (java.net.ConnectException e) {
  Thread.sleep(5000);
  // apply retry logic
}
</pre>

<p>When a connection is closed by the application via the <span class="code ">Connection.Close</span> method,
connection recovery will not be initiated.</p>
<p>Channel-level exceptions will not trigger any kind of recovery as they usually
indicate a semantic issue in the application (e.g. an attempt to consume from a
non-existent queue).</p>
<h3><a id="recovery-listeners" class="anchor" href="#recovery-listeners">Recovery Listeners</a></h3>
<p>It is possible to register one or more recovery listeners on recoverable connections
and channels. When connection recovery is enabled, connections returned by
<span class="code ">ConnectionFactory#newConnection</span> and <span class="code ">Connection#createChannel</span>
implement <span class="code ">com.rabbitmq.client.Recoverable</span>, providing two methods with
fairly descriptive names:</p>
<ul>
<li><span class="code ">addRecoveryListener</span></li>
<li><span class="code ">removeRecoveryListener</span></li>
</ul>
<p>Note that you currently need to cast connections and channels to <span class="code ">Recoverable</span>
in order to use those methods.</p>
<h3><a id="publishers" class="anchor" href="#publishers">Effects on Publishing</a></h3>
<p>Messages that are published using <span class="code ">Channel.basicPublish</span> when connection is down
will be lost. The client does not enqueue them for delivery after connection has recovered.
To ensure that published messages reach RabbitMQ applications need to use <a href="confirms.html">Publisher Confirms</a>
and account for connection failures.</p>
<h3><a id="topology-recovery" class="anchor" href="#topology-recovery">Topology Recovery</a></h3>
<p>Topology recovery involves recovery of exchanges, queues, bindings
and consumers. It is enabled by default when automatic recovery is
enabled. Topology recovery is enabled by default in modern versions of the client.</p>
<p>Topology recovery can be disabled explicitly if needed:</p>
<pre class="lang-java">
ConnectionFactory factory = new ConnectionFactory();

Connection conn = factory.newConnection();
// enable automatic recovery (e.g. Java client prior 4.0.0)
factory.setAutomaticRecoveryEnabled(true);
// disable topology recovery
factory.setTopologyRecoveryEnabled(false);
</pre>

<h3><a id="automatic-recovery-limitations" class="anchor" href="#automatic-recovery-limitations">Failure Detection and Recovery Limitations</a></h3>
<p>Automatic connection recovery has a number of limitations and intentional
design decisions that applications developers need to be aware of.</p>
<p>Topology recovery relies on a per-connection cache of entities (queues, exchanges,
bindings, consumers). When, say, a queue is declared on a connection, it will be added to the cache.
When it is deleted or is scheduled for deletion (e.g. because it is <a href="queues.html">auto-deleted</a>)
it will be removed. This makes it possible to declare and delete entities on different
channels without having unexpected results. It also means that consumer tags (a channel-specific identifier)
must be unique across all channels on connections that use automatic connection recovery.</p>
<p>When a connection is down or lost, it <a href="./heartbeats.html">takes time to detect</a>.
Therefore there is a window of time in which both the
library and the application are unaware of effective
connection failure.  Any messages published during this
time frame are serialised and written to the TCP socket
as usual. Their delivery to the broker can only be
guaranteed via <a href="./confirms.html">publisher
confirms</a>: publishing in AMQP 0-9-1 is entirely
asynchronous by design.</p>
<p>When a socket or I/O operation error is detected by a
connection with automatic recovery enabled, recovery
begins after a configurable delay, 5 seconds by
default. This design assumes that even though a lot of
network failures are transient and generally short
lived, they do not go away in an instant. Having a delay
also avoids an inherent race condition between server-side resource
cleanup (such as <a href="queues.html">exclusive or auto-delete queue</a> deletion)
and operations performed on a newly opened connection on the same resources.</p>
<p>Connection recovery attempts by default will continue at identical time intervals until
a new connection is successfully opened.
Recovery delay can be made dynamic by providing a <span class="code ">RecoveryDelayHandler</span>
implementation instance to <span class="code ">ConnectionFactory#setRecoveryDelayHandler</span>.
Implementations that use dynamically computed delay intervals should avoid
values that are too low (as a rule of thumb, lower than 2 seconds).</p>
<p>When a connection is in the recovering state, any
publishes attempted on its channels will be rejected
with an exception. The client currently does not perform
any internal buffering of such outgoing messages. It is
an application developer's responsibility to keep track of such
messages and republish them when recovery succeeds.
<a href="./confirms.html">Publisher confirms</a> is a protocol extension
that should be used by publishers that cannot afford message loss.</p>
<p>Connection recovery will not kick in when a channel is closed due to a
channel-level exception. Such exceptions often indicate application-level
issues. The library cannot make an informed decision about when that's
the case.</p>
<p>Closed channels won't be recovered even after connection recovery kicks in.
This includes both explicitly closed channels and the channel-level exception
case above.</p>
<h3><a id="recovery-and-acknowledgements" class="anchor" href="#recovery-and-acknowledgements">Manual Acknowledgements and Automatic Recovery</a></h3>
<p>When manual acknowledgements are used, it is possible that
network connection to RabbitMQ node fails between message
delivery and acknowledgement. After connection recovery,
RabbitMQ will reset delivery tags on all channels.</p>
<p>This means that <i>basic.ack</i>, <i>basic.nack</i>, and <i>basic.reject</i>
with old delivery tags will cause a channel exception. To avoid this,
RabbitMQ Java client keeps track of and updates delivery tags to make them monotonically
growing between recoveries.</p>
<p><span class="code ">Channel.basicAck</span>,
<span class="code ">Channel.basicNack</span>, and
<span class="code ">Channel.basicReject</span> then translate adjusted
delivery tags into those used by RabbitMQ.</p>
<p>Acknowledgements with stale delivery tags will not be sent. Applications
that use manual acknowledgements and automatic recovery must
be capable of handling redeliveries.</p>
<h3><a id="recovery-channel-lifecycle" class="anchor" href="#recovery-channel-lifecycle">Channels Lifecycle and Topology Recovery</a></h3>
<p>Automatic connection recovery is meant to be as transparent as possible
for the application developer, that's why <span class="code ">Channel</span> instances
remain the same even if several connections fail and recover behind the scenes.
Technically, when automatic recovery is on, <span class="code ">Channel</span> instances
act as proxies or decorators: they delegate the AMQP business to an
actual AMQP channel implementation and implement some recovery machinery around it.
That is why you shouldn't close a channel after it has created some resources
(queues, exchanges, bindings) or topology recovery for those resources
will fail later, as the channel has been closed. Instead, leave creating channels open
for the life of the application.</p>
<h2><a id="unhandled-exceptions" class="anchor" href="#unhandled-exceptions">Unhandled Exceptions</a></h2>
<p>Unhandled exceptions related to connection, channel, recovery,
and consumer lifecycle are delegated to the exception
handler. Exception handler is any object that implements the
<span class="code ">ExceptionHandler</span> interface.  By default, an
instance of <span class="code ">DefaultExceptionHandler</span> is used. It
prints exception details to the standard output.</p>
<p>It is possible to override the handler using
<span class="code ">ConnectionFactory#setExceptionHandler</span>. It will be
used for all connections created by the factory:</p>
<pre class="lang-java">
ConnectionFactory factory = new ConnectionFactory();
cf.setExceptionHandler(customHandler);
</pre>

<p>Exception handlers should be used for exception logging.</p>
<h2><a id="metrics" class="anchor" href="#metrics">Metrics and Monitoring</a></h2>
<p>The client collects runtime metrics (e.g. number
of published messages) for active connections. Metric collection is optional feature that should be set up
at the <span class="code ">ConnectionFactory</span> level, using the <span class="code ">setMetricsCollector(metricsCollector)</span> method.
This method expects a <span class="code ">MetricsCollector</span> instance, which is
called in several places of the client code.</p>
<p>The client supports <a href="http://micrometer.io">Micrometer</a> (as of version 4.3) and
<a href="http://metrics.dropwizard.io">Dropwizard Metrics</a>
out of the box.</p>
<p>Here are the collected metrics:</p>
<ul>
<li>Number of open connections</li>
<li>Number of open channels</li>
<li>Number of published messages</li>
<li>Number of consumed messages</li>
<li>Number of acknowledged messages</li>
<li>Number of rejected messages</li>
</ul>
<p>Both Micrometer and Dropwizard Metrics provide counts, but also
mean rate, last five minute rate, etc, for messages-related
metrics. They also support common tools for monitoring and reporting
(JMX, Graphite, Ganglia, Datadog, etc). See the dedicated
sections below for more details.</p>
<p>Developers should keep a few things in mind when enabling metric collection.</p>
<ul>
<li>Don't forget to add the appropriate dependencies (in Maven, Gradle, or even as JAR files) to JVM
   classpath when using Micrometer or Dropwizard Metrics.
   Those are optional dependencies and will not be pulled automatically with the Java client.
   You may also need to add other dependencies depending on the reporting
   backend(s) used.</li>
<li>Metrics collection is extensible. Implementing a custom
   <span class="code ">MetricsCollector</span> for specific needs is encouraged.</li>
<li>The <span class="code ">MetricsCollector</span> is set at the <span class="code ">ConnectionFactory</span>
   level but can be shared across different instances.</li>
<li>Metrics collection doesn't support transactions. E.g. if an acknowledgment
   is sent in a transaction and the transaction is then rolled back,
   the acknowledgment is counted in the client metrics (but not by the broker
   obviously). Note the acknowledgment is actually sent to the broker and
   then cancelled by the transaction rollback, so the client metrics
   are correct in term of acknowledgments sent. As a summary, don't use
   client metrics for critical business logic, they're not guaranteed
   to be perfectly accurate. They are meant to be used to simplify reasoning
   about a running system and make operations more efficient.</li>
</ul>
<h3><a id="metrics-micrometer" class="anchor" href="#metrics-micrometer">Micrometer support</a></h3>
<p>Metric collection has to be enabled first:</p>
<p><a href="http://micrometer.io">Micrometer</a> the following way:</p>
<pre class="lang-java">
ConnectionFactory connectionFactory = new ConnectionFactory();
MicrometerMetricsCollector metrics = new MicrometerMetricsCollector();
connectionFactory.setMetricsCollector(metrics);
...
metrics.getPublishedMessages(); // get Micrometer's Counter object
</pre>

<p>Micrometer supports <a href="http://micrometer.io/docs">several reporting backends</a>:
Netflix Atlas, Prometheus, Datadog, Influx, JMX, etc.</p>
<p>You would typically pass in an instance of <span class="code ">MeterRegistry</span>
to the <span class="code ">MicrometerMetricsCollector</span>. Here is an example
with JMX:</p>
<pre class="lang-java">
JmxMeterRegistry registry = new JmxMeterRegistry();
MicrometerMetricsCollector metrics = new MicrometerMetricsCollector(registry);
ConnectionFactory connectionFactory = new ConnectionFactory();
connectionFactory.setMetricsCollector(metrics);
</pre>

<h3><a id="metrics-dropwizard-metrics" class="anchor" href="#metrics-dropwizard-metrics">Dropwizard Metrics support</a></h3>
<p>Enable metrics collection with <a href="http://metrics.dropwizard.io">Dropwizard</a> like so:</p>
<pre class="lang-java">
ConnectionFactory connectionFactory = new ConnectionFactory();
StandardMetricsCollector metrics = new StandardMetricsCollector();
connectionFactory.setMetricsCollector(metrics);
...
metrics.getPublishedMessages(); // get Metrics' Meter object
</pre>

<p>Dropwizard Metrics supports <a href="http://metrics.dropwizard.io/3.2.3/getting-started.html">several reporting backends</a>:
console, JMX, HTTP, Graphite, Ganglia, etc.</p>
<p>You would typically pass in an instance of <span class="code ">MetricsRegistry</span>
to the <span class="code ">StandardMetricsCollector</span>. Here is an example
with JMX:</p>
<pre class="lang-java">
MetricRegistry registry = new MetricRegistry();
StandardMetricsCollector metrics = new StandardMetricsCollector(registry);

ConnectionFactory connectionFactory = new ConnectionFactory();
connectionFactory.setMetricsCollector(metrics);

JmxReporter reporter = JmxReporter
  .forRegistry(registry)
  .inDomain("com.rabbitmq.client.jmx")
  .build();
reporter.start();
</pre>

<h2><a id="gae-pitfalls" class="anchor" href="#gae-pitfalls">RabbitMQ Java Client on Google App Engine</a></h2>
<p>Using RabbitMQ Java client on Google App Engine (GAE) requires using a custom
thread factory that instantiates thread using GAE's <span class="code ">ThreadManager</span> (see above).
In addition, it is necessary to set a low heartbeat interval (4-5 seconds) to avoid running
into the low <span class="code ">InputStream</span> read timeouts on GAE:</p>
<pre class="lang-java">
ConnectionFactory factory = new ConnectionFactory();
cf.setRequestedHeartbeat(5);
</pre>

<h2><a id="cache-pitfalls" class="anchor" href="#cache-pitfalls">Caveats and Limitations</a></h2>
<p>To make topology recovery possible, RabbitMQ Java client maintains a cache
of declared queues, exchanges, and bindings. The cache is per-connection. Certain
RabbitMQ features make it impossible for clients to observe some topology changes,
e.g. when a queue is deleted due to TTL. RabbitMQ Java client tries to invalidate
cache entries in the most common cases:</p>
<ul>
<li>When a queue is deleted.</li>
<li>When an exchange is deleted.</li>
<li>When a binding is deleted.</li>
<li>When a consumer is cancelled on an auto-deleted queue.</li>
<li>When a queue or exchange is unbound from an auto-deleted exchange.</li>
</ul>
<p>However, the client cannot track these topology changes beyond a single connection.
Applications that rely on auto-delete queues or exchanges, as well as queue TTL (note: not message TTL!),
and use <a href="#connection-recovery">automatic connection recovery</a>, should explicitly delete entities know to be unused
or deleted, to purge client-side topology cache. This is facilitated by <span class="code ">Channel#queueDelete</span>,
<span class="code ">Channel#exchangeDelete</span>, <span class="code ">Channel#queueUnbind</span>, and <span class="code ">Channel#exchangeUnbind</span>
being idempotent in RabbitMQ 3.3.x (deleting what's not there does not result in an exception).</p>
<h2><a id="rpc" class="anchor" href="#rpc">The RPC (Request/Reply) Pattern: an Example</a></h2>
<p>As a programming convenience, the Java client API offers a
class <span class="code ">RpcClient</span> which uses a temporary reply
queue to provide simple <a href="./tutorials/tutorial-six-java.html">RPC-style communication</a> facilities via AMQP 0-9-1.</p>
<p>The class doesn't impose any particular format on the RPC arguments and return values.
It simply provides a mechanism for sending a message to a given exchange with a particular
routing key, and waiting for a response on a reply queue.</p>
<pre class="lang-java">
import com.rabbitmq.client.RpcClient;

RpcClient rpc = new RpcClient(channel, exchangeName, routingKey);</pre>

<p>(The implementation details of how this class uses AMQP 0-9-1 are as follows: request messages are sent with the
<span class="code ">basic.correlation_id</span> field set to a value unique for this <span class="code ">RpcClient</span> instance,
and with <span class="code ">basic.reply_to</span> set to the name of the reply queue.)</p>
<p>Once you have created an instance of this class, you can use it to send RPC requests by using any of the following methods:</p>
<pre class="lang-java">
byte[] primitiveCall(byte[] message);
String stringCall(String message)
Map mapCall(Map message)
Map mapCall(Object[] keyValuePairs)
</pre>

<p>The <span class="code ">primitiveCall</span> method transfers raw byte arrays as the request and response
bodies. The method <span class="code ">stringCall</span> is a thin
convenience wrapper around <span class="code ">primitiveCall</span>,
treating the message bodies as <span class="code ">String</span> instances
in the default character encoding.</p>
<p>The <span class="code ">mapCall</span> variants are a little more sophisticated: they encode
a <span class="code ">java.util.Map</span> containing ordinary Java values
into an AMQP 0-9-1 binary table representation, and decode the
response in the same way. (Note that there are some restrictions on what value
types can be used here - see the javadoc for details.)</p>
<p>All the marshalling/unmarshalling convenience methods use <span class="code ">primitiveCall</span> as a
transport mechanism, and just provide a wrapping layer on top of it.</p>
<h2><a id="tls" class="anchor" href="#tls">TLS Support</a></h2>
<p>It's possible to encrypt the communication between the client and the broker
<a href="./ssl.html">using TLS</a>. Client and server authentication (a.k.a. peer verification) is also supported.
Here is the simplest, most naive way to use encryption with the Java client:</p>
<pre class="lang-java">
ConnectionFactory factory = new ConnectionFactory();
factory.setHost("localhost");
factory.setPort(5671);

// Only suitable for development.
// This code will not perform peer certificate chain verification and prone
// to man-in-the-middle attacks.
// See the main TLS guide to learn about peer verification and how to enable it.
factory.useSslProtocol();
</pre>

<p>Note the client doesn't enforce any server authentication (<a href="./ssl.html#peer-verification">peer certificate chain verification</a>) in the above
sample as the default, "trust all certificates" <span class="code ">TrustManager</span> is used.
This is convenient for local development but <strong>prone to man-in-the-middle attacks</strong>
and therefore <a href="./production-checklist.html">not recommended for production</a>.</p>
<p>To learn more about TLS support in RabbitMQ, see
the <a href="ssl.html">TLS guide</a>. If you only want to configure
the Java client (especially the peer verification and trust manager parts),
read <a href="ssl.html#java-client">the appropriate section</a> of the TLS guide.</p>
<h2><a id="oauth2-support" class="anchor" href="#oauth2-support">OAuth 2 Support</a></h2>
<p>The client can authenticate against an OAuth 2 server like <a href="https://github.com/cloudfoundry/uaa">UAA</a>.
The <a href="https://github.com/rabbitmq/rabbitmq-server/tree/master/deps/rabbitmq_auth_backend_oauth2">OAuth 2 plugin</a>
must be enabled on the server side and configured to use the same
OAuth 2 server as the client.</p>
<h3><a id="oauth2-getting-token" class="anchor" href="#oauth2-getting-token">Getting the OAuth 2 Token</a></h3>
<p>The Java client provides the <span class="code ">OAuth2ClientCredentialsGrantCredentialsProvider</span>
class to get a JWT token using the <a href="https://tools.ietf.org/html/rfc6749#section-4.4">OAuth 2 Client Credentials flow</a>.
The client will send the JWT token in the password field when opening a connection.
The broker will then verify the JWT token signature, validity, and permissions
before authorising the connection and granting access to the requested
virtual host.</p>
<p>Prefer the use of <span class="code ">OAuth2ClientCredentialsGrantCredentialsProviderBuilder</span>
to create an <span class="code ">OAuth2ClientCredentialsGrantCredentialsProvider</span> instance and
then set it up on the <span class="code ">ConnectionFactory</span>. The
following snippet shows how to configure and create an instance of the OAuth 2 credentials provider
for the <a href="https://github.com/rabbitmq/rabbitmq-server/tree/master/deps/rabbitmq_auth_backend_oauth2#examples">example setup of the OAuth 2 plugin</a>:</p>
<pre class="lang-java">
import com.rabbitmq.client.impl.OAuth2ClientCredentialsGrantCredentialsProvider.
        OAuth2ClientCredentialsGrantCredentialsProviderBuilder;
...
CredentialsProvider credentialsProvider =
  new OAuth2ClientCredentialsGrantCredentialsProviderBuilder()
    .tokenEndpointUri("http://localhost:8080/uaa/oauth/token/")
    .clientId("rabbit_client").clientSecret("rabbit_secret")
    .grantType("password")
    .parameter("username", "rabbit_super")
    .parameter("password", "rabbit_super")
    .build();

connectionFactory.setCredentialsProvider(credentialsProvider);
</pre>

<p>In production, make sure to use HTTPS for the token endpoint URI and configure
the <span class="code ">SSLContext</span> if necessary for the HTTPS requests (to verify and trust
the identity of the OAuth 2 server). The following snippet does
so by using the <span class="code ">tls().sslContext()</span> method from
<span class="code ">OAuth2ClientCredentialsGrantCredentialsProviderBuilder</span>:</p>
<pre class="lang-java">
SSLContext sslContext = ... // create and initialise SSLContext

CredentialsProvider credentialsProvider =
  new OAuth2ClientCredentialsGrantCredentialsProviderBuilder()
    .tokenEndpointUri("http://localhost:8080/uaa/oauth/token/")
    .clientId("rabbit_client").clientSecret("rabbit_secret")
    .grantType("password")
    .parameter("username", "rabbit_super")
    .parameter("password", "rabbit_super")
    .tls()                    // configure TLS
      .sslContext(sslContext) // set SSLContext
      .builder()              // back to main configuration
    .build();
</pre>

<p>Please consult the <a href="https://rabbitmq.github.io/rabbitmq-java-client/api/current/com/rabbitmq/client/impl/OAuth2ClientCredentialsGrantCredentialsProvider.html">Javadoc</a>
to see all the available options.</p>
<h3><a id="oauth2-refreshing-token" class="anchor" href="#oauth2-refreshing-token">Refreshing the Token</a></h3>
<p>Tokens expire and the broker will refuse operations on connections with
expired tokens. To avoid this, it is possible to call
<span class="code ">CredentialsProvider#refresh()</span> before expiration and send the new
token to the server. This is cumbersome
from an application point of view, so the Java client provides
help with the <span class="code ">DefaultCredentialsRefreshService</span>. This utility
tracks used tokens, refreshes them before they expire, and send
the new tokens for the connections it is responsible for.</p>
<p>The following snippet shows how to create a <span class="code ">DefaultCredentialsRefreshService</span>
instance and set it up on the <span class="code ">ConnectionFactory</span>:</p>
<pre class="lang-java">
import com.rabbitmq.client.impl.DefaultCredentialsRefreshService.
        DefaultCredentialsRefreshServiceBuilder;
...
CredentialsRefreshService refreshService =
  new DefaultCredentialsRefreshServiceBuilder().build();
cf.setCredentialsRefreshService(refreshService);
</pre>

<p>The <span class="code ">DefaultCredentialsRefreshService</span> schedules a refresh after 80%
of the token validity time, e.g. if the token expires in 60 minutes,
it will be refreshed after 48 minutes. This is the default behaviour,
please consult the <a href="https://rabbitmq.github.io/rabbitmq-java-client/api/current/com/rabbitmq/client/impl/DefaultCredentialsRefreshService.html">Javadoc</a>
for more information.</p><div id="help-and-feedback"><h2>Getting Help and Providing Feedback</h2><p>
                    If you have questions about the contents of this guide or
                    any other topic related to RabbitMQ, don't hesitate to ask them
                    on the <a href="https://groups.google.com/forum/#!forum/rabbitmq-users">RabbitMQ mailing list</a>.
                  </p></div><div id="contribute"><h2>Help Us Improve the Docs &lt;3</h2><p>
                    If you'd like to contribute an improvement to the site,
                    its source is <a href="https://github.com/rabbitmq/rabbitmq-website">available on GitHub</a>.
                    Simply fork the repository and submit a pull request. Thank you!
                  </p></div></div><div id="right-nav"><div id="in-this-section"><h4>In This Section</h4><ul>
     <li><a href="/admin-guide.html">Server Documentation</a></li>
     <li><a href="/clients.html" class="selected">Client Documentation</a><ul>
       <li><a href="/api-guide.html" class="selected">Java Client Guide</a><ul>
         <li><a href="/java-tools.html">Java Client Tools</a></li>
         
       </ul></li>
       <li><a href="/jms-client.html">JMS Client</a></li>
       <li><a href="/dotnet-api-guide.html">.NET Client Guide</a></li>
       <li><a href="/erlang-client-user-guide.html">Erlang Client Guide</a></li>
       <li><a href="/heartbeats.html">Heartbeats</a></li>
       <li><a href="/amqp-0-9-1-reference.html">AMQP 0-9-1 Reference</a></li>
       <li><a href="/uri-spec.html">AMQP 0-9-1 URI Spec</a></li>
       
       
       
     </ul></li>
     <li><a href="/plugins.html">Plugins</a></li>
     <li><a href="/news.html">News</a></li>
     <li><a href="/protocol.html">Protocol</a></li>
     <li><a href="/extensions.html">Our Extensions</a></li>
     <li><a href="/build.html">Building</a></li>
     
     <li><a href="/mpl.html">License</a></li>
   </ul></div><div id="related-links"><h4>Related Links</h4><ul><li><a href="/java-client.html">Java Client Downloads</a></li></ul></div></div></div><div class="clear"></div><div class="pageFooter"><div class="container"></div><div class="container"><div class="rabbit-logo"><a href="./"><img src="./img/logo-rabbitmq-white.svg" alt="RabbitMQ" /></a></div><ul class="footerNav"><li><a href="./#features">Features</a></li><li><a href="./#getstarted">Get Started</a></li><li><a href="./#support">Support</a></li><li><a href="./#community">Community</a></li><li><a href="./documentation.html">Docs</a></li></ul><p id="copyright">
          Copyright Â© 2007-2022 <a href="https://tanzu.vmware.com/">VMware</a>, Inc. or its affiliates. All rights reserved.
          <a href="https://www.vmware.com/help/legal.html">Terms of Use</a> â€¢
          <a href="https://www.vmware.com/help/privacy.html">Privacy</a> â€¢
          <a href="./trademark-guidelines.html">Trademark Guidelines</a> â€¢
          <a href="https://www.vmware.com/help/privacy/california-privacy-rights.html">Your California Privacy Rights</a> â€¢
          <a class="ot-sdk-show-settings">Cookie Settings</a><br /><a id="teconsent"></a></p></div></div></div><script type="text/javascript" src="/js/highlight.pack.js"></script><script type="text/javascript">
        // code highlighting
        window.addEventListener("load", function() {
          const selectors = "pre.lang-bash, \
                             pre.lang-csharp, \
                             pre.lang-elixir, \
                             pre.lang-erlang, \
                             pre.lang-go, \
                             pre.lang-groovy, \
                             pre.lang-haskell, \
                             pre.lang-html, \
                             pre.lang-ini, \
                             pre.lang-java, \
                             pre.lang-javascript, \
                             pre.lang-json, \
                             pre.lang-makefile, \
                             pre.lang-objectivec, \
                             pre.lang-php, \
                             pre.lang-plaintext, \
                             pre.lang-powershell, \
                             pre.lang-python, \
                             pre.lang-ruby, \
                             pre.lang-swift, \
                             pre.lang-yaml, \
                             pre.lang-xml";
          document.querySelectorAll(selectors).forEach(function(el) {
            hljs.highlightBlock(el);
          });
        });
      </script></body>
</html>
