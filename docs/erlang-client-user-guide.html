<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="73d8ba46-8c12-43f6-8c22-24aa21b8d93d" name="onetrust-data-domain" /><meta content="https://tags.tiqcdn.com/utag/vmware/microsites-privacy/prod/utag.js" name="microsites-utag" /><script src="https://d1fto35gcfffzn.cloudfront.net/assets/jquery-1.11.2.min.js"></script><script src="//www.vmware.com/files/templates/inc/utag_data.js"></script><script src="//tags.tiqcdn.com/utag/vmware/microsites-privacy/prod/utag.sync.js"></script><script>function OptanonWrapper() { { window.dataLayer.push({ event: 'OneTrustGroupsUpdated' }); } }</script><script src="/js/gtm.js"></script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="googlebot" content="NOODP" /><meta name="google-site-verification" content="nSYeDgyKM9mw5CWcZuD0xu7iSWXlJijAlg9rcxVOYf4" /><meta name="google-site-verification" content="6UEaC3SWhpGQvqRnSJIEm2swxXpM5Adn4dxZhFsNdw0" /><meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="viewport" name="viewport" /><link href="https://fonts.googleapis.com/css?family=Raleway:400,500,600,700" rel="stylesheet" /><link rel="stylesheet" href="/css/rabbit.css" type="text/css" /><link rel="stylesheet" href="/css/highlightjs_style.css" type="text/css" /><link rel="stylesheet" href="/css/rabbit-next.css" type="text/css" /><!--[if IE 6]>
      <link rel="stylesheet" href="/css/rabbit-ie6.css" type="text/css" />
      <![endif]--><link rel="icon" type="/image/vnd.microsoft.icon" href="/favicon.ico" /><link rel="stylesheet" href="/css/tutorial.css" type="text/css" /><script async="true" type="text/javascript" src="/js/site.js"></script><title> Erlang RabbitMQ Client library
 — RabbitMQ</title></head>
  <body id="erlang-client-user-guide"><div id="outerContainer"><div class="container"><div class="rabbit-logo"><a href="/"><img src="/img/logo-rabbitmq.svg" alt="RabbitMQ" /></a></div><a class="btn menubtn" onclick="showHide()">Menu <img src="/img/carrot-down-white.svg" /></a><div class="mobilemenuicon" onclick="showHide()"><img src="/img/mobile-menu-icon.svg" /></div><div id="nav"><ul id="mainNav"><li><a href="/#features">Features</a></li><li><a href="/#getstarted">Get Started</a></li><li><a href="/#support">Support</a></li><li><a href="/#community">Community</a></li><li><a href="/documentation.html">Docs</a></li></ul></div></div><div class="nav-separator"></div><div id="innerContainer" class="container"><div id="left-content"><h1> Erlang RabbitMQ Client library
</h1>


<h2><a id="overview" class="anchor" href="#overview">Overview</a></h2>
<p>This guide covers an Erlang client for RabbitMQ (<a href="/tutorials/amqp-concepts.html">AMQP 0-9-1</a>).</p>
<p>This user guide assumes that the reader is familiar with <a href="/tutorials/amqp-concepts.html">basic concepts of AMQP 0-9-1</a>.</p>
<p>Refer to guides on <a href="connections.html">connections</a>, <a href="channels.html">channels</a>, <a href="queues.html">queues</a>,
<a href="/publishers.html">publishers</a>, and <a href="/consumers.html">consumers</a> to learn about those
key RabbitMQ concepts in more details.</p>
<p>Some topics covered in this guide include</p>
<ul>
<li><a href="#dependency">How to add a dependency</a> on this client</li>
<li><a href="#basics">Usage basics</a></li>
<li>How to <a href="#connecting">connect</a> to and <a href="#disconnecting">disconnect</a> from a RabbitMQ node</li>
<li>How to <a href="#channels">open a channel</a> and <a href="#methods">perform protocol operations</a> on it</li>
<li>How to <a href="#topology">define a topology</a>: declare queues, exchanges and bindings</li>
<li><a href="#publishing">Publishing</a> and <a href="#consumers">consumption</a> of messages</li>
<li>Handling of <a href="#returns">returned messages</a></li>
</ul>
<p>and more.</p>
<h2><a id="dependency" class="anchor" href="#dependency">Dependency</a></h2>
<p>The client library is named <span class="code ">amqp_client</span> and <a href="https://hex.pm/packages/amqp_client">distributed via Hex.pm</a>
together with its key dependency, <a href="https://hex.pm/packages/rabbit_common"><span class="code ">rabbit-common</span></a>.</p>
<p>Below are dependency snippets to be used with popular build tools: Mix,
<a href="https://www.rebar3.org/docs/getting-started">Rebar 3</a> and <a href="https://erlang.mk">erlang.mk</a>.</p>
<h3>Mix</h3>
<pre class="lang-elixir">
{:rabbit_common, "~&gt; 3.8"}
</pre>

<h3>Rebar 3</h3>
<pre class="lang-erlang">
{rabbit_common, "3.9.16"}
</pre>

<h3>erlang.mk</h3>
<pre class="lang-makefile">
dep_rabbit_common = hex 3.9.16
</pre>

<h2><a id="basics" class="anchor" href="#basics">Basics</a></h2>
<p>The basic usage of the client follows these broad steps:</p>
<ol>
<li>Make sure the <span class="code ">amqp_client</span> Erlang application is started</li>
<li>Establish a <a href="connections.html">connection</a> to a RabbitMQ node</li>
<li>Open a new channel on the connection</li>
<li>Execute <a href="/amqp-0-9-1-quickref.html">AMQP 0-9-1 commands</a> with a channel such as
   declaring exchanges and queues, defining bindings between them, publishing messages,
   registering consumers (subscribing), and so on</li>
<li>Register optional event handlers such as <a href="#returns">returned message handler</a></li>
<li>When no longer required, close the channel and the connection</li>
</ol>
<h3><a id="amqp-client-app" class="anchor" href="#amqp-client-app">The amqp_client Application</a></h3>
<p>RabbitMQ Erlang client is an Erlang application named <span class="code ">amqp_client</span>.</p>
<p>As with any Erlang application, to begin using the client it's necessary to first
make sure it is started:</p>
<pre class="lang-erlang">
application:ensure_started(amqp_client).
</pre>

<h3><a id="key-modules" class="anchor" href="#key-modules">Key Modules and Concepts</a></h3>
<p>The main two modules in the client library are:</p>
<ul>
<li><span class="code ">amqp_connection</span>, which is used to open a connection to a
    RabbitMQ node and open channels on it</li>
<li><span class="code ">amqp_channel</span>, which exposes most AMQP 0-9-1 operations such as queue declaration
   or consumer registration</li>
</ul>
<p>Once a connection has been established and successfully <a href="/access-control.html">authenticated</a>,
and a channel has been opened, an application will typically use the
<span class="code ">amqp_channel:call/{2,3}</span> and <span class="code ">amqp_channel:cast/{2,3}</span> functions
together with AMQP 0-9-1 protocol method records to perform most operations.</p>
<p>Several additional modules make it possible for applications to react to certain events.
They will be covered later in this guide.</p>
<p>The library is made up of two layers:</p>
<ul>
<li>A high level logical layer that follows the AMQP 0-9-1 protocol and operation execution model</li>
<li>A low-level protocol implementation layer that is responsible for communicating with RabbitMQ nodes</li>
</ul>
<h3><a id="driver-types" class="anchor" href="#driver-types">Network Connection Types</a></h3>
<p>AMQP 0-9-1 clients connect to RabbitMQ using TCP. One AMQP 0-9-1 connection uses one TCP connection
under the hood. However, the Erlang client is unique in that it provides
an alternative way of communicating with RabbitMQ nodes.</p>
<h4>Network Client</h4>
<p>Much like other clients, this library provides a TCP-based client that uses a TCP connection
to transfer serialised protocol frames to the server. This client is called
the network client and most applications should use.</p>
<p>To use the network client, <a href="#connecting">start a connection</a> using <span class="code ">amqp_connection:start/1</span> with the
parameter set to an <span class="code ">#amqp_params_network</span> record.</p>
<h4>Direct (Erlang Distribution) Client</h4>
<p>Alternatively, Erlang distribution connections can be used instead of separate TCP
connections. This communication method assumes that the application that uses
the client runs on the same Erlang cluster as RabbitMQ nodes.</p>
<p>The use of direct client should be limited to applications that are deployed
side by side with RabbitMQ. <a href="shovel.html">Shovel</a> and <a href="/federation.html">Federation</a>
plugins are two examples of such applications.</p>
<p>In most other cases, developers should prefer the more traditional network client covered above.
It will be easier to reason about for operators and developers not familiar with Erlang.</p>
<p>To use the direct driver, <a href="#connecting">start a connection</a> using <span class="code ">amqp_connection:start/1</span> with the
parameter set to an <span class="code ">#amqp_params_direct</span> record.</p>
<h3><a id="headers" class="anchor" href="#headers">Including Header Files</a></h3>
<p>The Erlang client uses a number of record definitions which you
will encounter in this guide. These records fall into two broad
categories:</p>
<ul>
<li>Generated AMQP 0-9-1 method definitions</li>
<li>Definitions of data structures that are commonly used throughout the client</li>
</ul>
<p>To gain access to these records, you need to include the
amqp_client.hrl in every module that uses the Erlang client:</p>
<pre class="lang-erlang">
-include("amqp_client.hrl").
</pre>

<h2><a id="connecting" class="anchor" href="#connecting">Connecting to RabbitMQ</a></h2>
<p>The <span class="code ">amqp_connection</span> module is used to start a <a href="connections.html">connection</a> to a RabbitMQ node.
In this example we will use a network connection, which is the recommended
option for most use cases:</p>
<pre class="lang-erlang">
{ok, Connection} = amqp_connection:start(#amqp_params_network{})
</pre>

<p>This function returns an <span class="code ">{ok, Connection}</span> pair, where <span class="code ">Connection</span> is the
pid of a process that maintains a permanent connection.
This pid will be used to open channels on the connection and <a href="#disconnecting">close the connection</a>.</p>
<p>In case of an error, the above call returns an <span class="code ">{error, Error}</span> pair.</p>
<p>The <span class="code ">#amqp_params_network</span> record sets the following default values:</p>
<table>
  <thead>
    <tr>
      <td>Parameter</td>
      <td>Default Value</td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>username</td>
      <td>guest</td>
    </tr>
    <tr>
      <td>password</td>
      <td>guest</td>
    </tr>
    <tr>
      <td>virtual_host</td>
      <td>/</td>
    </tr>
    <tr>
      <td>host</td>
      <td>localhost</td>
    </tr>
    <tr>
      <td>port</td>
      <td>5672</td>
    </tr>
    <tr>
      <td>channel_max</td>
      <td>2047</td>
    </tr>
    <tr>
      <td>frame_max</td>
      <td>0</td>
    </tr>
    <tr>
      <td><a href="/heartbeats.html">heartbeat</a></td>
      <td>0</td>
    </tr>
    <tr>
      <td><a href="/ssl.html">ssl_options</a></td>
      <td>none</td>
    </tr>
    <tr>
      <td>auth_mechanisms</td>
      <td>[fun amqp_auth_mechanisms:plain/3, fun amqp_auth_mechanisms:amqplain/3]</td>
    </tr>
    <tr>
      <td>client_properties</td>
      <td>[]</td>
    </tr>
  </tbody>
</table>

<p>These values are only the defaults that will work with an out of
the box RabbitMQ node running on the same host. If the target node or the
environment has been configured differently, these values can be
overridden to match the actual deployment scenario.</p>
<p>TLS options can also be specified globally using the
<span class="code ">ssl_options</span> environment key for the <span class="code ">amqp_client</span> application.
They will be merged with the TLS parameters from the URI (the latter will take precedence).</p>
<h3>Direct (Erlang Distribution) Client</h3>
<p>Applications that are deployed inside the same Erlang cluster as the
RabbitMQ, such as RabbitMQ plugins, can start a direct connection
that bypasses network serialisation and relies on Erlang distribution
for data transfers.</p>
<p>To start a direct connection, use <span class="code ">amqp_connection:start/1</span> with the parameter
set to an <span class="code ">#amqp_params_direct</span> record:</p>
<pre class="lang-erlang">
{ok, Connection} = amqp_connection:start(#amqp_params_direct{})
</pre>

<p>Credentials are optional for direct connections, since Erlang
distribution relies on <a href="">a shared secret</a>, the Erlang cookie, for authentication.</p>
<p>If a username and password are provided then they will be used for authentication and
made available to authentication backends.</p>
<p>If only a username is supplied, then the user is considered trusted and logged in
unconditionally.</p>
<p>If neither username nor password are provided, then the connection will be considered
to be from a fully trusted user which can connect to any virtual host and has
full <a href="/access-control.html">permissions</a>.</p>
<p>The <span class="code ">#amqp_params_direct</span> record sets the following default values:</p>
<table>
  <thead>
    <tr>
      <td>Parameter</td>
      <td>Default Value</td>
    </tr>
  </thead>

  <tr>
    <td>username</td>
    <td>none</td>
  </tr>
  <tr>
    <td>password</td>
    <td>none</td>
  </tr>
  <tr>
    <td>virtual_host</td>
    <td>/</td>
  </tr>
  <tr>
    <td>node</td>
    <td>node()</td>
  </tr>
  <tr>
    <td>client_properties</td>
    <td>[]</td>
  </tr>
</table>

<h3><a id="amqp-uris" class="anchor" href="#amqp-uris">Connecting to RabbitMQ Using an AMQP URI</a></h3>
<p>Instead of working with records such <span class="code ">#amqp_params_network</span> directly,
<a href="/uri-spec.html">AMQP URIs</a> may be used.</p>
<p>The <span class="code ">amqp_uri:parse/1</span> function is provided for this purpose.
It parses an URI and returns the equivalent <span class="code ">#amqp_params_network</span> or <span class="code ">#amqp_params_direct</span> record.</p>
<p>Diverging from the spec, if the hostname is omitted, the
connection is assumed to be direct and an <span class="code ">#amqp_params_direct{}</span>
record is returned.  In addition to the standard host, port, user,
password and vhost parameters, extra parameters may be specified
via the query string (e.g. "?heartbeat=5" to configure a <a href="/heartbeats.html">heartbeat timeout</a>).</p>
<h2><a id="channels" class="anchor" href="#channels">Creating Channels</a></h2>
<p>Once a connection has been established, use the <span class="code ">amqp_connection</span> module
to open one or more <a href="channels.html">channels</a> that will be used
to define the topology, publish and consume messages:</p>
<pre class="lang-erlang">
{ok, Channel} = amqp_connection:open_channel(Connection)
</pre>

<p>This function takes the pid of the connection process and returns
a <span class="code ">{ok, Channel}</span> pair, where <span class="code ">Channel</span> is a pid that represents
a channel and will be used to execute protocol commands.</p>
<h2><a id="methods" class="anchor" href="#methods">Using AMQP 0-9-1 Methods (Protocol Operations)</a></h2>
<p>The client library's primary way of interacting with RabbitMQ nodes is by
sending and handling <a href="/specification.html">AMQP 0-9-1 methods</a>
(also referred to as "commands" in this guide) that are represented by records.</p>
<p>The client tries to use sensible default values for each record.
For example, when using the <span class="code ">#'exchange.declare'{}</span> method to declare a transient exchange,
it is sufficient to only specify a name:</p>
<pre class="lang-erlang">
#'exchange.declare'{exchange = &lt;&lt;"my_exchange"&gt;&gt;}
</pre>

<p>The above example is equivalent to this:</p>
<pre class="lang-erlang">
#'exchange.declare'{exchange    = &lt;&lt;"my_exchange"&gt;&gt;,
                    type        = &lt;&lt;"direct"&gt;&gt;,
                    passive     = false,
                    durable     = false,
                    auto_delete = false,
                    internal    = false,
                    nowait      = false,
                    arguments   = []}
</pre>

<h2><a id="topology" class="anchor" href="#topology">Defining a Topology: Exchanges, Queues, Bindings</a></h2>
<p>Once a channel has been established, the <span class="code ">amqp_channel</span> module can
be used to manage the fundamental objects within AMQP, namely
exchanges and queues. The following function creates an exchange
called my_exchange, which by default, is the direct exchange:</p>
<pre class="lang-erlang">
Declare = #'exchange.declare'{exchange = &lt;&lt;"my_exchange"&gt;&gt;},
#'exchange.declare_ok'{} = amqp_channel:call(Channel, Declare)
</pre>

<p>Similarly, a <a href="/queues.html#durability">transient</a> queue called <span class="code ">my_queue</span> is created by this code:</p>
<pre class="lang-erlang">
Declare = #'queue.declare'{queue = &lt;&lt;"my_queue"&gt;&gt;},
#'queue.declare_ok'{} = amqp_channel:call(Channel, Declare)
</pre>

<p>To declare a durable queue:</p>
<pre class="lang-erlang">
Declare = #'queue.declare'{
  queue = &lt;&lt;"my_queue"&gt;&gt;,
  durable = true
},
#'queue.declare_ok'{} = amqp_channel:call(Channel, Declare)
</pre>

<p>In some cases an application wants to use a transient queue and is not interested in the actual name
of the queue. In this case, it is possible to let the broker generate a random name for a
queue. To do this, use a <span class="code ">#'queue.declare'{}</span> method and leave the
queue attribute undefined. Specifying a blank string for queue name
would have the same effect.</p>
<pre class="lang-erlang">
#'queue.declare_ok'{queue = Queue} = amqp_channel:call(Channel, #'queue.declare'{})
</pre>

<p>The server will generate a queue name unique in this cluster and return this name as
part of the acknowledgement.</p>
<h3>Bindings</h3>
<p>To create a routing rule from an exchange to a queue, the
<span class="code ">#'queue.bind'{}</span> command is used:</p>
<pre class="lang-erlang">
Binding = #'queue.bind'{queue       = Queue,
                        exchange    = Exchange,
                        routing_key = RoutingKey},
#'queue.bind_ok'{} = amqp_channel:call(Channel, Binding)
</pre>

<p>When this routing rule is no longer required, this route can be
deleted using the <span class="code ">#'queue.unbind'{}</span> command:</p>
<pre class="lang-erlang">
Binding = #'queue.unbind'{queue       = Queue,
                          exchange    = Exchange,
                          routing_key = RoutingKey},
#'queue.unbind_ok'{} = amqp_channel:call(Channel, Binding)
</pre>

<h3>Deleting Entities</h3>
<p>An exchange can be deleted by the <span class="code ">#'exchange.delete'{}</span> command:</p>
<pre class="lang-erlang">
Delete = #'exchange.delete'{exchange = &lt;&lt;"my_exchange"&gt;&gt;},
#'exchange.delete_ok'{} = amqp_channel:call(Channel, Delete)
</pre>

<p>Similarly, a queue is deleted using the <span class="code ">#'queue.delete'{}</span> command:</p>
<pre class="lang-erlang">
Delete = #'queue.delete'{queue = &lt;&lt;"my_queue"&gt;&gt;},
#'queue.delete_ok'{} = amqp_channel:call(Channel, Delete)
</pre>

<h3><a id="call-or-cast" class="anchor" href="#call-or-cast">Synchronous and Asynchronous Protocol Methods, Calls and Casts</a></h3>
<p>Note that the above examples use <span class="code ">amqp_channel:call/2</span>.
This is because they use synchronous AMQP 0-9-1 methods that produce a response
(unlike a group of methods called asynchronous methods).</p>
<p>It is generally advisable to use <span class="code ">amqp_channel:call/{2,3}</span> for synchronous methods,
rather than <span class="code ">amqp_channel:cast/{2,3}</span>, even though both functions work with both
sync and async methods.</p>
<p>One difference between the two functions is that <span class="code ">amqp_channel:call/{2,3}</span> blocks the calling
process until the reply comes back from the server (for sync methods) or the method
has been sent on the wire (for async methods), whereas <span class="code ">amqp_channel:cast/{2,3}</span>
returns an 'ok' immediately.</p>
<p>Thus, only by using <span class="code ">amqp_channel:call/{2,3}</span> can we verify that the server
has acknowledged our command.</p>
<h2><a id="publishing" class="anchor" href="#publishing">Publishing Messages</a></h2>
<p>To publish a message to an exchange with a particular routing key,
the <span class="code ">#'basic.publish'{}</span> method.
Messages are represented using the <span class="code ">#amqp_msg{}</span> record:</p>
<pre class="lang-erlang">
Payload = &lt;&lt;"foobar"&gt;&gt;,
Publish = #'basic.publish'{exchange = X, routing_key = Key},
amqp_channel:cast(Channel, Publish, #amqp_msg{payload = Payload})
</pre>

<p>By default, the properties field of the <span class="code ">#amqp_msg{}</span> record contains
a minimal set of <a href="/publishers.html#message-properties">message properties</a> as a <span class="code ">#'P_basic'{}</span> properties record.</p>
<p>If an application needs to override any of the defaults, for example,
to send persistent messages, the <span class="code ">#amqp_msg{}</span> needs to
be constructed accordingly:</p>
<pre class="lang-erlang">
Payload = &lt;&lt;"foobar"&gt;&gt;,
Publish = #'basic.publish'{exchange = X, routing_key = Key},
Props = #'P_basic'{delivery_mode = 2}, %% persistent message
Msg = #amqp_msg{props = Props, payload = Payload},
amqp_channel:cast(Channel, Publish, Msg)
</pre>

<p>Full list of <a href="/publishers.html#message-properties">message properties</a> can be found
in the Publishers guide.</p>
<p>The AMQP 0-9-1 <span class="code ">#'basic.publish'</span> method is <a href="#call-or-cast">asynchronous</a>:
the server will not send a response to it. However, clients can opt in
to have <a href="/publishers.html#unroutable">unroutable messages</a> returned to them.
This is described in the section on <a href="#returns">return message handlers</a>.</p>
<p>The above example does not use <a href="/confirms.html">Publisher Confirms</a>.
To await for all outstanding publishes to be confirmed after publishing
a batch of messages, use <span class="code ">amqp_channel:wait_for_confirms/2</span> function.
It will return a <span class="code ">true</span> if all outstanding publishes were successfully confirmed
or a <span class="code ">timeout</span> if timeout has occurred.</p>
<p>Note that waiting after every published message is extremely inefficient
and unnecessary. A more optimal way would be to publish a batch of messages
and await their confirmation. If some publishes were not confirmed in time,
the entire last batch can be republished.</p>
<h2><a id="consumers" class="anchor" href="#consumers">Consumers: Subscribing To Queues Using the "Push API"</a></h2>
<p>Applications can subscribe to be delivered messages routed to a queue. This "push API" is the
recommended way of consuming messages (the other being <a href="#polling">polling</a>, which should be
avoided when possible).</p>
<p>To add a consumer to a queue (subscribe to a queue), the
<span class="code ">#'basic.consume'{}</span> method is used in one of two ways:</p>
<pre class="lang-erlang">
#'basic.consume_ok'{consumer_tag = Tag} =
  amqp_channel:subscribe(Channel, #'basic.consume'{queue = Q}, Consumer)
</pre>

<p>or</p>
<pre class="lang-erlang">
%% A consumer process is not provided so the calling
process (`self()`) will be the consumer
#'basic.consume_ok'{consumer_tag = Tag} =
  amqp_channel:call(Channel, #'basic.consume'{queue = Q})
</pre>

<p>The consumer argument is the pid of a process to which the client library
will deliver messages.
This can be an arbitrary Erlang process, including the process that initiated
the connection.
The <span class="code ">#'basic.consume_ok'{}</span> return contains a consumer tag. The tag is a consumer
(subscription) identifier that is used to cancel the consumer.</p>
<p>This is used at a later point in time to cancel the consumer.
This notification is sent both to the process that created the subscription
(as the return value to <span class="code ">amqp_channel:subscribe/3</span>) and
as a message to the consumer process.</p>
<p>When a consumer process is subscribed to a queue, it will receive
messages in its mailbox. An example receive loop looks like this:</p>
<pre class="lang-erlang">
loop(Channel) -&gt;
    receive
        %% This is the first message received
        #'basic.consume_ok'{} -&gt;
            loop(Channel);

        %% This is received when the subscription is cancelled
        #'basic.cancel_ok'{} -&gt;
            ok;

        %% A delivery
        {#'basic.deliver'{delivery_tag = Tag}, Content} -&gt;
            %% Do something with the message payload
            %% (some work here)

            %% Ack the message
            amqp_channel:cast(Channel, #'basic.ack'{delivery_tag = Tag}),

            %% Loop
            loop(Channel)
    end.
</pre>

<p>In the above example, the process consumes the consumer registration (subscription)
notification and then proceeds to wait for delivery messages to
arrive in its process mailbox.</p>
<p>When messages are received, the loop does something useful with the message and
sends an <a href="/confirms.html">acknowledgement</a> back to the server.
If the consumer is cancelled, a cancellation notification will be sent to the
consumer process. In this scenario, the receive loop just
exits. If the application does not wish to explicitly acknowledge
message receipts, it can use automatic acknowledgement mode.
For that, set the <span class="code ">no_ack</span> property of <span class="code ">#'basic.consume'</span> record
to <span class="code ">true</span>. When in automatic acknowledgement mode, consumers do not
acknowledge deliveries: RabbitMQ will consider them delivered
immediately after sending them down the connection.</p>
<h3>Cancelling a Consumer</h3>
<p>To cancel a consumer, use the consumer tag returned
with the <span class="code ">#'basic.consume_ok'{}</span> response:</p>
<pre class="lang-erlang">
amqp_channel:call(Channel, #'basic.cancel'{consumer_tag = Tag})
</pre>

<p>A cancelled consumer may still receive "in flight" deliveries, e.g. those
currently in TCP buffers at the time of consumer cancellation.
However, eventually — and usually shortly after — consumer cancellation there
will be no further deliveries to its handling process.</p>
<h2><a id="consumers-imlementation" class="anchor" href="#consumers-imlementation">Implementation of Consumers</a></h2>
<p>The channel uses a module implementing the <span class="code ">amqp_gen_consumer</span>
behaviour to determine how it should handle consumer events.
Effectively, this module handles client-side
consumer registration and ensures routing of deliveries to the appropriate consumers.</p>
<p>For instance, the default consumer module, <span class="code ">amqp_selective_consumer</span>,
keeps track of which processes are subscribed to which queues and routes deliveries appropriately;
in addition, if the channel gives it a delivery for an unknown
consumer, it will pass it to a default consumer, should one be registered.</p>
<p>By contrast, <span class="code ">amqp_direct_consumer</span> simply forwards all the
messages it receives from the channel to its only registered consumer.</p>
<p>The consumer module for a channel is chosen when the channel is
opened by setting the second parameter to <span class="code ">amqp_connection:open_channel/2</span>.</p>
<p>The consumer module implements the <span class="code ">amqp_gen_consumer</span> behaviour and thus implements functions to handle
receiving <span class="code ">basic.consume</span>, <span class="code ">basic.consume_ok</span>, <span class="code ">basic.cancel</span>, <span class="code ">basic.cancel_ok</span> methods as well
delivery of published messages.</p>
<h2><a id="disconnecting" class="anchor" href="#disconnecting">Closing Channels And The Connection</a></h2>
<p>When a channel is no longer required, a client should close it.
This is achieved using <span class="code ">amqp_channel:close/1</span>:</p>
<pre class="lang-erlang">
amqp_channel:close(Channel)
</pre>

<p>To close the connection, <span class="code ">amqp_connection:close/1</span> is used:</p>
<pre class="lang-erlang">
amqp_connection:close(Connection)
</pre>

<p>Closing a connection will automatically implicitly close all channels
on that connection.</p>
<p>Both the #'channel.close'{} and #'connection.close'{} commands
take the arguments <span class="code ">reply_code</span> (an integer) and <span class="code ">reply_text</span> (a binary),
which can be set by the client depending on the reason why
the channel or connection is being closed.</p>
<p>In most cases the <span class="code ">reply_code</span> should set to 200 to indicate a normal shutdown.
The <span class="code ">reply_text</span> attribute is just an arbitrary string, that the server
may or may not log. If a client wants to set to a different reply
code and/or text, it can use the overloaded functions
<span class="code ">amqp_channel:close/3</span> and <span class="code ">amqp_connection:close/3</span> respectively.</p>
<h2><a id="flow" class="anchor" href="#flow">Delivery Flow Control</a></h2>
<p>By default, there is no flow control within a channel other than
normal TCP back-pressure. A consumer can set the size of the
prefetch buffer that the broker will maintain for outstanding
unacknowledged messages on a single channel. This is achieved
using the #'basic.qos'{} command:</p>
<pre class="lang-erlang">
amqp_channel:call(Channel, #'basic.qos'{prefetch_count = Prefetch})
</pre>

<p>Applications are recommended to use a prefetch. Learn more in the
<a href="/confirms.html">Publisher Confirms and Consumer Acknowledgements guide</a>.</p>
<h2><a id="blocked" class="anchor" href="#blocked">Blocked Connections</a></h2>
<p>When a node detects that it is below a certain available resource threshold,
it may <a href="alarms.html">choose to stop reading from publishers' network sockets</a>.</p>
<p>RabbitMQ supports <a href="connection-blocked.html">a mechanism to allow clients to be told this has taken place</a>.</p>
<p>Use <span class="code ">amqp_connection:register_blocked_handler/2</span> giving the
pid of a process to which <span class="code ">#'connection.blocked'{}</span> and
<span class="code ">#'connection.unblocked'{}</span> should may be sent.</p>
<h2><a id="returns" class="anchor" href="#returns">Handling Returned Messages</a></h2>
<p>The broker will return undeliverable messages back to the
originating client. These are messages published either with the
immediate or mandatory flags set. In order for the application to
get notified of a return, it must register a callback process
that can process <span class="code ">#'basic.return'{}</span> frames.</p>
<p>Here is an example of unrouteable message handling:</p>
<pre class="lang-erlang">
amqp_channel:register_return_handler(Channel, self()),
amqp_channel:call(Channel, #'exchange.declare'{exchange = X}),
Publish = #'basic.publish'{exchange = X, routing_key = SomeKey,
                          mandatory = true},
amqp_channel:call(Channel, Publish, #amqp_msg{payload = Payload}),
receive
    {BasicReturn, Content} -&gt;
        #'basic.return'{reply_text = &lt;&lt;"unroutable"&gt;&gt;, exchange = X} = BasicReturn
        %% Do something with the returned message
end
</pre>

<h2><a id="polling" class="anchor" href="#polling">Receiving Messages Using the "Fetch API"</a></h2>
<p>It is also possible to retrieve individual messages on demand ("pull API" a.k.a. polling).
This approach to consumption is highly inefficient as it is effectively polling
and applications repeatedly have to ask for results even if the vast majority of the requests
yield no results. Therefore using this approach <strong>is highly discouraged</strong>.</p>
<p>This is achieved using the <span class="code ">#'basic.get'{}</span> command:</p>
<pre class="lang-erlang">
Get = #'basic.get'{queue = Q, no_ack = true},
{#'basic.get_ok'{}, Content} = amqp_channel:call(Channel, Get),
#amqp_msg{payload = Payload} = Content
</pre>

<p>The payload that is returned is an Erlang binary, and it is up to
the application to decode it, as the structure of this content is
opaque to both client library and the server.</p>
<p>If the queue were empty when the <span class="code ">#'basic.get'{}</span> command was
invoked, then the channel will return an <span class="code ">#'basic.get_empty'</span>
result, as illustrated here:</p>
<pre class="lang-erlang">
#'basic.get_empty'{} = amqp_channel:call(Channel, Get)
</pre>

<p>Note that the previous example sets the no_ack flag on the
<span class="code ">#'basic.get'{}</span> command. This tells the broker that the receiver
will not send an acknowledgement of the message. In doing so, the
broker can absolve itself of the responsibility for delivery -
once it believes it has delivered a message, then it is free to
assume that consuming application has taken responsibility for
it. In general, a lot of applications will not want these
semantics, rather, they will want to explicitly acknowledge the
receipt of a message. This is done with the #'basic.ack'{}
command, where the no_ack field is turned off by default:</p>
<pre class="lang-erlang">
Get = #'basic.get'{queue = Q},
{#'basic.get_ok'{delivery_tag = Tag}, Content}
    = amqp_channel:call(Channel, Get),
%% Do something with the message payload.......and then ack it
amqp_channel:cast(Channel, #'basic.ack'{delivery_tag = Tag})
</pre>

<p>Notice that the <span class="code ">#'basic.ack'{}</span> method was sent using
<span class="code ">amqp_channel:cast/2</span> instead of <span class="code ">amqp_channel:call/2</span>. This is
because acknowledgements are entirely asynchronous and the server
will not produce a response for them.</p>
<h2><a id="example" class="anchor" href="#example">A Basic Example</a></h2>
<p>Below is a complete example of basic usage of the library. For the sake of simplicity
it does not use <a href="/confirms.html">publisher confirms</a> and uses a <a href="#polling">polling consumer</a> which performs
<a href="/confirms.html">manual acknowledgements</a>.</p>
<pre class="lang-erlang">
-module(amqp_example).

-include("amqp_client.hrl").

-compile([export_all]).

test() -&gt;
    %% Start a network connection
    {ok, Connection} = amqp_connection:start(#amqp_params_network{}),
    %% Open a channel on the connection
    {ok, Channel} = amqp_connection:open_channel(Connection),

    %% Declare a queue
    #'queue.declare_ok'{queue = Q}
        = amqp_channel:call(Channel, #'queue.declare'{}),

    %% Publish a message
    Payload = &lt;&lt;"foobar"&gt;&gt;,
    Publish = #'basic.publish'{exchange = &lt;&lt;&gt;&gt;, routing_key = Q},
    amqp_channel:cast(Channel, Publish, #amqp_msg{payload = Payload}),

    %% Poll for a message
    Get = #'basic.get'{queue = Q},
    {#'basic.get_ok'{delivery_tag = Tag}, Content}
         = amqp_channel:call(Channel, Get),

    %% Do something with the message payload
    %% (some work here)

    %% Ack the message
    amqp_channel:cast(Channel, #'basic.ack'{delivery_tag = Tag}),

    %% Close the channel
    amqp_channel:close(Channel),
    %% Close the connection
    amqp_connection:close(Connection),

    ok.
</pre>

<p>In this example, a queue is created with a server generated name
and a message is published directly to the queue. This makes use
of the fact that every queue is bound to the default exchange via
its own queue name. The message is then dequeued and acknowledged.</p>
<h2><a id="deployment" class="anchor" href="#deployment">Compiling Code with Client as a Dependency</a></h2>
<p>The client build process produces two deployment archives:</p>
<ul>
<li>amqp_client.ez, which contains all of the client library modules</li>
<li>rabbit_common.ez, which contains the common modules from the server that are required at run-time</li>
</ul>
<p>Both dependencies can be provisioned using build tools such as <a href="https://www.rebar3.org/docs/getting-started">Rebar 3</a>
or <a href="https://erlang.mk">erlang.mk</a>.</p>
<p>For the sake of an example. let's assume that the dependency management tool
used compiles dependencies under the <span class="code ">./deps</span> directory.</p>
<p>Then to compile the example code manually, <span class="code ">erlc</span> can be used with <span class="code ">ERL_LIBS</span> pointing to the
<span class="code ">./deps</span> directory:</p>
<pre class="lang-bash">
ERL_LIBS=deps erlc -o ebin amqp_example.erl
</pre>

<p>And then to run your application you could set the Erlang run-time like this:</p>
<pre class="lang-bash">
ERL_LIBS=deps erl -pa ebin
# =&gt; Erlang/OTP 23 [erts-11.0] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:16]
# =&gt;
# =&gt; Eshell V11.0  (abort with ^G)
# =&gt; 1&gt; amqp_example:test().
# =&gt; ok
# =&gt; 2&gt;
</pre><div id="help-and-feedback"><h2>Getting Help and Providing Feedback</h2><p>
                    If you have questions about the contents of this guide or
                    any other topic related to RabbitMQ, don't hesitate to ask them
                    on the <a href="https://groups.google.com/forum/#!forum/rabbitmq-users">RabbitMQ mailing list</a>.
                  </p></div><div id="contribute"><h2>Help Us Improve the Docs &lt;3</h2><p>
                    If you'd like to contribute an improvement to the site,
                    its source is <a href="https://github.com/rabbitmq/rabbitmq-website">available on GitHub</a>.
                    Simply fork the repository and submit a pull request. Thank you!
                  </p></div></div><div id="right-nav"><div id="in-this-section"><h4>In This Section</h4><ul>
     <li><a href="/admin-guide.html">Server Documentation</a></li>
     <li><a href="/clients.html" class="selected">Client Documentation</a><ul>
       <li><a href="/api-guide.html">Java Client Guide</a></li>
       <li><a href="/jms-client.html">JMS Client</a></li>
       <li><a href="/dotnet-api-guide.html">.NET Client Guide</a></li>
       <li><a href="/erlang-client-user-guide.html" class="selected">Erlang Client Guide</a></li>
       <li><a href="/heartbeats.html">Heartbeats</a></li>
       <li><a href="/amqp-0-9-1-reference.html">AMQP 0-9-1 Reference</a></li>
       <li><a href="/uri-spec.html">AMQP 0-9-1 URI Spec</a></li>
       
       
       
     </ul></li>
     <li><a href="/plugins.html">Plugins</a></li>
     <li><a href="/news.html">News</a></li>
     <li><a href="/protocol.html">Protocol</a></li>
     <li><a href="/extensions.html">Our Extensions</a></li>
     <li><a href="/build.html">Building</a></li>
     
     <li><a href="/mpl.html">License</a></li>
   </ul></div><div id="related-links"><h4>Related Links</h4><ul><li><a href="https://hexdocs.pm/amqp_client/3.9.16/">Erlang edoc</a></li></ul></div></div></div><div class="clear"></div><div class="pageFooter"><div class="container"></div><div class="container"><div class="rabbit-logo"><a href="/"><img src="/img/logo-rabbitmq-white.svg" alt="RabbitMQ" /></a></div><ul class="footerNav"><li><a href="/#features">Features</a></li><li><a href="/#getstarted">Get Started</a></li><li><a href="/#support">Support</a></li><li><a href="/#community">Community</a></li><li><a href="/documentation.html">Docs</a></li></ul><p id="copyright">
          Copyright © 2007-2022 <a href="https://tanzu.vmware.com/">VMware</a>, Inc. or its affiliates. All rights reserved.
          <a href="https://www.vmware.com/help/legal.html">Terms of Use</a> •
          <a href="https://www.vmware.com/help/privacy.html">Privacy</a> •
          <a href="/trademark-guidelines.html">Trademark Guidelines</a> •
          <a href="https://www.vmware.com/help/privacy/california-privacy-rights.html">Your California Privacy Rights</a> •
          <a class="ot-sdk-show-settings">Cookie Settings</a><br /><a id="teconsent"></a></p></div></div></div><script type="text/javascript" src="/js/highlight.pack.js"></script><script type="text/javascript">
        // code highlighting
        window.addEventListener("load", function() {
          const selectors = "pre.lang-bash, \
                             pre.lang-csharp, \
                             pre.lang-elixir, \
                             pre.lang-erlang, \
                             pre.lang-go, \
                             pre.lang-groovy, \
                             pre.lang-haskell, \
                             pre.lang-html, \
                             pre.lang-ini, \
                             pre.lang-java, \
                             pre.lang-javascript, \
                             pre.lang-json, \
                             pre.lang-makefile, \
                             pre.lang-objectivec, \
                             pre.lang-php, \
                             pre.lang-plaintext, \
                             pre.lang-powershell, \
                             pre.lang-python, \
                             pre.lang-ruby, \
                             pre.lang-swift, \
                             pre.lang-yaml, \
                             pre.lang-xml";
          document.querySelectorAll(selectors).forEach(function(el) {
            hljs.highlightBlock(el);
          });
        });
      </script></body>
</html>
