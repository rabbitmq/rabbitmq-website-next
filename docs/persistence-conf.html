<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="73d8ba46-8c12-43f6-8c22-24aa21b8d93d" name="onetrust-data-domain" /><meta content="https://tags.tiqcdn.com/utag/vmware/microsites-privacy/prod/utag.js" name="microsites-utag" /><script src="https://d1fto35gcfffzn.cloudfront.net/assets/jquery-1.11.2.min.js"></script><script src="//www.vmware.com/files/templates/inc/utag_data.js"></script><script src="//tags.tiqcdn.com/utag/vmware/microsites-privacy/prod/utag.sync.js"></script><script>function OptanonWrapper() { { window.dataLayer.push({ event: 'OneTrustGroupsUpdated' }); } }</script><script src="/js/gtm.js"></script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="googlebot" content="NOODP" /><meta name="google-site-verification" content="nSYeDgyKM9mw5CWcZuD0xu7iSWXlJijAlg9rcxVOYf4" /><meta name="google-site-verification" content="6UEaC3SWhpGQvqRnSJIEm2swxXpM5Adn4dxZhFsNdw0" /><meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="viewport" name="viewport" /><link href="https://fonts.googleapis.com/css?family=Raleway:400,500,600,700" rel="stylesheet" /><link rel="stylesheet" href="/css/rabbit.css" type="text/css" /><link rel="stylesheet" href="/css/highlightjs_style.css" type="text/css" /><link rel="stylesheet" href="/css/rabbit-next.css" type="text/css" /><!--[if IE 6]>
      <link rel="stylesheet" href="/css/rabbit-ie6.css" type="text/css" />
      <![endif]--><link rel="icon" type="/image/vnd.microsoft.icon" href="/favicon.ico" /><link rel="stylesheet" href="/css/tutorial.css" type="text/css" /><script async="true" type="text/javascript" src="/js/site.js"></script><title> Persistence Configuration
 â€” RabbitMQ</title></head>
  <body id="persistence-conf"><div id="outerContainer"><div class="container"><div class="rabbit-logo"><a href="/"><img src="/img/logo-rabbitmq.svg" alt="RabbitMQ" /></a></div><a class="btn menubtn" onclick="showHide()">Menu <img src="/img/carrot-down-white.svg" /></a><div class="mobilemenuicon" onclick="showHide()"><img src="/img/mobile-menu-icon.svg" /></div><div id="nav"><ul id="mainNav"><li><a href="/#features">Features</a></li><li><a href="/#getstarted">Get Started</a></li><li><a href="/#support">Support</a></li><li><a href="/#community">Community</a></li><li><a href="/documentation.html">Docs</a></li></ul></div></div><div class="nav-separator"></div><div id="innerContainer" class="container"><div id="left-content"><h1> Persistence Configuration
</h1>


<h2><a id="overview" class="anchor" href="#overview">Overview</a></h2>
<p>This guide covers a few configurable
values that affect throughput, latency and I/O characteristics of a node.
Consider reading the entire guide and get accustomed to <a href="https://rabbitmq.github.io/rabbitmq-perf-test/stable/htmlsingle/">benchmarking with PerfTest</a>
before drawing any conclusions.</p>
<p>Some related guides include:</p>
<ul>
<li><a href="configure.html">Main configuration guide</a></li>
<li><a href="./relocate.html">File and Directory Locations</a></li>
<li><a href="./runtime.html">Runtime Tuning</a></li>
<li><a href="./queues.html#runtime-characteristics">Queues</a> and their runtime characteristics</li>
<li><a href="./quorum-queues.html">Quorum Queues</a></li>
<li><a href="./streams.html">Streams</a></li>
</ul>
<h2><a id="overview" class="anchor" href="#overview">Overview of Peristence in RabbitMQ</a></h2>
<p>Modern RabbitMQ versions provide several queue types plus streams:</p>
<ul>
<li><a href="./quorum-queues.html">Quorum queues</a>: replicated, durable, data-safety oriented</li>
<li><a href="./streams.html">Streams</a>: a replicated, durable data structure that supports different operations (than a queue)</li>
<li>Classic queues: the original queue type, oriented towards non-mirrored queue use cases (mirroring is deprecated)</li>
</ul>
<p>These queue types have different storage implementations and applicable configuration
settings that can be tuned are also different.</p>
<h2><a id="streams" class="anchor" href="#streams">Streams</a></h2>
<p>Streams use a log-based storage mechanism and keep very little data in memory
(primarily the operational data that has not yet been written to disk).
Nonetheless they offer excellent throughput when clients use the <a href="./stream.html">RabbitMQ Stream Protocol</a>.</p>
<p>Since streams are very disk I/O heavy, their throughput degrades with larger messages.
They benefit greatly from modern SSD and NVMe storage.</p>
<p>Streams offer no tunable storage parameters related to storage.</p>
<h2><a id="quorum-queues" class="anchor" href="#quorum-queues">Quorum Queues</a></h2>
<p>Quorum queues use a log-based storage mechanism implemented by RabbitMQ's Raft
implementation. They keep very little data in memory
(primarily the operational data that has not yet been written to disk).</p>
<p>As quorum queues persist all data to disks before doing anything it is recommended
to use the fastest disks possible.</p>
<p>Due to the disk I/O-heavy nature of quorum queues, their throughput decreases
as message sizes increase.</p>
<p>The primary storage-related setting that can affect quorum queue resource use
is the write-ahead log segment size limit, the limit at which WAL in-memory
table will be moved to disk. In other words, every quorum queue would be able to
keep up to this much message data in memory under steady load.</p>
<p>The limit can be controlled</p>
<pre class="lang-ini">
# Flush current WAL file to a segment file on disk once it reaches 32 MiB in size
raft.wal_max_size_bytes = 32000000
</pre>

<p>Because memory deallocation may take some time,
we recommend that the RabbitMQ node is allocated at least 3 times the memory of the default WAL file size limit.
More will be required in high-throughput systems.
4 times is a good starting point for those.</p>
<h2><a id="classic-queues" class="anchor" href="#classic-queues">Classic Queues</a></h2>
<p>Classic queues have two storage implementations available to them: v1 (the original
one) and v2 (available in RabbitMQ 3.10 and later versions).</p>
<h3><a id="queue-version" class="anchor" href="#queue-version">Queue Version</a></h3>
<p>Since <strong>RabbitMQ 3.10.0</strong>, the broker has a new implementation of
classic queues, named <strong>version 2</strong>. Version 2 queues have a new
index file format and implementation as well as a new per-queue
storage file format to replace the embedding of messages directly
in the index.</p>
<p>The main improvement from version 2 is improved stability while
under high memory pressure.</p>
<p>In <strong>RabbitMQ 3.10.0</strong> version 1 remains the default. It is possible
to switch back and forth between version 1 and version 2.</p>
<p>The version can be changed using the <span class="code ">queue-version</span> <a href="./parameters.html#policies">policy</a> key.
When setting a new version via policy the queue will immediately
convert its data on disk. It is possible to upgrade to version 2
or downgrade to version 1. Note that for large queues the conversion
may take some time and results in the queue being unavailable while
the conversion is running.</p>
<p>The default version can be set through configuration by setting
<span class="code ">classic_queue.default_version</span> in <span class="code ">rabbitmq.conf</span>:</p>
<pre class="lang-ini">
# makes classic queues use a more efficient message storage
# and queue index implementations
classic_queue.default_version = 2
</pre>

<h2><a id="cq-v1" class="anchor" href="#cq-v1">How Classic Queue v1 Persistence Overview</a></h2>
<p>First, some background: both persistent and transient messages
can be written to disk. Persistent messages will be written to
disk as soon as they reach the queue, while transient messages
will be written to disk only so that they can be evicted from
memory while under memory pressure. Persistent messages are also
kept in memory when possible and only evicted from memory under
memory pressure. The "persistence layer" refers to the mechanism
used to store messages of both types to disk.</p>
<p>On this page we say "queue" to refer to a non-replicated queue or a
queue leader or a queue mirror. Queue mirroring is a "layer above"
persistence.</p>
<p>The persistence layer has two components: the <em>queue index</em>
and the <em>message store</em>. The queue index is responsible for
maintaining knowledge about where a given message is in a queue,
along with whether it has been delivered and acknowledged. There
is therefore one queue index per queue.</p>
<p>The message store is a key-value store for messages, shared
among all queues in each vhost. Messages (the body, and any
metadata fields: properties and/or headers) can either be stored
directly in the queue index, or written to the message store. There are
technically two message stores (one for transient and one for
persistent messages) but they are usually considered together as
"the message store".</p>
<h3><a id="memory-costs" class="anchor" href="#memory-costs">Memory Costs</a></h3>
<p>Under memory pressure, the persistence layer tries to write as
much out to disk as possible, and remove as much as possible
from memory. There are some things however which must remain in
memory:</p>
<ul>
<li>Each queue maintains some metadata for each
   <em>unacknowledged</em> message. The message itself can be
   removed from memory if its destination is the message store.</li>
<li>The message store needs an index. The default message store
   index uses a small amount of memory for every message in the
   store.</li>
</ul>
<h3><a id="index-embedding" class="anchor" href="#index-embedding">Message Embedding in Queue Indices</a></h3>
<p>There are advantages and disadvantages to writing messages to
the queue index.</p>
<p>This feature has advantages and disadvantages. Main advantages are:</p>
<ul>
<li>Messages can be written to disk in one operation rather than
   two; for tiny messages this can be a substantial gain.</li>
<li>Messages that are written to the queue index do not require an
   entry in the message store index and thus do not have a memory
   cost when paged out.</li>
</ul>
<p>Disadvantages are:</p>
<ul>
<li>The queue index keeps blocks of a fixed number of records in
   memory; if non-tiny messages are written to the queue index then
   memory use can be substantial.</li>
<li>If a message is routed to multiple queues by an exchange, the
   message will need to be written to multiple queue indices. If
   such a message is written to the message store, only one copy
   needs to be written.</li>
<li>Unacknowledged messages whose destination is the queue index
   are always kept in memory.</li>
<li>Two writes are still required when <strong>version 2</strong> is used.</li>
</ul>
<p>The intent is for very small messages to be stored in the queue
index as an optimisation, and for all other messages to be
written to the message store. This is controlled by the
configuration item <span class="code ">queue_index_embed_msgs_below</span>. By
default, messages with a serialised size of less than 4096 bytes
(including properties and headers) are stored in the queue
index.</p>
<p>Each queue index needs to keep at least one segment file in
memory when reading messages from disk. The segment file
contains records for 16,384 messages. Therefore be cautious if
increasing <span class="code ">queue_index_embed_msgs_below</span>; a small
increase can lead to a large amount of memory used.</p>
<h2><a id="limits" class="anchor" href="#limits">OS and Runtime Limits Affecting </a></h2>
<p>It is possible for persistence to underperform because the
persister is limited in the number of file handles or async
threads it has to work with. In both cases this can happen when
you have a large number of queues which need to access the disk
simultaneously.</p>
<h3><a id="file-handles" class="anchor" href="#file-handles">Too Few File Handles</a></h3>
<p>The RabbitMQ server is limited in the <a href="./networking.html#open-file-handle-limit">number of file handles</a> it can open.
Every running network connection requires one file handle, and the rest are available
for queues to use. If there are more disk-accessing queues than
file handles after network connections have been taken into
account, then the disk-accessing queues will share the file
handles among themselves; each gets to use a file handle for a
while before it is taken back and given to another queue.</p>
<p>This prevents the server from crashing due to there being too
many disk-accessing queues, but it can become expensive. The
management plugin can show I/O statistics for each node in the
cluster; as well as showing rates of reads, writes, seeks and so
on it will also show a rate of file handle churn â€” the rate at
which file handles are recycled in this way. A busy server with
too few file handles might be doing hundreds of reopens per
second - in which case its performance is likely to increase
notably if given more file handles.</p>
<h2><a id="msg-store-index-implementations" class="anchor" href="#msg-store-index-implementations">Classic Queues v1: Alternate Message Store Index Implementations</a></h2>
<p>As mentioned above, each message which is written to the message
store uses a small amount of memory for its index entry. The
message store index used by classic queues v1 is pluggable in RabbitMQ, and other
implementations are available as plugins which can remove this
limitation.</p>
<p>The reason they are not shipped with the RabbitMQ distribution is
that they all use native code. Note that such plugins typically
make the message store run more slowly.</p><div id="help-and-feedback"><h2>Getting Help and Providing Feedback</h2><p>
                    If you have questions about the contents of this guide or
                    any other topic related to RabbitMQ, don't hesitate to ask them
                    on the <a href="https://groups.google.com/forum/#!forum/rabbitmq-users">RabbitMQ mailing list</a>.
                  </p></div><div id="contribute"><h2>Help Us Improve the Docs &lt;3</h2><p>
                    If you'd like to contribute an improvement to the site,
                    its source is <a href="https://github.com/rabbitmq/rabbitmq-website">available on GitHub</a>.
                    Simply fork the repository and submit a pull request. Thank you!
                  </p></div></div><div id="right-nav"><div id="in-this-section"><h4>In This Section</h4><ul>
     <li><a href="/admin-guide.html" class="selected">Server Documentation</a><ul>
       <li><a href="/configure.html" class="selected">Configuration</a><ul>
         <li><a href="/relocate.html">File Locations</a></li>
         <li><a href="/logging.html">Logging</a></li>
         <li><a href="/persistence-conf.html" class="selected">Persistence</a></li>
         <li><a href="/networking.html">Networking</a></li>
         <li><a href="/parameters.html">Parameters and Policies</a></li>
       </ul></li>
       <li><a href="/management.html">Management UI</a></li>
       <li><a href="/monitoring.html">Monitoring</a></li>
       <li><a href="/production-checklist.html">Production Checklist</a></li>
       <li><a href="/ssl.html">TLS Support</a></li>
       <li><a href="/streams.html">Streams</a></li>
       <li><a href="/feature-flags.html">Feature Flags</a></li>
       <li><a href="/distributed.html">Distributed RabbitMQ</a></li>
       <li><a href="/clustering.html">Clustering</a></li>
       <li><a href="/reliability.html">Reliable Delivery</a></li>
       <li><a href="/definitions.html">Schema Definition Export and Import</a></li>
       <li><a href="/backup.html">Backup and restore</a></li>
       <li><a href="/alarms.html">Alarms</a></li>
       <li><a href="/memory-use.html">Memory Use</a></li>
       <li><a href="/networking.html">Networking</a></li>
       <li><a href="/vhosts.html">Virtual Hosts</a></li>
       <li><a href="/access-control.html">Access Control (Authorisation)</a></li>
       <li><a href="/authentication.html">Authentication Mechanisms</a></li>
       <li><a href="/ldap.html">LDAP</a></li>
       <li><a href="/lazy-queues.html">Lazy Queues</a></li>
       <li><a href="/event-exchange.html">Internal Event Exchange</a></li>
       <li><a href="/firehose.html">Firehose (Message Tracing)</a></li>
       <li><a href="/manpages.html">Manual Pages</a></li>
       <li><a href="/windows-quirks.html">Windows Quirks</a></li>
       
       
       
       
     </ul></li>
     <li><a href="/clients.html">Client Documentation</a></li>
     <li><a href="/plugins.html">Plugins</a></li>
     <li><a href="/news.html">News</a></li>
     <li><a href="/protocol.html">Protocol</a></li>
     <li><a href="/extensions.html">Our Extensions</a></li>
     <li><a href="/build.html">Building</a></li>
     
     <li><a href="/mpl.html">License</a></li>
   </ul></div></div></div><div class="clear"></div><div class="pageFooter"><div class="container"></div><div class="container"><div class="rabbit-logo"><a href="/"><img src="/img/logo-rabbitmq-white.svg" alt="RabbitMQ" /></a></div><ul class="footerNav"><li><a href="/#features">Features</a></li><li><a href="/#getstarted">Get Started</a></li><li><a href="/#support">Support</a></li><li><a href="/#community">Community</a></li><li><a href="/documentation.html">Docs</a></li></ul><p id="copyright">
          Copyright Â© 2007-2023 <a href="https://tanzu.vmware.com/">VMware</a>, Inc. or its affiliates. All rights reserved.
          <a href="https://www.vmware.com/help/legal.html">Terms of Use</a> â€¢
          <a href="https://www.vmware.com/help/privacy.html">Privacy</a> â€¢
          <a href="/trademark-guidelines.html">Trademark Guidelines</a> â€¢
          <a href="https://www.vmware.com/help/privacy/california-privacy-rights.html">Your California Privacy Rights</a> â€¢
          <a class="ot-sdk-show-settings">Cookie Settings</a><br /><a id="teconsent"></a></p></div></div></div><script type="text/javascript" src="/js/highlight.pack.js"></script><script type="text/javascript">
        // code highlighting
        window.addEventListener("load", function() {
          const selectors = "pre.lang-apacheconf, \
                             pre.lang-bash, \
                             pre.lang-csharp, \
                             pre.lang-clojure, \
                             pre.lang-elixir, \
                             pre.lang-erlang, \
                             pre.lang-go, \
                             pre.lang-groovy, \
                             pre.lang-haskell, \
                             pre.lang-ini, \
                             pre.lang-java, \
                             pre.lang-javascript, \
                             pre.lang-json, \
                             pre.lang-makefile, \
                             pre.lang-nginxconf, \
                             pre.lang-objectivec, \
                             pre.lang-php, \
                             pre.lang-plaintext, \
                             pre.lang-powershell, \
                             pre.lang-python, \
                             pre.lang-ruby, \
                             pre.lang-swift, \
                             pre.lang-yaml, \
                             pre.lang-xml";
          document.querySelectorAll(selectors).forEach(function(el) {
            hljs.highlightBlock(el);
          });
        });
      </script></body>
</html>
