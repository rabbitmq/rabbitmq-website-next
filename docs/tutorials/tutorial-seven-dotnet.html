<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
      new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&amp;l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
      })(window,document,'script','dataLayer','GTM-NSPM4RC');</script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="googlebot" content="NOODP" /><meta name="google-site-verification" content="nSYeDgyKM9mw5CWcZuD0xu7iSWXlJijAlg9rcxVOYf4" /><meta name="google-site-verification" content="6UEaC3SWhpGQvqRnSJIEm2swxXpM5Adn4dxZhFsNdw0" /><meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="viewport" name="viewport" /><link href="https://fonts.googleapis.com/css?family=Raleway:400,500,600,700" rel="stylesheet" /><link rel="stylesheet" href="/css/rabbit.css" type="text/css" /><link rel="stylesheet" href="/css/highlightjs_style.css" type="text/css" /><link rel="stylesheet" href="/css/rabbit-next.css" type="text/css" /><!--[if IE 6]>
      <link rel="stylesheet" href="/css/rabbit-ie6.css" type="text/css" />
      <![endif]--><link rel="icon" type="/image/vnd.microsoft.icon" href="/favicon.ico" /><link rel="stylesheet" href="/css/tutorial.css" type="text/css" /><script async="true" type="text/javascript" src="/js/site.js"></script><title>RabbitMQ tutorial - Reliable Publishing with Publisher Confirms  — RabbitMQ</title>
    
  </head>
  <body id=""><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NSPM4RC" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="outerContainer"><div class="container"><div class="rabbit-logo"><a href="/"><img src="/img/logo-rabbitmq.svg" alt="RabbitMQ" /></a></div><a class="btn menubtn" onclick="showHide()">Menu <img src="/img/carrot-down-white.svg" /></a><div class="mobilemenuicon" onclick="showHide()"><img src="/img/mobile-menu-icon.svg" /></div><div id="nav"><ul id="mainNav"><li><a href="/#features">Features</a></li><li><a href="/#getstarted">Get Started</a></li><li><a href="/#support">Support</a></li><li><a href="/#community">Community</a></li><li><a href="/documentation.html">Docs</a></li></ul></div></div><div class="nav-separator"></div><div id="innerContainer" class="container">
<div id="sidebar" class="tutorial-seven">
   <table id="tutorials" xml:base="site/tutorials/tutorials-menu.xml.inc">
  <tr>
  <td id="tutorial-one">
    <h2><span class="tute-num">1</span> <a href="/tutorials/tutorial-one-python.html">"Hello World!"</a></h2>
    <p>
      The simplest thing that does <em>something</em>
    </p>
    <p><img src="/img/tutorials/python-one.png" width="180" /></p>
    <ul>
      <li><a href="/tutorials/tutorial-one-python.html">Python</a></li>
      <li><a href="/tutorials/tutorial-one-java.html">Java</a></li>
      <li><a href="/tutorials/tutorial-one-ruby.html">Ruby</a></li>
      <li><a href="/tutorials/tutorial-one-php.html">PHP</a></li>
      <li><a href="/tutorials/tutorial-one-dotnet.html">C#</a></li>
      <li><a href="/tutorials/tutorial-one-javascript.html">JavaScript</a></li>
      <li><a href="/tutorials/tutorial-one-go.html">Go</a></li>
      <li><a href="/tutorials/tutorial-one-elixir.html">Elixir</a></li>
      <li><a href="/tutorials/tutorial-one-objectivec.html">Objective-C</a></li>
      <li><a href="/tutorials/tutorial-one-swift.html">Swift</a></li>
      <li><a href="/tutorials/tutorial-one-spring-amqp.html">Spring AMQP</a></li>
    </ul>
  </td>

  <td id="tutorial-two">
    <h2><span class="tute-num">2</span> <a href="/tutorials/tutorial-two-python.html">Work queues</a></h2>
    <p>
      Distributing tasks among workers (the <a href="http://www.enterpriseintegrationpatterns.com/patterns/messaging/CompetingConsumers.html">competing consumers pattern</a>)
    </p>
    <p><img src="/img/tutorials/python-two.png" width="180" /></p>
    <ul>
        <li><a href="/tutorials/tutorial-two-python.html">Python</a></li>
        <li><a href="/tutorials/tutorial-two-java.html">Java</a></li>
        <li><a href="/tutorials/tutorial-two-ruby.html">Ruby</a></li>
        <li><a href="/tutorials/tutorial-two-php.html">PHP</a></li>
        <li><a href="/tutorials/tutorial-two-dotnet.html">C#</a></li>
        <li><a href="/tutorials/tutorial-two-javascript.html">JavaScript</a></li>
        <li><a href="/tutorials/tutorial-two-go.html">Go</a></li>
        <li><a href="/tutorials/tutorial-two-elixir.html">Elixir</a></li>
        <li><a href="/tutorials/tutorial-two-objectivec.html">Objective-C</a></li>
        <li><a href="/tutorials/tutorial-two-swift.html">Swift</a></li>
        <li><a href="/tutorials/tutorial-two-spring-amqp.html">Spring AMQP</a></li>
    </ul>
  </td>

  <td id="tutorial-three">
    <h2><span class="tute-num">3</span> <a href="/tutorials/tutorial-three-python.html">Publish/Subscribe</a></h2>
    <p>
      Sending messages to many consumers at once
    </p>
    <p><img src="/img/tutorials/python-three.png" height="50" width="180" /></p>
    <ul>
      <li><a href="/tutorials/tutorial-three-python.html">Python</a></li>
      <li><a href="/tutorials/tutorial-three-java.html">Java</a></li>
      <li><a href="/tutorials/tutorial-three-ruby.html">Ruby</a></li>
      <li><a href="/tutorials/tutorial-three-php.html">PHP</a></li>
      <li><a href="/tutorials/tutorial-three-dotnet.html">C#</a></li>
      <li><a href="/tutorials/tutorial-three-javascript.html">JavaScript</a></li>
      <li><a href="/tutorials/tutorial-three-go.html">Go</a></li>
      <li><a href="/tutorials/tutorial-three-elixir.html">Elixir</a></li>
      <li><a href="/tutorials/tutorial-three-objectivec.html">Objective-C</a></li>
      <li><a href="/tutorials/tutorial-three-swift.html">Swift</a></li>
      <li><a href="/tutorials/tutorial-three-spring-amqp.html">Spring AMQP</a></li>
    </ul>
  </td>
  </tr>

  <tr>
  <td id="tutorial-four">
    <h2><span class="tute-num">4</span> <a href="/tutorials/tutorial-four-python.html">Routing</a></h2>
    <p>
      Receiving messages selectively
    </p>
    <p><img src="/img/tutorials/python-four.png" height="50" width="180" /></p>
    <ul>
      <li><a href="/tutorials/tutorial-four-python.html">Python</a></li>
      <li><a href="/tutorials/tutorial-four-java.html">Java</a></li>
      <li><a href="/tutorials/tutorial-four-ruby.html">Ruby</a></li>
      <li><a href="/tutorials/tutorial-four-php.html">PHP</a></li>
      <li><a href="/tutorials/tutorial-four-dotnet.html">C#</a></li>
      <li><a href="/tutorials/tutorial-four-javascript.html">JavaScript</a></li>
      <li><a href="/tutorials/tutorial-four-go.html">Go</a></li>
      <li><a href="/tutorials/tutorial-four-elixir.html">Elixir</a></li>
      <li><a href="/tutorials/tutorial-four-objectivec.html">Objective-C</a></li>
      <li><a href="/tutorials/tutorial-four-swift.html">Swift</a></li>
      <li><a href="/tutorials/tutorial-four-spring-amqp.html">Spring AMQP</a></li>
    </ul>
  </td>

  <td id="tutorial-five">
    <h2><span class="tute-num">5</span> <a href="/tutorials/tutorial-five-python.html">Topics</a></h2>
    <p>
      Receiving messages based on a pattern (topics)
    </p>
    <p><img src="/img/tutorials/python-five.png" height="50" width="180" /></p>
    <ul>
      <li><a href="/tutorials/tutorial-five-python.html">Python</a></li>
      <li><a href="/tutorials/tutorial-five-java.html">Java</a></li>
      <li><a href="/tutorials/tutorial-five-ruby.html">Ruby</a></li>
      <li><a href="/tutorials/tutorial-five-php.html">PHP</a></li>
      <li><a href="/tutorials/tutorial-five-dotnet.html">C#</a></li>
      <li><a href="/tutorials/tutorial-five-javascript.html">JavaScript</a></li>
      <li><a href="/tutorials/tutorial-five-go.html">Go</a></li>
      <li><a href="/tutorials/tutorial-five-elixir.html">Elixir</a></li>
      <li><a href="/tutorials/tutorial-five-objectivec.html">Objective-C</a></li>
      <li><a href="/tutorials/tutorial-five-swift.html">Swift</a></li>
      <li><a href="/tutorials/tutorial-five-spring-amqp.html">Spring AMQP</a></li>
    </ul>
  </td>

  <td id="tutorial-six">
    <h2><span class="tute-num">6</span> <a href="/tutorials/tutorial-six-python.html">RPC</a></h2>
    <p>
      <a href="http://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html">Request/reply pattern</a> example
    </p>
    <p><img src="/img/tutorials/python-six.png" height="50" width="180" /></p>
    <ul>
      <li><a href="/tutorials/tutorial-six-python.html">Python</a></li>
      <li><a href="/tutorials/tutorial-six-java.html">Java</a></li>
      <li><a href="/tutorials/tutorial-six-ruby.html">Ruby</a></li>
      <li><a href="/tutorials/tutorial-six-php.html">PHP</a></li>
      <li><a href="/tutorials/tutorial-six-dotnet.html">C#</a></li>
      <li><a href="/tutorials/tutorial-six-javascript.html">JavaScript</a></li>
      <li><a href="/tutorials/tutorial-six-go.html">Go</a></li>
      <li><a href="/tutorials/tutorial-six-elixir.html">Elixir</a></li>
      <li><a href="/tutorials/tutorial-six-spring-amqp.html">Spring AMQP</a></li>
    </ul>
  </td>
  </tr>
  <tr>
  <td id="tutorial-seven">
    <h2><span class="tute-num">7</span> <a href="/tutorials/tutorial-seven-java.html">Publisher Confirms</a></h2>
    <p>
      Reliable publishing with publisher confirms
    </p>
    <ul>
      <li><a href="/tutorials/tutorial-seven-java.html">Java</a></li>
      <li><a href="/tutorials/tutorial-seven-dotnet.html">C#</a></li>
      <li><a href="/tutorials/tutorial-seven-php.html">PHP</a></li>
    </ul>
  </td>
  <td class="tutorial-empty"></td>
  <td class="tutorial-empty"></td>
  </tr>
</table>
</div>

<div id="tutorial">

<h2>Publisher Confirms</h2>
<p><div class="aside" xml:base="site/tutorials/tutorials-help.xml.inc">
    <h3>Prerequisites</h3>
    <p>
      This tutorial assumes RabbitMQ is <a href="/download.html">installed</a> and running
      on <span class="code ">localhost</span> on the <a href="/networking.html#ports">standard port</a> (<span class="code ">5672</span>). In case you use
      a different host, port or credentials, connections settings would require adjusting.
    </p>

    <h3>Where to get help</h3>
    <p>
        If you're having trouble going through this tutorial you can contact us through the
        <a href="https://groups.google.com/forum/#!forum/rabbitmq-users">mailing list</a>
        or <a href="https://rabbitmq-slack.herokuapp.com/">RabbitMQ community Slack</a>.
    </p>
  </div></p>
<p><a href="/confirms.html#publisher-confirms">Publisher confirms</a>
are a RabbitMQ extension to implement reliable
publishing. When publisher confirms are enabled on a channel,
messages the client publishes are confirmed asynchronously
by the broker, meaning they have been taken care of on the server
side.</p>
<h3>(using the .NET client)</h3>
<h3>Overview</h3>
<p>In this tutorial we're going to use publisher confirms to make
sure published messages have safely reached the broker. We will
cover several strategies to using publisher confirms and explain
their pros and cons.</p>
<h3>Enabling Publisher Confirms on a Channel</h3>
<p>Publisher confirms are a RabbitMQ extension to the AMQP 0.9.1 protocol,
so they are not enabled by default. Publisher confirms are
enabled at the channel level with the <span class="code ">ConfirmSelect</span> method:</p>
<pre class="lang-csharp">
var channel = connection.CreateModel();
channel.ConfirmSelect();
</pre>

<p>This method must be called on every channel that you expect to use publisher
confirms. Confirms should be enabled just once, not for every message published.</p>
<h3>Strategy #1: Publishing Messages Individually</h3>
<p>Let's start with the simplest approach to publishing with confirms,
that is, publishing a message and waiting synchronously for its confirmation:</p>
<pre class="lang-csharp">
while (ThereAreMessagesToPublish())
{
    byte[] body = ...;
    BasicProperties properties = ...;
    channel.BasicPublish(exchange, queue, properties, body);
    // uses a 5 second timeout
    channel.WaitForConfirmsOrDie(new TimeSpan(0, 0, 5));
}
</pre>

<p>In the previous example we publish a message as usual and wait for its
confirmation with the <span class="code ">Channel#WaitForConfirmsOrDie(TimeSpan)</span> method.
The method returns as soon as the message has been confirmed. If the
message is not confirmed within the timeout or if it is nack-ed (meaning
the broker could not take care of it for some reason), the method will
throw an exception. The handling of the exception usually consists
in logging an error message and/or retrying to send the message.</p>
<p>Different client libraries have different ways to synchronously deal with publisher confirms,
so make sure to read carefully the documentation of the client you are using.</p>
<p>This technique is very straightforward but also has a major drawback:
it <strong>significantly slows down publishing</strong>, as the confirmation of a message blocks the publishing
of all subsequent messages. This approach is not going to deliver throughput of
more than a few hundreds of published messages per second. Nevertheless, this can be
good enough for some applications.</p>
<blockquote>
<h4>Are Publisher Confirms Asynchronous?</h4>
<p>We mentioned at the beginning that the broker confirms published
messages asynchronously but in the first example the code waits
synchronously until the message is confirmed. The client actually
receives confirms asynchronously and unblocks the call to <span class="code ">WaitForConfirmsOrDie</span>
accordingly. Think of <span class="code ">WaitForConfirmsOrDie</span> as a synchronous helper
which relies on asynchronous notifications under the hood.</p>
</blockquote>
<h3>Strategy #2: Publishing Messages in Batches</h3>
<p>To improve upon our previous example, we can publish a batch
of messages and wait for this whole batch to be confirmed.
The following example uses a batch of 100:</p>
<pre class="lang-csharp">
var batchSize = 100;
var outstandingMessageCount = 0;
while (ThereAreMessagesToPublish())
{
    byte[] body = ...;
    BasicProperties properties = ...;
    channel.BasicPublish(exchange, queue, properties, body);
    outstandingMessageCount++;
    if (outstandingMessageCount == batchSize)
    {
        channel.WaitForConfirmsOrDie(new TimeSpan(0, 0, 5));
        outstandingMessageCount = 0;
    }
}
if (outstandingMessageCount &gt; 0)
{
    channel.WaitForConfirmsOrDie(new TimeSpan(0, 0, 5));
}
</pre>

<p>Waiting for a batch of messages to be confirmed improves throughput drastically over
waiting for a confirm for individual message (up to 20-30 times with a remote RabbitMQ node).
One drawback is that we do not know exactly what went wrong in case of failure,
so we may have to keep a whole batch in memory to log something meaningful or
to re-publish the messages. And this solution is still synchronous, so it
blocks the publishing of messages.</p>
<h3>Strategy #3: Handling Publisher Confirms Asynchronously</h3>
<p>The broker confirms published messages asynchronously, one just needs
to register a callback on the client to be notified of these confirms:</p>
<pre class="lang-csharp">
var channel = connection.CreateModel();
channel.ConfirmSelect();
channel.BasicAcks += (sender, ea) =&gt;
{
  // code when message is confirmed
};
channel.BasicNacks += (sender, ea) =&gt;
{
  //code when message is nack-ed
};
</pre>

<p>There are 2 callbacks: one for confirmed messages and one for nack-ed messages
(messages that can be considered lost by the broker). Both callbacks have a corresponding <span class="code ">EventArgs</span> parameter (<span class="code ">ea</span>) containing a:</p>
<ul>
<li>delivery tag: the sequence number identifying the confirmed
 or nack-ed message. We will see shortly how to correlate it with the published message.</li>
<li>multiple: this is a boolean value. If false, only one message is confirmed/nack-ed, if
 true, all messages with a lower or equal sequence number are confirmed/nack-ed.</li>
</ul>
<p>The sequence number can be obtained with <span class="code ">Channel#NextPublishSeqNo</span>
before publishing:</p>
<pre class="lang-csharp">
var sequenceNumber = channel.NextPublishSeqNo;
channel.BasicPublish(exchange, queue, properties, body);
</pre>

<p>A simple way to correlate messages with sequence number consists
in using a dictionary. Let's assume we want to publish strings because they are easy
to turn into an array of bytes for publishing. Here is a code
sample that uses a dictionary to correlate the publishing sequence number
with the string body of the message:</p>
<pre class="lang-csharp">
var outstandingConfirms = new ConcurrentDictionary&lt;ulong, string&gt;();
// ... code for confirm callbacks will come later
var body = "...";
outstandingConfirms.TryAdd(channel.NextPublishSeqNo, body);
channel.BasicPublish(exchange, queue, properties, Encoding.UTF8.GetBytes(body));
</pre>

<p>The publishing code now tracks outbound messages with a dictionary. We need
to clean this dictionary when confirms arrive and do something like logging a warning
when messages are nack-ed:</p>
<pre class="lang-csharp">
var outstandingConfirms = new ConcurrentDictionary&lt;ulong, string&gt;();

void cleanOutstandingConfirms(ulong sequenceNumber, bool multiple)
{
    if (multiple)
    {
        var confirmed = outstandingConfirms.Where(k =&gt; k.Key &lt;= sequenceNumber);
        foreach (var entry in confirmed)
        {
            outstandingConfirms.TryRemove(entry.Key, out _);
        }
    }
    else
    {
        outstandingConfirms.TryRemove(sequenceNumber, out _);
    }
}

channel.BasicAcks += (sender, ea) =&gt; cleanOutstandingConfirms(ea.DeliveryTag, ea.Multiple);
channel.BasicNacks += (sender, ea) =&gt;
{
    outstandingConfirms.TryGetValue(ea.DeliveryTag, out string body);
    Console.WriteLine($"Message with body {body} has been nack-ed. Sequence number: {ea.DeliveryTag}, multiple: {ea.Multiple}");
    cleanOutstandingConfirms(ea.DeliveryTag, ea.Multiple);
};

// ... publishing code
</pre>

<p>The previous sample contains a callback that cleans the dictionary when
confirms arrive. Note this callback handles both single and multiple
confirms. This callback is used when confirms arrive (<span class="code ">Channel#BasicAcks</span>). The callback for nack-ed messages
retrieves the message body and issues a warning. It then re-uses the
previous callback to clean the dictionary of outstanding confirms (whether
messages are confirmed or nack-ed, their corresponding entries in the dictionary
must be removed.)</p>
<blockquote>
<h4>How to Track Outstanding Confirms?</h4>
<p>Our samples use a <span class="code ">ConcurrentDictionary</span> to track outstanding confirms.
This data structure is convenient for several reasons. It allows to
easily correlate a sequence number with a message (whatever the message data
is) and to easily clean the entries up to a given sequence id (to handle
multiple confirms/nacks). At last, it supports concurrent access, because
confirm callbacks are called in a thread owned by the client library, which
should be kept different from the publishing thread.</p>
<p>There are other ways to track outstanding confirms than with
a sophisticated dictionary implementation, like using a simple concurrent hash table
and a variable to track the lower bound of the publishing sequence, but
they are usually more involved and do not belong to a tutorial.</p>
</blockquote>
<p>To sum up, handling publisher confirms asynchronously usually requires the
following steps:</p>
<ul>
<li>provide a way to correlate the publishing sequence number with a message.</li>
<li>register confirm listeners on the channel to be notified when
 publisher acks/nacks arrive to perform the appropriate actions, like
 logging or re-publishing a nack-ed message. The sequence-number-to-message
 correlation mechanism may also require some cleaning during this step.</li>
<li>track the publishing sequence number before publishing a message.</li>
</ul>
<blockquote>
<h4>Re-publishing nack-ed Messages?</h4>
<p>It can be tempting to re-publish a nack-ed message from the corresponding
callback but this should be avoided, as confirm callbacks are
dispatched in an I/O thread where channels are not supposed
to do operations. A better solution consists in enqueuing the message in an in-memory
queue which is polled by a publishing thread. A class like <span class="code ">ConcurrentQueue</span>
would be a good candidate to transmit messages between the confirm callbacks
and a publishing thread.</p>
</blockquote>
<h3>Summary</h3>
<p>Making sure published messages made it to the broker can be essential in some applications.
Publisher confirms are a RabbitMQ feature that helps to meet this requirement. Publisher
confirms are asynchronous in nature but it is also possible to handle them synchronously.
There is no definitive way to implement publisher confirms, this usually comes down
to the constraints in the application and in the overall system. Typical techniques are:</p>
<ul>
<li>publishing messages individually, waiting for the confirmation synchronously: simple, but very
 limited throughput.</li>
<li>publishing messages in batch, waiting for the confirmation synchronously for a batch: simple, reasonable
 throughput, but hard to reason about when something goes wrong.</li>
<li>asynchronous handling: best performance and use of resources, good control in case of error, but
 can be involved to implement correctly.</li>
</ul>
<h2>Putting It All Together</h2>
<p>The <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/dotnet/PublisherConfirms/PublisherConfirms.cs"><span class="code ">PublisherConfirms.cs</span></a>
class contains code for the techniques we covered. We can compile it, execute it as-is and
see how they each perform:</p>
<pre class="lang-bash">
dotnet run
</pre>

<p>The output will look like the following:</p>
<pre class="lang-bash">
Published 50,000 messages individually in 5,549 ms
Published 50,000 messages in batch in 2,331 ms
Published 50,000 messages and handled confirms asynchronously in 4,054 ms
</pre>

<p>The output on your computer should look similar if the client and the server sit 
on the same machine. Publishing messages individually performs poorly as expected, 
but the results for asynchronously handling are a bit disappointing compared to batch publishing.</p>
<p>Publisher confirms are very network-dependent, so we're better off
trying with a remote node, which is more realistic as clients
and servers are usually not on the same machine in production.
<span class="code ">PublisherConfirms.cs</span> can easily be changed to use a non-local node:</p>
<pre class="lang-csharp">
private static IConnection CreateConnection()
{
    var factory = new ConnectionFactory { HostName = "remote-host", UserName = "remote-host", Password = "remote-password" };
    return factory.CreateConnection();
}
</pre>

<p>Recompile the class, execute it again, and wait for the results:</p>
<pre class="lang-bash">
Published 50,000 messages individually in 231,541 ms
Published 50,000 messages in batch in 7,232 ms
Published 50,000 messages and handled confirms asynchronously in 6,332 ms
</pre>

<p>We see publishing individually now performs terribly. But
with the network between the client and the server, batch publishing and asynchronous handling
now perform similarly, with a small advantage for asynchronous handling of the publisher confirms.</p>
<p>Remember that batch publishing is simple to implement, but does not make it easy to know
which message(s) could not make it to the broker in case of negative publisher acknowledgment.
Handling publisher confirms asynchronously is more involved to implement but provide
better granularity and better control over actions to perform when published messages
are nack-ed.</p></div></div><div class="clear"></div><div class="pageFooter"><div class="container"></div><div class="container"><div class="rabbit-logo"><a href="/"><img src="/img/logo-rabbitmq-white.svg" alt="RabbitMQ" /></a></div><ul class="footerNav"><li><a href="/#features">Features</a></li><li><a href="/#getstarted">Get Started</a></li><li><a href="/#support">Support</a></li><li><a href="/#community">Community</a></li><li><a href="/documentation.html">Docs</a></li></ul><p id="copyright">
          Copyright © 2007-2020 <a href="https://tanzu.vmware.com/">VMware</a>, Inc. or its affiliates. All rights reserved.
          <a href="https://pivotal.io/legal">Terms of Use</a>,
          <a href="https://pivotal.io/privacy-policy">Privacy</a> and
          <a href="/trademark-guidelines.html">Trademark Guidelines</a><br /><a id="teconsent"></a></p></div></div></div><script type="text/javascript" src="/js/highlight.pack.js"></script><script type="text/javascript">
        // code highlighting
        window.addEventListener("load", function() {
          const selectors = "pre.lang-bash, \
                             pre.lang-csharp, \
                             pre.lang-elixir, \
                             pre.lang-erlang, \
                             pre.lang-go, \
                             pre.lang-groovy, \
                             pre.lang-haskell, \
                             pre.lang-html, \
                             pre.lang-ini, \
                             pre.lang-java, \
                             pre.lang-javascript, \
                             pre.lang-json, \
                             pre.lang-makefile, \
                             pre.lang-objectivec, \
                             pre.lang-php, \
                             pre.lang-plaintext, \
                             pre.lang-powershell, \
                             pre.lang-python, \
                             pre.lang-ruby, \
                             pre.lang-swift, \
                             pre.lang-yaml, \
                             pre.lang-xml";
          document.querySelectorAll(selectors).forEach(function(el) {
            hljs.highlightBlock(el);
          });
        });
      </script></body>
</html>
