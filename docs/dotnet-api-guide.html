<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="73d8ba46-8c12-43f6-8c22-24aa21b8d93d" name="onetrust-data-domain" /><meta content="https://tags.tiqcdn.com/utag/vmware/microsites-privacy/prod/utag.js" name="microsites-utag" /><script src="https://d1fto35gcfffzn.cloudfront.net/assets/jquery-1.11.2.min.js"></script><script src="//www.vmware.com/files/templates/inc/utag_data.js"></script><script src="//tags.tiqcdn.com/utag/vmware/microsites-privacy/prod/utag.sync.js"></script><script>function OptanonWrapper() { { window.dataLayer.push({ event: 'OneTrustGroupsUpdated' }); } }</script><script src="/js/gtm.js"></script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="googlebot" content="NOODP" /><meta name="google-site-verification" content="nSYeDgyKM9mw5CWcZuD0xu7iSWXlJijAlg9rcxVOYf4" /><meta name="google-site-verification" content="6UEaC3SWhpGQvqRnSJIEm2swxXpM5Adn4dxZhFsNdw0" /><meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="viewport" name="viewport" /><link href="https://fonts.googleapis.com/css?family=Raleway:400,500,600,700" rel="stylesheet" /><link rel="stylesheet" href="/css/rabbit.css" type="text/css" /><link rel="stylesheet" href="/css/highlightjs_style.css" type="text/css" /><link rel="stylesheet" href="/css/rabbit-next.css" type="text/css" /><!--[if IE 6]>
      <link rel="stylesheet" href="/css/rabbit-ie6.css" type="text/css" />
      <![endif]--><link rel="icon" type="/image/vnd.microsoft.icon" href="/favicon.ico" /><link rel="stylesheet" href="/css/tutorial.css" type="text/css" /><script async="true" type="text/javascript" src="/js/site.js"></script><title> .NET/C# Client API Guide
 — RabbitMQ</title></head>
  <body id="dotnet-api-guide"><div id="outerContainer"><div class="container"><div class="rabbit-logo"><a href="/"><img src="/img/logo-rabbitmq.svg" alt="RabbitMQ" /></a></div><a class="btn menubtn" onclick="showHide()">Menu <img src="/img/carrot-down-white.svg" /></a><div class="mobilemenuicon" onclick="showHide()"><img src="/img/mobile-menu-icon.svg" /></div><div id="nav"><ul id="mainNav"><li><a href="/#features">Features</a></li><li><a href="/#getstarted">Get Started</a></li><li><a href="/#support">Support</a></li><li><a href="/#community">Community</a></li><li><a href="/documentation.html">Docs</a></li></ul></div></div><div class="nav-separator"></div><div id="innerContainer" class="container"><div id="left-content"><h1> .NET/C# Client API Guide
</h1>


<h2><a id="overview" class="anchor" href="#overview">Overview</a></h2>
<p>This guide covers <a href="/dotnet.html">RabbitMQ .NET/C# client</a> and its public API.
It assumes that the <a href="https://www.nuget.org/packages/RabbitMQ.Client">most recent major version of the client</a> is used
and the reader is familiar with <a href="/getstarted.html">the basics</a>.</p>
<p>Key sections of the guide are:</p>
<ul>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#major-api-elements">Important interfaces and classes</a> in the public API</li>
<li><a href="#connecting">Connecting to RabbitMQ</a></li>
<li><a href="#connection-and-channel-lifspan">Connection and Channel Lifespan</a></li>
<li><a href="#client-provided-names">Client-provided connection name</a></li>
<li><a href="#exchanges-and-queues">Using Exchanges and Queues</a></li>
<li><a href="#publishing">Publishing Messages</a></li>
<li><a href="#consuming">Consuming Using a Subscription</a> and <a href="#consuming-memory-safety">Consumer Memory Safety</a></li>
<li><a href="#consuming-async">Async Consumer Implementations</a></li>
<li><a href="#concurrency">Concurrency Considerations and Safety</a></li>
<li><a href="#recovery">Automatic Recovery From Network Failures</a></li>
</ul>
<p>An <a href="https://rabbitmq.github.io/rabbitmq-dotnet-client/api/RabbitMQ.Client.html">API reference</a> is available separately.</p>
<h2><a id="dotnet-versions" class="anchor" href="#dotnet-versions">.NET Version Requirements</a></h2>
<p>6.x release series of this library <a href="/dotnet.html#overview">require .NET 4.6.1+ or a .NET Standard 2.0+ implementation</a>.
For 5.x releases, the requirements are <a href="/dotnet.html#overview">.NET 4.5.1+ or a .NET Standard 1.5+ implementation</a>.</p>
<h2><a id="license" class="anchor" href="#license">License</a></h2>
<p>The library is open source, developed <a href="https://github.com/rabbitmq/rabbitmq-dotnet-client/">on GitHub</a>, and is double-licensed under the</p>
<ul>
<li><a href="https://www.apache.org/licenses/LICENSE-2.0.html">Apache Public License 2.0</a></li>
<li><a href="https://www.mozilla.org/MPL/2.0/">Mozilla Public License 2.0</a></li>
</ul>
<p>This means that the user can consider the library to be licensed under any of the licenses from the list above.
For example, the user may choose the Apache Public License 2.0 and include this client into
a commercial product.</p>
<h2><a id="dependencies" class="anchor" href="#dependencies">Dependencies</a></h2>
<p>The client has a couple of dependencies:</p>
<ul>
<li><a href="https://www.nuget.org/packages/System.Memory/"><span class="code ">System.Memory</span></a> 4.5.x</li>
<li><a href="https://www.nuget.org/packages/System.Threading.Channels/"><span class="code ">System.Threading.Channels</span></a> 4.7.x</li>
</ul>
<p>Applications that use different versions of the same dependencies
should use <a href="https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/redirect-assembly-versions">assembly version redirection</a>,
<a href="https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/how-to-enable-and-disable-automatic-binding-redirection">automatic</a> or
explicit.</p>
<h2><a id="major-api-elements" class="anchor" href="#major-api-elements">Major namespaces, interfaces and classes</a></h2>
<p>The client API is closely modelled on the <a href="/tutorials/amqp-concepts.html">AMQP 0-9-1 protocol model</a>,
with additional abstractions for ease of use.</p>
<p>An <a href="https://rabbitmq.github.io/rabbitmq-dotnet-client/">API reference</a> is available separately.</p>
<p>The core API interfaces and classes are defined in the <span class="code ">RabbitMQ.Client</span> namespace:</p>
<pre class="lang-csharp">
using RabbitMQ.Client;
</pre>

<p>The core API interfaces and classes are</p>
<ul>
<li><span class="code ">IModel</span>: represents an AMQP 0-9-1 channel, and provides most of the operations (protocol methods)</li>
<li><span class="code ">IConnection</span>: represents an AMQP 0-9-1 connection</li>
<li><span class="code ">ConnectionFactory</span>: constructs <span class="code ">IConnection</span> instances</li>
<li><span class="code ">IBasicConsumer</span>: represents a message consumer</li>
</ul>
<p>Other useful interfaces and classes include:</p>
<ul>
<li><span class="code ">DefaultBasicConsumer</span>: commonly used base class for consumers</li>
</ul>
<p>Public namespaces other than <span class="code ">RabbitMQ.Client</span> include:</p>
<ul>
<li><span class="code ">RabbitMQ.Client.Events</span>: various events and event handlers
  that are part of the client library, including <span class="code ">EventingBasicConsumer</span>,
  a consumer implementation built around C# event handlers.</li>
<li><span class="code ">RabbitMQ.Client.Exceptions</span>: exceptions visible to the user.</li>
</ul>
<p>All other namespaces are reserved for private implementation detail of
the library, although members of private namespaces are usually made
available to applications using the library in order to permit
developers to implement workarounds for faults and gaps they
discover in the library implementation. Applications cannot rely on
any classes, interfaces, member variables etc. that appear within
private namespaces remaining stable across releases of the library.</p>
<h2><a id="connecting" class="anchor" href="#connecting">Connecting to RabbitMQ</a></h2>
<p>Before an application can use RabbitMQ, it has to open a <a href="connections.html">connection</a>
to a RabbitMQ node. The connection then will be used to perform all subsequent
operations. Connections are <strong>meant to be long-lived</strong>. Opening a connection
for every operation (e.g. publishing a message) would be very inefficient and is
<strong>highly discouraged</strong>.</p>
<p>To open a connection with the .NET client, first instantiate a <span class="code ">ConnectionFactory</span>
and configure it to use desired hostname, virtual host, credentials, <a href="/ssl.html">TLS settings</a>,
and any other parameters as needed.</p>
<p>Then call the <span class="code ">ConnectionFactory.CreateConnection()</span> method to open a connection.
Successful and unsuccessful client connection events can be <a href="/networking.html#logging">observed in server logs</a>.</p>
<p>The following two code snippets connect to a RabbitMQ node using a hostname configured
using the <span class="code ">hostName</span> property:</p>
<pre class="lang-csharp">
ConnectionFactory factory = new ConnectionFactory();
// "guest"/"guest" by default, limited to localhost connections
factory.UserName = user;
factory.Password = pass;
factory.VirtualHost = vhost;
factory.HostName = hostName;

IConnection conn = factory.CreateConnection();
</pre>

<pre class="lang-csharp">
ConnectionFactory factory = new ConnectionFactory();
factory.Uri = "amqp://user:pass@hostName:port/vhost";

IConnection conn = factory.CreateConnection();
</pre>

<h3><a id="endpoints-list" class="anchor" href="#endpoints-list">Using Lists of Endpoints</a></h3>
<p>It is possible to specify a list of endpoints to use when connecting. The first
reachable endpoint will be used. In case of <a href="#recovery">connection failures</a>, using
a list of endpoints makes it possible for the application to connect to a different
node if the original one is down.</p>
<p>To use multiple of endpoint, provide a list of <span class="code ">AmqpTcpEndpoint</span>s to <span class="code ">ConnectionFactory#CreateConnection</span>.
An <span class="code ">AmqpTcpEndpoint</span> represents a hostname and port pair.</p>
<pre class="lang-csharp">
ConnectionFactory factory = new ConnectionFactory();
factory.UserName = "username";
factory.Password = "s3Kre7";

var endpoints = new System.Collections.Generic.List&lt;AmqpTcpEndpoint&gt; {
  new AmqpTcpEndpoint("hostname"),
  new AmqpTcpEndpoint("localhost")
};
IConnection conn = factory.CreateConnection(endpoints);
</pre>

<h3><a id="connecting-uri" class="anchor" href="#connecting-uri"></a></h3>
<p>Since the .NET client uses a stricter interpretation of the <a href="/uri-spec.html">AMQP 0-9-1 URI spec</a>
than the other clients, care must be taken when using URIs.
In particular, the host part must not be omitted and virtual hosts with
empty names are not addressable.</p>
<p>All factory properties have default values. The default value for a property will be used if the property
remains unassigned prior to creating a connection:</p>
<table>
  <thead>
    <tr>
      <td>Property</td>
      <td>Default Value</td>
    </tr>
  </thead>

  <tr>
    <td>Username</td>
    <td><span class="code ">"guest"</span></td>
  </tr>

  <tr>
    <td>Password</td>
    <td><span class="code ">"guest"</span></td>
  </tr>

  <tr>
    <td>Virtual host</td>
    <td><span class="code ">"/"</span></td>
  </tr>

  <tr>
    <td>Hostname</td>
    <td><span class="code ">"localhost"</span></td>
  </tr>

  <tr>
    <td>Port</td>

    <td>
      <span class="code ">5672</span> for regular ("plain TCP") connections,
      <span class="code ">5671</span> for <a href="/ssl.html">connections with TLS enabled</a>
    </td>
  </tr>
</table>

<p>Note that <a href="/access-control.html">user guest can only connect from localhost</a> by default.
This is to limit well-known credential use in production systems.</p>
<p>The <span class="code ">IConnection</span> interface can then be used to open a <a href="channels.html">channel</a>:</p>
<pre class="lang-csharp">
IModel channel = conn.CreateModel();
</pre>

<p>The channel can now be used to send and receive messages,
as described in subsequent sections.</p>
<p>Just like connections, channels are <strong>meant to be long-lived</strong>. Opening a new channel
for every operation would be highly inefficient and is <strong>highly discouraged</strong>. Channels,
however, can have a shorter life span than connections. For example, certain
protocol errors will automatically close channels. If applications can recover
from them, they can open a new channel and retry the operation.</p>
<p>This is covered in more detail in the <a href="channels.html">Channel guide</a> as well as other
guides such as <a href="/confirms.html">Consumer Acknowledgements</a>.</p>
<h2><a id="disconnecting" class="anchor" href="#disconnecting">Disconnecting from RabbitMQ</a></h2>
<p>To disconnect, simply close the channel and the connection:</p>
<pre class="lang-csharp">
channel.Close();
conn.Close();
</pre>

<p>Disposing channel and connection objects is not enough, they must be explicitly closed
with the API methods from the example above.</p>
<p>Note that closing the channel may be considered good practice, but isn’t strictly necessary here - it will be done
automatically anyway when the underlying connection is closed.</p>
<p>Client disconnection events can be <a href="/networking.html#logging">observed in server node logs</a>.</p>
<h2><a id="connection-and-channel-lifspan" class="anchor" href="#connection-and-channel-lifspan">Connection and Channel Lifespan</a></h2>
<p>Connections are meant to be long-lived. The underlying protocol is designed and optimized for
long running connections. That means that opening a new connection per operation,
e.g. a message published, is unnecessary and strongly discouraged as it will introduce a lot of
network roundtrips and overhead.</p>
<p>Channels are also meant to be long-lived but since many recoverable protocol errors will
result in channel closure, channel lifespan could be shorter than that of its connection.
Closing and opening new channels per operation is usually unnecessary but can be
appropriate. When in doubt, consider reusing channels first.</p>
<p>Channel-level exceptions such as attempts to consume from a
queue that does not exist will result in channel closure. A closed channel can no
longer be used and will not receive any more events from the server (such
as message deliveries). Channel-level exceptions will be logged by RabbitMQ
and will initiate a shutdown sequence for the channel (see below).</p>
<h2><a id="client-provided-names" class="anchor" href="#client-provided-names">Client-Provided Connection Name</a></h2>
<p>RabbitMQ nodes have a limited amount of information about their clients:</p>
<ul>
<li>their TCP endpoint (source IP address and port)</li>
<li>the credentials used</li>
</ul>
<p>This information alone can make identifying applications and instances problematic, in particular when credentials can be
shared and clients connect over a load balancer but <a href="/networking.html#proxy-protocol">Proxy protocol</a> cannot be enabled.</p>
<p>To make it easier to identify clients in <a href="/logging.html">server logs</a> and <a href="/management.html">management UI</a>,
AMQP 0-9-1 client connections, including the RabbitMQ .NET client, can provide a custom identifier.
If set, the identifier will be mentioned in log entries and management UI. The identifier is known as
the <strong>client-provided connection name</strong>. The name can be used to identify an application or a specific component
within an application. The name is optional; however, developers are strongly encouraged to provide one
as it would significantly simplify certain operational tasks.</p>
<p>RabbitMQ .NET client provides a connection factory property,
<a href="https://rabbitmq.github.io/rabbitmq-dotnet-client/api/RabbitMQ.Client.ConnectionFactory.html#RabbitMQ_Client_ConnectionFactory_ClientProvidedName"><span class="code ">ConnectionFactory.ClientProvidedName</span></a>,
which, if set, controls the client-provided connection name for all new connections opened
by this factory.</p>
<p>Here's a modified connection example used above which provides such a name:</p>
<pre class="lang-csharp">
ConnectionFactory factory = new ConnectionFactory();
// "guest"/"guest" by default, limited to localhost connections
factory.UserName = user;
factory.Password = pass;
factory.VirtualHost = vhost;
factory.HostName = hostName;

// this name will be shared by all connections instantiated by
// this factory
factory.ClientProvidedName = "app:audit component:event-consumer"

IConnection conn = factory.CreateConnection();
</pre>

<h2><a id="exchanges-and-queues" class="anchor" href="#exchanges-and-queues">Using Exchanges and Queues</a></h2>
<p>Client applications work with exchanges and <a href="queues.html">queues</a>,
the high-level <a href="/tutorials/amqp-concepts.html">building blocks of the protocol</a>.
These must be "declared" before they can be
used. Declaring either type of object simply ensures that one of that
name exists, creating it if necessary.</p>
<p>Continuing the previous example, the following code declares an
exchange and a queue, then binds them together.</p>
<pre class="lang-csharp">
channel.ExchangeDeclare(exchangeName, ExchangeType.Direct);
channel.QueueDeclare(queueName, false, false, false, null);
channel.QueueBind(queueName, exchangeName, routingKey, null);
</pre>

<p>This will actively declare the following objects:</p>
<ul>
<li>a non-durable, non-autodelete exchange of "direct" type</li>
<li>a non-durable, non-autodelete, non-exclusive queue</li>
</ul>
<p>The exchange can be customised by using additional parameters.
The above code then binds the queue to the exchange with the given
routing key.</p>
<p>Many channel API (<span class="code ">IModel</span>) methods are overloaded. The convenient
short form of <span class="code ">ExchangeDeclare</span> uses sensible defaults. There are
also longer forms with more parameters, to let you override these
defaults as necessary, giving full control where needed.</p>
<p>This "short version, long version" pattern is used throughout the API.</p>
<h3><a id="passive-declaration" class="anchor" href="#passive-declaration">Passive Declaration</a></h3>
<p>Queues and exchanges can be declared "passively". A passive declare simply checks that the entity
with the provided name exists. If it does, the operation is a no-op. For queues successful
passive declares will return the same information as non-passive ones, namely the number of
consumers and messages in <a href="/confirms.html">ready state</a> in the queue.</p>
<p>If the entity does not exist, the operation fails with a channel level exception. The channel
cannot be used after that. A new channel should be opened. It is common to use one-off (temporary)
channels for passive declarations.</p>
<p><span class="code ">IModel#QueueDeclarePassive</span> and <span class="code ">IModel#ExchangeDeclarePassive</span> are the
methods used for passive declaration. The following example demonstrates <span class="code ">IModel#QueueDeclarePassive</span>:</p>
<pre class="lang-csharp">
var response = channel.QueueDeclarePassive("queue-name");
// returns the number of messages in Ready state in the queue
response.MessageCount;
// returns the number of consumers the queue has
response.ConsumerCount;
</pre>

<p><span class="code ">IModel#ExchangeDeclarePassive</span>'s return value contains no useful information. Therefore
if the method returns and no channel exceptions occurs, it means that the exchange does exist.</p>
<h3><a id="nowait-methods" class="anchor" href="#nowait-methods">Operations with Optional Responses</a></h3>
<p>Some common operations also have a "no wait" version which won't wait for server
response. For example, to declare a queue and instruct the server to not send any
response, use</p>
<pre class="lang-csharp">channel.QueueDeclareNoWait(queueName, true, false, false, null);</pre>

<p>The "no wait" versions are more efficient but offer lower safety guarantees, e.g. they
are more dependent on the <a href="/heartbeats.html">heartbeat mechanism</a> for detection of failed operations.
When in doubt, start with the standard version. The "no wait" versions are only needed in scenarios
with high topology (queue, binding) churn.</p>
<h3><a id="deleting-entities" class="anchor" href="#deleting-entities">Deleting Entities and Purging Messages</a></h3>
<p>A queue or exchange can be explicitly deleted:</p>
<pre class="lang-csharp">
channel.QueueDelete("queue-name", false, false);
</pre>

<p>It is possible to delete a queue only if it is empty:</p>
<pre class="lang-csharp">
channel.QueueDelete("queue-name", false, true);
</pre>

<p>or if it is not used (does not have any consumers):</p>
<pre class="lang-csharp">
channel.QueueDelete("queue-name", true, false);
</pre>

<p>A queue can be purged (all of its messages deleted):</p>
<pre class="lang-csharp">
channel.QueuePurge("queue-name")
</pre>

<h2><a id="publishing" class="anchor" href="#publishing">Publishing Messages</a></h2>
<p>To publish a message to an exchange, use <span class="code ">IModel.BasicPublish</span> as
follows:</p>
<pre class="lang-csharp">
byte[] messageBodyBytes = System.Text.Encoding.UTF8.GetBytes("Hello, world!");
channel.BasicPublish(exchangeName, routingKey, null, messageBodyBytes);
</pre>

<p>For fine control, you can use overloaded variants to specify the
mandatory flag, or specify messages properties:</p>
<pre class="lang-csharp">
byte[] messageBodyBytes = System.Text.Encoding.UTF8.GetBytes("Hello, world!");
IBasicProperties props = channel.CreateBasicProperties();
props.ContentType = "text/plain";
props.DeliveryMode = 2;
channel.BasicPublish(exchangeName, routingKey, props, messageBodyBytes);
</pre>

<p>This sends a message with delivery mode 2 (persistent) and
content-type "text/plain". See the definition of the <span class="code ">IBasicProperties</span>
interface for more information about the available message properties.</p>
<p>In the following example, we publish a message with custom headers:</p>
<pre class="lang-csharp">
byte[] messageBodyBytes = System.Text.Encoding.UTF8.GetBytes("Hello, world!");

IBasicProperties props = channel.CreateBasicProperties();
props.ContentType = "text/plain";
props.DeliveryMode = 2;
props.Headers = new Dictionary&lt;string, object&gt;();
props.Headers.Add("latitude",  51.5252949);
props.Headers.Add("longitude", -0.0905493);

channel.BasicPublish(exchangeName, routingKey, props, messageBodyBytes);
</pre>

<p>Code sample below sets a message expiration:</p>
<pre class="lang-csharp">
byte[] messageBodyBytes = System.Text.Encoding.UTF8.GetBytes("Hello, world!");

IBasicProperties props = channel.CreateBasicProperties();
props.ContentType = "text/plain";
props.DeliveryMode = 2;
props.Expiration = "36000000"

channel.BasicPublish(exchangeName, routingKey, props, messageBodyBytes);
</pre>

<h2><a id="consuming" class="anchor" href="#consuming">Retrieving Messages By Subscription ("push API")</a></h2>
<p>The recommended and most convenient way to receive messages is to set up a subscription using the
<span class="code ">IBasicConsumer</span> interface. The messages will then be delivered
automatically as they arrive, rather than having to be requested
proactively.</p>
<p>One way to implement a consumer is to use the
convenience class <span class="code ">EventingBasicConsumer</span>, which dispatches
deliveries and other consumer lifecycle events as C# events:</p>
<pre class="lang-csharp">
var consumer = new EventingBasicConsumer(channel);
consumer.Received += (ch, ea) =&gt;
                {
                    var body = ea.Body.ToArray();
                    // copy or deserialise the payload
                    // and process the message
                    // ...
                    channel.BasicAck(ea.DeliveryTag, false);
                };
// this consumer tag identifies the subscription
// when it has to be cancelled
String consumerTag = channel.BasicConsume(queueName, false, consumer);
</pre>

<p>Another option is to subclass <span class="code ">DefaultBasicConsumer</span>,
overriding methods as necessary, or implement <span class="code ">IBasicConsumer</span>
directly. You will generally want to implement the core method <span class="code ">IBasicConsumer.HandleBasicDeliver</span>.</p>
<p>More sophisticated consumers will need to implement further
methods. In particular, <span class="code ">HandleModelShutdown</span> traps
channel/connection closure. Consumers can also implement
<span class="code ">HandleBasicCancelOk</span> to be notified of cancellations.</p>
<p>The <span class="code ">ConsumerTag</span> property of <span class="code ">DefaultBasicConsumer</span> can be
used to retrieve the server-generated consumer tag, in cases where
none was supplied to the original <span class="code ">IModel.BasicConsume</span> call.</p>
<p>You can cancel an active consumer with <span class="code ">IModel.BasicCancel</span>:</p>
<pre class="lang-csharp">
channel.BasicCancel(consumerTag);
</pre>

<p>When calling the API methods, you always refer to consumers by their
consumer tags, which can be either client- or server-generated as
explained in the <a href="/specification.html">AMQP 0-9-1 specification</a> document.</p>
<h2><a id="consuming-memory-safety" class="anchor" href="#consuming-memory-safety">Consumer Memory Safety Requirements</a></h2>
<p>As of <a href="https://github.com/rabbitmq/rabbitmq-dotnet-client/blob/master/CHANGELOG.md">version 6.0</a> of
the .NET client, message payloads are represented using the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.readonlymemory-1?view=netcore-3.1"><span class="code ">System.ReadOnlyMemory&lt;byte&gt;</span></a>
type from the <a href="https://www.nuget.org/packages/System.Memory/"><span class="code ">System.Memory</span> library</a>.</p>
<p>This library places certain restrictions on when a read only memory span can be
accessed by applications.</p>
<p><strong>Important</strong>: consumer interface implementations <strong>must deserialize or copy delivery payload before delivery handler method returns</strong>.
Retaining a reference to the payload is not safe: the memory allocated for it can be deallocated at any moment
after the handler returns.</p>
<h2><a id="consuming-async" class="anchor" href="#consuming-async">Async Consumer Implementations</a></h2>
<p>The client provides an async-oriented consumer dispatch implementation. This dispatcher can only
be used with async consumers, that is, <span class="code ">IAsyncBasicConsumer</span> implementations.</p>
<p>In order to use this dispatcher, set the <span class="code ">ConnectionFactory.DispatchConsumersAsync</span> property to <span class="code ">true</span>:</p>
<pre class="lang-csharp">
ConnectionFactory factory = new ConnectionFactory();
// ...
// use async-oriented consumer dispatcher. Only compatible with IAsyncBasicConsumer implementations
factory.DispatchConsumersAsync = true;
</pre>

<p>then register a consumer that implements <span class="code ">IAsyncBasicConsumer</span>, such as <span class="code ">AsyncEventingBasicConsumer</span> or <span class="code ">AsyncDefaultBasicConsumer</span>:</p>
<pre class="lang-csharp">
var consumer = new AsyncEventingBasicConsumer(channel);
consumer.Received += async (ch, ea) =&gt;
    {
        var body = ea.Body.ToArray();
        // copy or deserialise the payload
        // and process the message
        // ...

        ch.BasicAck(ea.DeliveryTag, false);
        await Task.Yield();

    };
// this consumer tag identifies the subscription
// when it has to be cancelled
string tag = m.BasicConsume(queueName, false, consumer);
// ensure we get a delivery
bool waitRes = latch.WaitOne(2000);
</pre>

<h2><a id="basic-get" class="anchor" href="#basic-get">Fetching Individual Messages (Polling or "pull API")</a></h2>
<p>It is also possible to retrieve individual messages on demand ("pull API" a.k.a. polling).
This approach to consumption is <strong>very inefficient</strong> as it is effectively polling
and applications repeatedly have to ask for results even if the vast majority of the requests
yield no results. Therefore using this approach <strong>is highly discouraged</strong>.</p>
<p>To "pull" a message, use the <span class="code ">IModel.BasicGet</span> method.
The returned value is an instance of <span class="code ">BasicGetResult</span>, from which the header
information (properties) and message body can be extracted:</p>
<pre class="lang-csharp">
bool noAck = false;
BasicGetResult result = channel.BasicGet(queueName, noAck);
if (result == null) {
    // No message available at this time.
} else {
    IBasicProperties props = result.BasicProperties;
    ReadOnlyMemory&lt;byte&gt; body = result.Body;
    ...
</pre>

<p>The above example uses <a href="/confirms.html">automatic acknowledgements</a> (<span class="code ">noAck = false</span>), so the application must also call
<span class="code ">IModel.BasicAck</span> to acknowledge the delivery after processing:</p>
<pre class="lang-csharp">
    ...
    // acknowledge receipt of the message
    channel.BasicAck(result.DeliveryTag, false);
}
</pre>

<p>Note that fetching messages using this API is relatively inefficient. If you'd prefer
  RabbitMQ to push messages to the client, see the next section.</p>
<h2><a id="concurrency" class="anchor" href="#concurrency">Concurrency Considerations for Consumers</a></h2>
<p>There is a number of concurrency-related topics for a library user to consider.</p>
<h3><a id="concurrency-channel-sharing" class="anchor" href="#concurrency-channel-sharing">Sharing Channels Between Threads</a></h3>
<p>As a rule of thumb, <span class="code ">IModel</span> instance usage by more than
one thread simultaneously should be avoided. Application code
should maintain a clear notion of thread ownership for <span class="code ">IModel</span> instances.</p>
<p>This is a hard requirement for publishers: sharing a channel (an <span class="code ">IModel</span> instance)
for concurrent publishing will lead to incorrect frame interleaving at the protocol level.
Channel instances <strong>must not be shared</strong> by threads that publish on them.</p>
<p>If more than one thread needs to access a particular <span class="code ">IModel</span>
instances, the application should enforce mutual exclusion. One
way of achieving this is for all users of an <span class="code ">IModel</span> to
<span class="code ">lock</span> the instance itself:</p>
<pre class="lang-csharp">
IModel ch = RetrieveSomeSharedIModelInstance();
lock (ch) {
  ch.BasicPublish(...);
}
</pre>

<p>Symptoms of incorrect serialisation of <span class="code ">IModel</span> operations
include, but are not limited to,</p>
<ul>
<li><a href="/connections.html#error-handling">connection-level exceptions</a> due to invalid frame
   interleaving on the wire. RabbitMQ <a href="/logging.html">server logs</a> will
   contain unexpected frame errors in such scenario.</li>
<li>Pipelining and continuation exceptions thrown by the client</li>
</ul>
<p>Consumption that involve sharing a channel between threads should be avoided
when possible but can be done safely.</p>
<p>Consumers that can be multi-threaded or use a thread pool internally, including TPL-based
consumers, must use mutual exclusion of <a href="/confirms.html">acknowledgements</a> operations
on a shared channel.</p>
<h3><a id="concurrency-thread-usage" class="anchor" href="#concurrency-thread-usage">Per-Connection Thread Use</a></h3>
<p>Each <span class="code ">IConnection</span> instance is, in the current implementation,
backed by a single background thread that reads from the socket and
dispatches the resulting events to the application.
If heartbeats are enabled, they will use a pair of .NET timers per connection.</p>
<p>Usually, therefore, there will be at least two threads active in an application
using this library:</p>
<dl>
  <dt>the application thread</dt>
  <dd>
    contains the application logic, and makes
    calls on <span class="code ">IModel</span> methods to perform protocol operations.
  </dd>

  <dt>the I/O activity thread</dt>
  <dd>
    hidden away and completely managed by the
    <span class="code ">IConnection</span> instance.
  </dd>
</dl>

<p>The one place where the nature of the threading model is visible to
the application is in any callback the application registers with the
library. Such callbacks include:</p>
<ul>
<li>any <span class="code ">IBasicConsumer</span> method</li>
<li>the <span class="code ">BasicReturn</span> event on <span class="code ">IModel</span></li>
<li>any of the various shutdown events on <span class="code ">IConnection</span>, <span class="code ">IModel</span> etc.</li>
</ul>
<h3><a id="consumer-callbacks-and-ordering" class="anchor" href="#consumer-callbacks-and-ordering">Consumer Callbacks and Ordering</a></h3>
<p>As of version <span class="code ">3.5.0</span> application callback handlers <strong>can</strong> invoke blocking
operations (such as <span class="code ">IModel.QueueDeclare</span> or <span class="code ">IModel.BasicCancel</span>). <span class="code ">IBasicConsumer</span> callbacks are invoked concurrently.
However, per-channel operation order is preserved. In other words, if messages A and B were delivered
in this order on the same channel, they will be processed in this order. If messages A and B
were delivered on different channels, they can be processed in any order (or in parallel).
Consumer callbacks are invoked in tasks dispatched a <a href="https://msdn.microsoft.com/en-us/library/dd997402%28v=vs.110%29.aspx">TaskScheduler</a>.</p>
<h3><a id="custom-task-scheduler" class="anchor" href="#custom-task-scheduler">Using a Custom Task Scheduler</a></h3>
<p>It is possible to use a custom task scheduler by setting <span class="code ">ConnectionFactory.TaskScheduler</span>:</p>
<pre class="lang-csharp">
public class CustomTaskScheduler : TaskScheduler
{
  // ...
}

var cf = new ConnectionFactory();
cf.TaskScheduler = new CustomTaskScheduler();
</pre>

<p>This, for example, can be used to <a href="https://msdn.microsoft.com/en-us/library/ee789351%28v=vs.110%29.aspx">limit concurrency degree with a custom TaskScheduler</a>.</p>
<h2><a id="basic-return" class="anchor" href="#basic-return">Handling Unroutable Messages</a></h2>
<p>If a message is published with the "mandatory" flag
set, but cannot be delivered, the broker will return it to the sending
client (via a <span class="code ">basic.return</span> AMQP 0-9-1 command).</p>
<p>To be notified of such returns, clients can subscribe to the
<span class="code ">IModel.BasicReturn</span> event. If there are no listeners attached to the
event, then returned messages will be silently dropped.</p>
<pre class="lang-csharp">
model.BasicReturn += new RabbitMQ.Client.Events.BasicReturnEventHandler(...);
</pre>

<p>The <span class="code ">BasicReturn</span> event will fire, for example, if the client
publishes a message with the "mandatory" flag set to an exchange of
"direct" type which is not bound to a queue.</p>
<h2><a id="recovery" class="anchor" href="#recovery">Automatic Recovery From Network Failures</a></h2>
<h3><a id="connection-recovery" class="anchor" href="#connection-recovery">Connection Recovery</a></h3>
<p>Network connection between clients and RabbitMQ nodes can fail.
RabbitMQ .NET/C# client supports automatic recovery of connections
and topology (queues, exchanges, bindings, and consumers). The feature
has certain limitations covered later in this guide.</p>
<p>The automatic recovery process performs the following steps:</p>
<ul>
<li>Reconnect</li>
<li>Restore connection listeners</li>
<li>Re-open channels</li>
<li>Restore channel listeners</li>
<li>Restore channel <span class="code ">basic.qos</span> setting, publisher confirms and transaction settings</li>
</ul>
<p>Topology recovery starts after the above actions are completed. The following steps are
performed for every channel known to being open at the time of connection failure:</p>
<ul>
<li>Re-declare exchanges (except for predefined ones)</li>
<li>Re-declare queues</li>
<li>Recover all bindings</li>
<li>Recover all consumers</li>
</ul>
<p>To enable automatic connection recovery, set
<span class="code ">ConnectionFactory.AutomaticRecoveryEnabled</span> to true:</p>
<pre class="lang-csharp">
ConnectionFactory factory = new ConnectionFactory();
factory.AutomaticRecoveryEnabled = true;
// connection that will recover automatically
IConnection conn = factory.CreateConnection();
</pre>

<p>If recovery fails due to an exception (e.g. RabbitMQ node is
still not reachable), it will be retried after a fixed time interval (default
is 5 seconds). The interval can be configured:</p>
<pre class="lang-csharp">
ConnectionFactory factory = new ConnectionFactory();
// attempt recovery every 10 seconds
factory.NetworkRecoveryInterval = TimeSpan.FromSeconds(10);
</pre>

<h3><a id="recovery-triggers" class="anchor" href="#recovery-triggers">When Will Connection Recovery Be Triggered?</a></h3>
<p>Automatic connection recovery, if enabled, will be triggered by the following events:</p>
<ul>
<li>An I/O exception is thrown in connection's I/O loop</li>
<li>A socket read operation times out</li>
<li>Missed server <a href="/heartbeats.html">heartbeats</a> are detected</li>
<li>Any other unexpected exception is thrown in connection's I/O loop</li>
</ul>
<p>whichever happens first.</p>
<p>If initial client connection to a RabbitMQ node fails, automatic connection
recovery won't kick in. Applications developers are responsible for retrying
such connections, logging failed attempts, implementing a limit to the number
of retries and so on. Here's a very basic example:</p>
<pre class="lang-csharp">
ConnectionFactory factory = new ConnectionFactory();
// configure various connection settings

try {
  Connection conn = factory.CreateConnection();
} catch (RabbitMQ.Client.Exceptions.BrokerUnreachableException e) {
  Thread.Sleep(5000);
  // apply retry logic
}
</pre>

<p>When a connection is closed by the application via the <span class="code ">Connection.Close</span> method,
connection recovery will not be initiated.</p>
<p>Channel-level exceptions will not trigger any kind of recovery as they usually
indicate a semantic issue in the application (e.g. an attempt to consume from a
non-existent queue).</p>
<h3><a id="publishers" class="anchor" href="#publishers">Effects on Publishing</a></h3>
<p>Messages that are published using <span class="code ">IModel.BasicPublish</span> when connection is down
will be lost. The client does not enqueue them for delivery after connection has recovered.
To ensure that published messages reach RabbitMQ applications need to use <a href="confirms.html">Publisher Confirms</a>
and account for connection failures.</p>
<h3><a id="topology-recovery" class="anchor" href="#topology-recovery">Topology Recovery</a></h3>
<p>Topology recovery involves recovery of exchanges, queues, bindings
and consumers. It is enabled by default but can be disabled:</p>
<pre class="lang-csharp">
ConnectionFactory factory = new ConnectionFactory();

Connection conn = factory.CreateConnection();
factory.AutomaticRecoveryEnabled = true;
factory.TopologyRecoveryEnabled  = false;
</pre>

<h3><a id="automatic-recovery-limitations" class="anchor" href="#automatic-recovery-limitations">Failure Detection and Recovery Limitations</a></h3>
<p>Automatic connection recovery has a number of limitations and intentional
design decisions that applications developers need to be aware of.</p>
<p>When a connection is down or lost, it <a href="/heartbeats.html">takes time to detect</a>.
Therefore there is a window of time in which both the
library and the application are unaware of effective
connection failure.  Any messages published during this
time frame are serialised and written to the TCP socket
as usual. Their delivery to the broker can only be
guaranteed via <a href="/confirms.html">publisher confirms</a>: publishing in AMQP 0-9-1 is entirely
asynchronous by design.</p>
<p>When a socket or I/O operation error is detected by a
connection with automatic recovery enabled, recovery
begins after a configurable delay, 5 seconds by
default. This design assumes that even though a lot of
network failures are transient and generally short
lived, they do not go away in an instant. Connection recovery
attempts will continue at identical time intervals until
a new connection is successfully opened.</p>
<p>When a connection is in the recovering state, any
publishes attempted on its channels will be rejected
with an exception. The client currently does not perform
any internal buffering of such outgoing messages. It is
an application developer's responsibility to keep track of such
messages and republish them when recovery succeeds.
<a href="/confirms.html">Publisher confirms</a> is a protocol extension
that should be used by publishers that cannot afford message loss.</p>
<p>Connection recovery will not kick in when a channel is closed due to a
channel-level exception. Such exceptions often indicate application-level
issues. The library cannot make an informed decision about when that's
the case.</p>
<p>Closed channels won't be recovered even after connection recovery kicks in.
This includes both explicitly closed channels and the channel-level exception
case above.</p>
<h3><a id="basic-ack-and-recovery" class="anchor" href="#basic-ack-and-recovery">Manual Acknowledgements and Automatic Recovery</a></h3>
<p>When manual acknowledgements are used, it is possible that
network connection to RabbitMQ node fails between message
delivery and acknowledgement. After connection recovery,
RabbitMQ will reset delivery tags on all channels.</p>
<p>This means that <span class="code ">basic.ack</span>, <span class="code ">basic.nack</span>, and <span class="code ">basic.reject</span>
with old delivery tags will cause a channel exception. To avoid this,
RabbitMQ .NET client keeps track of and updates delivery tags to make them monotonically
growing between recoveries.</p>
<p><span class="code ">IModel.BasicAck</span>, <span class="code ">IModel.BasicNack</span>, and
<span class="code ">IModel.BasicReject</span> then translate adjusted delivery tags into those used by RabbitMQ.</p>
<p>Acknowledgements with stale delivery tags will not be
sent. Applications that use manual acknowledgements and automatic
recovery must be capable of handling redeliveries.</p><div id="help-and-feedback"><h2>Getting Help and Providing Feedback</h2><p>
                    If you have questions about the contents of this guide or
                    any other topic related to RabbitMQ, don't hesitate to ask them
                    on the <a href="https://groups.google.com/forum/#!forum/rabbitmq-users">RabbitMQ mailing list</a>.
                  </p></div><div id="contribute"><h2>Help Us Improve the Docs &lt;3</h2><p>
                    If you'd like to contribute an improvement to the site,
                    its source is <a href="https://github.com/rabbitmq/rabbitmq-website">available on GitHub</a>.
                    Simply fork the repository and submit a pull request. Thank you!
                  </p></div></div><div id="right-nav"><div id="in-this-section"><h4>In This Section</h4><ul>
     <li><a href="/admin-guide.html">Server Documentation</a></li>
     <li><a href="/clients.html" class="selected">Client Documentation</a><ul>
       <li><a href="/api-guide.html">Java Client Guide</a></li>
       <li><a href="/jms-client.html">JMS Client</a></li>
       <li><a href="/dotnet-api-guide.html" class="selected">.NET Client Guide</a></li>
       <li><a href="/erlang-client-user-guide.html">Erlang Client Guide</a></li>
       <li><a href="/heartbeats.html">Heartbeats</a></li>
       <li><a href="/amqp-0-9-1-reference.html">AMQP 0-9-1 Reference</a></li>
       <li><a href="/uri-spec.html">AMQP 0-9-1 URI Spec</a></li>
       
       
       
     </ul></li>
     <li><a href="/plugins.html">Plugins</a></li>
     <li><a href="/news.html">News</a></li>
     <li><a href="/protocol.html">Protocol</a></li>
     <li><a href="/extensions.html">Our Extensions</a></li>
     <li><a href="/build.html">Building</a></li>
     
     <li><a href="/mpl.html">License</a></li>
   </ul></div></div></div><div class="clear"></div><div class="pageFooter"><div class="container"></div><div class="container"><div class="rabbit-logo"><a href="/"><img src="/img/logo-rabbitmq-white.svg" alt="RabbitMQ" /></a></div><ul class="footerNav"><li><a href="/#features">Features</a></li><li><a href="/#getstarted">Get Started</a></li><li><a href="/#support">Support</a></li><li><a href="/#community">Community</a></li><li><a href="/documentation.html">Docs</a></li></ul><p id="copyright">
          Copyright © 2007-2021 <a href="https://tanzu.vmware.com/">VMware</a>, Inc. or its affiliates. All rights reserved.
          <a href="https://www.vmware.com/help/legal.html">Terms of Use</a> •
          <a href="https://www.vmware.com/help/privacy.html">Privacy</a> •
          <a href="/trademark-guidelines.html">Trademark Guidelines</a> •
          <a href="https://www.vmware.com/help/privacy/california-privacy-rights.html">Your California Privacy Rights</a> •
          <a class="ot-sdk-show-settings">Cookie Settings</a><br /><a id="teconsent"></a></p></div></div></div><script type="text/javascript" src="/js/highlight.pack.js"></script><script type="text/javascript">
        // code highlighting
        window.addEventListener("load", function() {
          const selectors = "pre.lang-bash, \
                             pre.lang-csharp, \
                             pre.lang-elixir, \
                             pre.lang-erlang, \
                             pre.lang-go, \
                             pre.lang-groovy, \
                             pre.lang-haskell, \
                             pre.lang-html, \
                             pre.lang-ini, \
                             pre.lang-java, \
                             pre.lang-javascript, \
                             pre.lang-json, \
                             pre.lang-makefile, \
                             pre.lang-objectivec, \
                             pre.lang-php, \
                             pre.lang-plaintext, \
                             pre.lang-powershell, \
                             pre.lang-python, \
                             pre.lang-ruby, \
                             pre.lang-swift, \
                             pre.lang-yaml, \
                             pre.lang-xml";
          document.querySelectorAll(selectors).forEach(function(el) {
            hljs.highlightBlock(el);
          });
        });
      </script></body>
</html>
