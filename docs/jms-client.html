<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="73d8ba46-8c12-43f6-8c22-24aa21b8d93d" name="onetrust-data-domain" /><meta content="https://tags.tiqcdn.com/utag/vmware/microsites-privacy/prod/utag.js" name="microsites-utag" /><script src="https://d1fto35gcfffzn.cloudfront.net/assets/jquery-1.11.2.min.js"></script><script src="//www.vmware.com/files/templates/inc/utag_data.js"></script><script src="//tags.tiqcdn.com/utag/vmware/microsites-privacy/prod/utag.sync.js"></script><script>function OptanonWrapper() { { window.dataLayer.push({ event: 'OneTrustGroupsUpdated' }); } }</script><script src="/js/gtm.js"></script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="googlebot" content="NOODP" /><meta name="google-site-verification" content="nSYeDgyKM9mw5CWcZuD0xu7iSWXlJijAlg9rcxVOYf4" /><meta name="google-site-verification" content="6UEaC3SWhpGQvqRnSJIEm2swxXpM5Adn4dxZhFsNdw0" /><meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="viewport" name="viewport" /><link href="https://fonts.googleapis.com/css?family=Raleway:400,500,600,700" rel="stylesheet" /><link rel="stylesheet" href="/css/rabbit.css" type="text/css" /><link rel="stylesheet" href="/css/highlightjs_style.css" type="text/css" /><link rel="stylesheet" href="/css/rabbit-next.css" type="text/css" /><!--[if IE 6]>
      <link rel="stylesheet" href="/css/rabbit-ie6.css" type="text/css" />
      <![endif]--><link rel="icon" type="/image/vnd.microsoft.icon" href="/favicon.ico" /><link rel="stylesheet" href="/css/tutorial.css" type="text/css" /><script async="true" type="text/javascript" src="/js/site.js"></script><title> RabbitMQ JMS Client
 — RabbitMQ</title></head>
  <body id="jms-client"><div id="outerContainer"><div class="container"><div class="rabbit-logo"><a href="/"><img src="/img/logo-rabbitmq.svg" alt="RabbitMQ" /></a></div><a class="btn menubtn" onclick="showHide()">Menu <img src="/img/carrot-down-white.svg" /></a><div class="mobilemenuicon" onclick="showHide()"><img src="/img/mobile-menu-icon.svg" /></div><div id="nav"><ul id="mainNav"><li><a href="/#features">Features</a></li><li><a href="/#getstarted">Get Started</a></li><li><a href="/#support">Support</a></li><li><a href="/#community">Community</a></li><li><a href="/documentation.html">Docs</a></li></ul></div></div><div class="nav-separator"></div><div id="innerContainer" class="container"><div id="left-content"><h1> RabbitMQ JMS Client
</h1>


<h2><a id="introduction" class="anchor" href="#introduction">Introduction</a></h2>
<p>RabbitMQ is not a JMS provider but includes <a href="https://github.com/rabbitmq/rabbitmq-server/tree/v3.9.x/deps/rabbitmq_jms_topic_exchange">a plugin</a>
needed to support the JMS Queue and Topic messaging models. JMS Client
for RabbitMQ implements the JMS 1.1 specification on top of the
<a href="./api-guide.html">RabbitMQ Java client</a>, thus allowing new and
existing JMS applications to connect to RabbitMQ.</p>
<p>The plugin and the JMS client are meant to work and be used together.</p>
<p>See the <a href="./java-versions.html">RabbitMQ Java libraries support page</a> for the support timeline
of the RabbitMQ JMS Client library.</p>
<h2><a id="components" class="anchor" href="#components">Components</a></h2>
<p>To fully leverage JMS with RabbitMQ, you need the following components:</p>
<ul>
<li>the <a href="https://github.com/rabbitmq/rabbitmq-jms-client">JMS client library</a> and its dependent libraries.</li>
<li><a href="https://github.com/rabbitmq/rabbitmq-server/tree/v3.9.x/deps/rabbitmq_jms_topic_exchange">RabbitMQ JMS topic selector plugin</a> that is included
   with RabbitMQ starting with version 3.6.3. To support message selectors for JMS
   topics, the RabbitMQ Topic Selector plugin must be installed on the
   RabbitMQ server. Message selectors allow a JMS application to filter
   messages using an expression based on SQL syntax. Message selectors
   for Queues are not currently supported.</li>
</ul>
<h2><a id="jms-amqp" class="anchor" href="#jms-amqp">JMS and AMQP 0-9-1</a></h2>
<p>JMS is the standard messaging API for the JEE platform. It is
available in commercial and open source implementations.  Each
implementation includes a JMS provider, a JMS client library, and
additional, implementation-specific components for administering the
messaging system. The JMS provider can be a standalone implementation
of the messaging service, or a bridge to a non-JMS messaging system.</p>
<p>The JMS client API is standardized, so JMS applications are portable
between vendors’ implementations. However, the underlying messaging
implementation is unspecified, so there is no interoperability between
JMS implementations. Java applications that want to share messaging
must all use the same JMS implementation unless bridging technology
exists. Furthermore, non-Java applications cannot access JMS without a
vendor-specific JMS client library to enable interoperability.</p>
<p>AMQP 0-9-1 is a messaging protocol, rather than an API like JMS. Any
client that implements the protocol can access a broker that supports
AMQP 0-9-1. Protocol-level interoperability allows AMQP 0-9-1 clients
written in any programming language and running on any operating
system to participate in the messaging system with no need to bridge
incompatible vendor implementations.</p>
<p>Because JMS Client for RabbitMQ is implemented using the RabbitMQ Java
client, it is compliant with both the JMS API and the AMQP 0-9-1 protocol.</p>
<p>You can download the JMS 1.1 specification and API documentation from
the <a href="http://www.oracle.com/technetwork/java/docs-136352.html">Oracle Technology Network Web site</a>.</p>
<h2><a id="limitations" class="anchor" href="#limitations">Limitations</a></h2>
<p>Some JMS 1.1 features are unsupported in the RabbitMQ JMS Client:</p>
<ul>
<li>The JMS Client does not support server sessions.</li>
<li>XA transaction support interfaces are not implemented.</li>
<li>Topic selectors are supported with the RabbitMQ JMS topic selector
 plugin. Queue selectors are not yet implemented.</li>
<li>SSL and socket options for RabbitMQ connections are supported, but
 only using the (default) SSL connection protocols that the RabbitMQ client provides.</li>
<li>The JMS <span class="code ">NoLocal</span> subscription feature, which prevents delivery of
 messages published from a subscriber’s own connection, is not supported
 with RabbitMQ. You can call a method that includes the <span class="code ">NoLocal</span>
 argument, but it is ignored.</li>
</ul>
<p>See <a href="jms-client-compliance.html">the JMS API compliance documentation</a> for a
detailed list of supported JMS APIs.</p>
<h2><a id="installing-configuring" class="anchor" href="#installing-configuring">Installing and Configuring</a></h2>
<h3><a id="plugin" class="anchor" href="#plugin">Enabling the Topic Selector Plug-in</a></h3>
<p>The topic selector plugin is included with RabbitMQ. Like any RabbitMQ
plugin, you need to enable the plugin in order to use it.</p>
<p>Enable the plugin using the <span class="code ">rabbitmq-plugins</span> command:</p>
<pre class="lang-bash">
rabbitmq-plugins enable rabbitmq_jms_topic_exchange
</pre>

<p>You don't need to restart the broker to activate the plugin.</p>
<p><strong><em>You need to enable this plugin only if you plan to use topic selectors
in your JMS client applications</em></strong>.</p>
<h3><a id="java-container" class="anchor" href="#java-container">Enabling the JMS client in a Java container</a></h3>
<p>To enable the JMS Client in a Java container (e.g. Java EE application
server, web container), you must install the JMS client JAR files and
its dependencies in the container and then define JMS resources in
the container’s naming system so that JMS clients can look them up.
The methods for accomplishing these tasks are container-specific, please
refer to the vendors’ documentation.</p>
<p>For standalone applications, you need to add the JMS client JAR files
and its dependencies to the application classpath. The JMS resources
can be defined programmatically or through a dependency injection
framework like Spring.</p>
<h3><a id="jms-connection-factory" class="anchor" href="#jms-connection-factory">Defining the JMS Connection Factory</a></h3>
<p>To define the JMS <span class="code ">ConnectionFactory</span> in JNDI, e.g. in Tomcat:</p>
<pre class="lang-xml">
&lt;Resource name="jms/ConnectionFactory"
            type="javax.jms.ConnectionFactory"
         factory="com.rabbitmq.jms.admin.RMQObjectFactory"
        username="guest"
        password="guest"
     virtualHost="/"
            host="localhost"
            port="5672"/&gt;
</pre>

<p>To define the JMS <span class="code ">ConnectionFactory</span> in JNDI, e.g. in WildFly (as of JMS Client 1.7.0):</p>
<pre class="lang-xml">
&lt;object-factory name="java:global/jms/ConnectionFactory"
                   module="org.jboss.genericjms.provider"
                   class="com.rabbitmq.jms.admin.RMQObjectFactory"&gt;
     &lt;environment&gt;
         &lt;property name="className" value="javax.jms.ConnectionFactory"/&gt;
         &lt;property name="username" value="guest"/&gt;
         &lt;property name="password" value="guest"/&gt;
         &lt;property name="virtualHost" value="/"/&gt;
         &lt;property name="host" value="localhost"/&gt;
         &lt;property name="port" value="5672"/&gt;
     &lt;/environment&gt;
&lt;/object-factory&gt;
</pre>

<p>Here is the equivalent Spring bean example (Java configuration):</p>
<pre class="lang-java">
@Bean
public ConnectionFactory jmsConnectionFactory() {
  RMQConnectionFactory connectionFactory = new RMQConnectionFactory();
  connectionFactory.setUsername("guest");
  connectionFactory.setPassword("guest");
  connectionFactory.setVirtualHost("/");
  connectionFactory.setHost("localhost");
  connectionFactory.setPort(5672);
  return connectionFactory;
}
</pre>

<p>And here is the Spring XML configuration:</p>
<pre class="lang-xml">
&lt;bean id="jmsConnectionFactory" class="com.rabbitmq.jms.admin.RMQConnectionFactory" &gt;
  &lt;property name="username" value="guest" /&gt;
  &lt;property name="password" value="guest" /&gt;
  &lt;property name="virtualHost" value="/" /&gt;
  &lt;property name="host" value="localhost" /&gt;
  &lt;property name="port" value="5672" /&gt;
&lt;/bean&gt;
</pre>

<p>The following table lists all of the attributes/properties that are available.</p>
<table>
<thead>
<tr>
<th>Attribute/Property</th>
<th>JNDI only?</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="code ">name</span></td>
<td>Yes</td>
<td>Name in JNDI.</td>
</tr>
<tr>
<td><span class="code ">type</span></td>
<td>Yes</td>
<td>Name of the JMS interface the object implements, usually <span class="code ">javax.jms.ConnectionFactory</span>. Other choices are <span class="code ">javax.jms.QueueConnectionFactory</span> and <span class="code ">javax.jms.TopicConnectionFactory</span>. You can also use the name of the (common) implementation class, <span class="code ">com.rabbitmq.jms.admin.RMQConnectionFactory</span>.</td>
</tr>
<tr>
<td><span class="code ">factory</span></td>
<td>Yes</td>
<td>JMS Client for RabbitMQ <span class="code ">ObjectFactory</span> class, always <span class="code ">com.rabbitmq.jms.admin.RMQObjectFactory</span>.</td>
</tr>
<tr>
<td><span class="code ">username</span></td>
<td>No</td>
<td>Name to use to authenticate a connection with the RabbitMQ broker. The default is "guest".</td>
</tr>
<tr>
<td><span class="code ">password</span></td>
<td>No</td>
<td>Password to use to authenticate a connection with the RabbitMQ broker. The default is "guest".</td>
</tr>
<tr>
<td><span class="code ">virtualHost</span></td>
<td>No</td>
<td>RabbitMQ <a href="./vhosts.html">virtual host</a> within which the application will operate. The default is "/".</td>
</tr>
<tr>
<td><span class="code ">host</span></td>
<td>No</td>
<td>Host on which RabbitMQ is running. The default is "localhost".</td>
</tr>
<tr>
<td><span class="code ">port</span></td>
<td>No</td>
<td>RabbitMQ port used for connections. The default is "5672" unless this is a <a href="./ssl.html">TLS connection</a>, in which case the default is "5671".</td>
</tr>
<tr>
<td><span class="code ">ssl</span></td>
<td>No</td>
<td>Whether to use an SSL connection to RabbitMQ. The default is "false". See the <span class="code ">useSslProtocol</span> methods for more information.</td>
</tr>
<tr>
<td><span class="code ">uri</span></td>
<td>No</td>
<td>The <a href="./uri-spec.html">AMQP 0-9-1 URI</a> string used to establish a RabbitMQ connection. The value can encode the <span class="code ">host</span>, <span class="code ">port</span>, <span class="code ">username</span>, <span class="code ">password</span> and <span class="code ">virtualHost</span> in a single string. Both 'amqp' and 'amqps' schemes are accepted. Note: this property sets other properties and the set order is unspecified.</td>
</tr>
<tr>
<td><span class="code ">onMessageTimeoutMs</span></td>
<td>No</td>
<td>How long to wait for <span class="code ">MessageListener#onMessage()</span> to return, in milliseconds. Default is 2000 ms.</td>
</tr>
<tr>
<td><span class="code ">preferProducerMessageProperty</span></td>
<td>No</td>
<td>Whether <span class="code ">MessageProducer</span> properties (delivery mode, priority, TTL) take precedence over respective <span class="code ">Message</span> properties or not. Default is true (which is compliant to the JMS specification).</td>
</tr>
<tr>
<td><span class="code ">requeueOnMessageListenerException</span></td>
<td>No</td>
<td>Whether requeuing messages on a <span class="code ">RuntimeException</span> in the <span class="code ">MessageListener</span> or not. Default is false.</td>
</tr>
<tr>
<td><span class="code ">queueBrowserReadMax</span></td>
<td>No</td>
<td>The maximum number of messages to read on a queue browser. Default is 0 (no limit).</td>
</tr>
<tr>
<td><span class="code ">onMessageTimeoutMs</span></td>
<td>No</td>
<td>The time in milliseconds <span class="code ">MessageListener#onMessage(Message)</span> can take to process a message. Default is 2000 ms.</td>
</tr>
<tr>
<td><span class="code ">channelsQos</span></td>
<td>No</td>
<td><a href="https://www.rabbitmq.com/consumer-prefetch.html">QoS setting</a> for channels created by the connection factory. Default is -1 (no QoS).</td>
</tr>
<tr>
<td><span class="code ">terminationTimeout</span></td>
<td>No</td>
<td>The time in milliseconds a <span class="code ">Connection#close()</span> should wait for threads/tasks/listeners to complete. Default is 15,000 ms.</td>
</tr>
<tr>
<td><span class="code ">declareReplyToDestination</span></td>
<td>No</td>
<td>Whether <span class="code ">replyTo</span> destination for consumed messages should be declared. Default is true.</td>
</tr>
</tbody>
</table>
<h2><a id="destination-interoperability" class="anchor" href="#destination-interoperability">JMS and AMQP 0-9-1 Destination Interoperability</a></h2>
<p>An interoperability feature allows you to define JMS 'amqp' destinations
that read and/or write to non-JMS RabbitMQ resources. <strong><em>Note this feature
does not support JMS topics</em></strong>.</p>
<p>A single 'amqp' destination can be defined for both sending and consuming.</p>
<h3>Sending JMS Messages to an AMQP Exchange</h3>
<p>A JMS destination can be defined so that a JMS application can send
<span class="code ">Message</span>s to a predefined RabbitMQ 'destination' (exchange/routing key)
using the JMS API in the normal way. The messages are written
"in the clear," which means that any AMQP 0-9-1 client can read them without
having to understand the internal format of Java JMS messages.
<strong><em>Only <span class="code ">BytesMessage</span>s and <span class="code ">TextMessage</span>s can be written in this way</em></strong>.</p>
<p>When messages are sent to an 'amqp' Destination, JMS message properties
are mapped onto AMQP 0-9-1 headers and properties as appropriate.
For example, the <span class="code ">JMSPriority</span> property converts to the <span class="code ">priority</span> property
for the AMQP 0-9-1 message. (It is also set as a header with the name
"JMSPriority".) User-defined properties are set as named message header
values, provided they are <span class="code ">boolean</span>, numeric or <span class="code ">String</span> types.</p>
<h3>Consuming Messages From an AMQP Queue</h3>
<p>Similarly, a JMS destination can be defined that reads messages from a
predefined RabbitMQ queue. A JMS application can then read these
messages using the JMS API. RabbitMQ JMS Client packs them up into
JMS Messages automatically. Messages read in this way are, by default,
<span class="code ">BytesMessage</span>s, but individual messages can be marked <span class="code ">TextMessage</span>
(by adding an AMQP message header called "JMSType" whose value is
"TextMessage"), which will interpret the byte-array payload as a UTF8
encoded String and return them as <span class="code ">TextMessage</span>s.</p>
<p>When reading from an 'amqp' Destination, values are mapped back to
JMS message properties, except that any explicit JMS property set as
a message header overrides the natural AMQP 0-9-1 header value, unless
this would misrepresent the message. For example,
<span class="code ">JMSDeliveryMode</span> cannot be overridden in this way.</p>
<h3>JMS 'amqp' <span class="code ">RMQDestination</span> Constructor</h3>
<p>The <span class="code ">com.rabbitmq.jms.admin</span> package contains the <span class="code ">RMQDestination</span> class,
which implements <span class="code ">Destination</span> in the JMS interface. This is extended
with a new constructor:</p>
<pre class="lang-java">
    public RMQDestination(String destinationName, String amqpExchangeName,
                          String amqpRoutingKey, String amqpQueueName);
</pre>

<p>This constructor creates a destination for JMS for RabbitMQ mapped
onto an AMQP 0-9-1 resource. The parameters are the following:</p>
<ul>
<li><span class="code ">destinationName</span> - the name of the queue destination</li>
<li><span class="code ">amqpExchangeName</span> - the exchange name for the mapped resource</li>
<li><span class="code ">amqpRoutingKey</span> - the routing key for the mapped resource</li>
<li><span class="code ">amqpQueueName</span> - the queue name of the mapped resource (to listen
 messages from)</li>
</ul>
<p>Applications that declare destinations in this way can use them directly,
or store them in a JNDI provider for JMS applications to retrieve.
Such destinations are non-temporary, queue destinations.</p>
<h3>JMS AMQP 0-9-1 Destination Definitions</h3>
<p>The <span class="code ">RMQDestination</span> object has the following new instance fields:</p>
<ul>
<li><span class="code ">amqp</span> – <em>boolean</em>, indicates if this is an AMQP 0-9-1 destination
 (if <strong>true</strong>); the default is <strong>false</strong>.</li>
<li><span class="code ">amqpExchangeName</span> – <em>String</em>, the RabbitMQ exchange name to use when
 sending messages to this destination, if <span class="code ">amqp</span> is <strong>true</strong>; the default
 is <strong>null</strong>.</li>
<li><span class="code ">amqpRoutingKey</span> – <em>String</em>, the AMQP 0-9-1 routing key to use when sending
 messages to this destination, if <span class="code ">amqp</span> is <strong>true</strong>; the default is <strong>null</strong>.</li>
<li><span class="code ">amqpQueueName</span> – <em>String</em>, the RabbitMQ queue name to use when reading
 messages from this destination, if <span class="code ">amqp</span> is <strong>true</strong>; the default is <strong>null</strong>.</li>
</ul>
<p>There are getters and setters for these fields, which means that a JNDI
 <span class="code ">&lt;Resource/&gt;</span> definition or an XML Spring bean definition can use them, for example
 JNDI with Tomcat:</p>
<pre class="lang-xml">
    &lt;Resource  name="jms/Queue"
               type="javax.jms.Queue"
            factory="com.rabbitmq.jms.admin.RMQObjectFactory"
    destinationName="myQueue"
               amqp="true"
      amqpQueueName="rabbitQueueName"
    /&gt;
</pre>

<p>This is the equivalent with WildFly (as of JMS Client 1.7.0):</p>
<pre class="lang-xml">
&lt;bindings&gt;
    &lt;object-factory name="java:global/jms/Queue"
                    module="foo.bar"
                    class="com.rabbitmq.jms.admin.RMQObjectFactory"&gt;
        &lt;environment&gt;
            &lt;property name="className" value="javax.jms.Queue"/&gt;
            &lt;property name="destinationName" value="myQueue"/&gt;
            &lt;property name="amqp" value="true"/&gt;
            &lt;property name="amqpQueueName" value="rabbitQueueName"/&gt;
        &lt;/environment&gt;
    &lt;/object-factory&gt;
&lt;/bindings&gt;
</pre>

<p>This is the equivalent Spring bean example (Java configuration):</p>
<pre class="lang-java">
    @Bean
    public Destination jmsDestination() {
        RMQDestination jmsDestination = new RMQDestination();
        jmsDestination.setDestinationName("myQueue");
        jmsDestination.setAmqp(true);
        jmsDestination.setAmqpQueueName("rabbitQueueName");
        return jmsDestination;
    }
</pre>

<p>And here is the Spring XML configuration:</p>
<pre class="lang-xml">
    &lt;bean id="jmsDestination" class="com.rabbitmq.jms.admin.RMQDestination" &gt;
     &lt;property name="destinationName" value="myQueue" /&gt;
     &lt;property name="amqp"            value="true" /&gt;
     &lt;property name="amqpQueueName"   value="rabbitQueueName" /&gt;
    &lt;/bean&gt;
</pre>

<p>Following is a <em>complete</em> list of the attributes/properties that are
available:</p>
<table>
<thead>
<tr>
<th>Attribute/Property Name</th>
<th>JNDI Only?</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="code ">name</span></td>
<td>Yes</td>
<td>Name in JNDI.</td>
</tr>
<tr>
<td><span class="code ">type</span></td>
<td>Yes</td>
<td>Name of the JMS interface the object implements, usually <span class="code ">javax.jms.Queue</span>. Other choices are <span class="code ">javax.jms.Topic</span> and <span class="code ">javax.jms.Destination</span>. You can also use the name of the (common) implementation class, <span class="code ">com.rabbitmq.jms.admin.RMQDestination</span>.</td>
</tr>
<tr>
<td><span class="code ">factory</span></td>
<td>Yes</td>
<td>JMS Client for RabbitMQ <span class="code ">ObjectFactory</span> class, always <span class="code ">com.rabbitmq.jms.admin.RMQObjectFactory</span>.</td>
</tr>
<tr>
<td><span class="code ">amqp</span></td>
<td>No</td>
<td>"<strong>true</strong>" means this is an 'amqp' destination. Default "<strong>false</strong>".</td>
</tr>
<tr>
<td><span class="code ">amqpExchangeName</span></td>
<td>No</td>
<td>Name of the RabbitMQ exchange to publish messages to when an 'amqp' destination. This exchange must exist when messages are published.</td>
</tr>
<tr>
<td><span class="code ">amqpRoutingKey</span></td>
<td>No</td>
<td>The routing key to use when publishing messages when an 'amqp' destination.</td>
</tr>
<tr>
<td><span class="code ">amqpQueueName</span></td>
<td>No</td>
<td>Name of the RabbitMQ queue to receive messages from when an 'amqp' destination. This queue must exist when messages are received.</td>
</tr>
<tr>
<td><span class="code ">destinationName</span></td>
<td>No</td>
<td>Name of the JMS destination.</td>
</tr>
</tbody>
</table>


<h2><a id="logging" class="anchor" href="#logging">Configuring Logging for the JMS Client</a></h2>
<p>The JMS Client logs messages using SLF4J (Simple Logging Façade for Java).
SLF4J delegates to a logging framework, such as Apache Logback.
If no other logging framework is
enabled, SLF4J defaults to a built-in, no-op, logger.
See the <a href="http://www.slf4j.org/docs.html">SLF4J</a> documentation for a
list of the logging frameworks SLF4J supports.</p>
<p>The target logging framework is configured at deployment time by adding
an SLF4J binding for the framework to the classpath.
For example, the Logback SLF4J binding is in the
<span class="code ">logback-classic-{version}.jar</span> file.
To direct JMS client log messages to Logback, for example,
add the following JARs to the classpath:</p>
<ul>
<li><a href="http://central.maven.org/maven2/org/slf4j/slf4j-api/1.7.25/slf4j-api-1.7.25.jar">slf4j-api-1.7.25.jar</a></li>
<li><a href="http://central.maven.org/maven2/ch/qos/logback/logback-core/1.2.3/logback-core-1.2.3.jar">logback-core-1.2.3.jar</a></li>
<li><a href="http://central.maven.org/maven2/ch/qos/logback/logback-classic/1.2.3/logback-classic-1.2.3.jar">logback-classic-1.2.3.jar</a></li>
</ul>
<p>We highly recommend to use a dependency management tool like <a href="http://maven.apache.org/">Maven</a>
or <a href="https://gradle.org/">Gradle</a> to manage dependencies.</p>
<p>The SLF4J API is backwards compatible, so you can use any version of
SLF4J. Version 1.7.5 or higher is recommended. The SLF4J API and
bindings, however, must be from the same SLF4J version.</p>
<p>No additional SLF4J configuration is required, once the API and
binding JAR files are in the classpath. However, the target framework
may have configuration files or command-line options.
Refer to the documentation for the target logging framework
for configuration details.</p>
<h2><a id="publisher-confirms" class="anchor" href="#publisher-confirms">Publisher Confirms</a></h2>
<p><a href="./confirms.html#publisher-confirms">Publisher confirms</a> are a RabbitMQ extension to implement reliable
publishing. This feature builds on top of the AMQP protocol, but the JMS client
provides an API to use it. This allows to benefit from a reliability feature without
diverging too much from the JMS API.</p>
<p>Publisher confirms are disabled by default. They can be enabled by setting
a <span class="code ">ConfirmListener</span> on the <span class="code ">RMQConnectionFactory</span>:</p>
<pre class="lang-java">
RMQConnectionFactory connectionFactory = new RMQConnectionFactory();
connectionFactory.setConfirmListener(context -&gt; {
    context.getMessage(); // the message that is confirmed/nack-ed
    context.isAck(); // whether the message is confirmed or nack-ed
});
</pre>

<p>Note the <span class="code ">ConfirmListener</span> is not a good place to execute long-running
tasks. Those should be executed in a dedicated thread, using e.g. an <span class="code ">ExecutorService</span>.</p>
<p>Typical operations in a <span class="code ">ConfirmListener</span> are logging or message re-publishing (in case
of nacks). The <a href="./tutorials/tutorial-seven-java.html">publish confirms tutorial</a> provides more guidance. It aims for the
AMQP Java client, but principles remain the same for the JMS client.</p>
<h2><a id="rpc-support" class="anchor" href="#rpc-support">Support for Request/Reply (a.k.a. RPC)</a></h2>
<p>It is possible to use JMS for synchronous request/reply use cases.
This pattern is commonly known as <em>Remote Procedure Call</em> or <em>RPC</em>.</p>
<h3>With JMS API</h3>
<p>An RPC client can be implemented in pure JMS like the following:</p>
<pre class="lang-java">
Message request = ... // create the request message
// set up reply-to queue and start listening on it
Destination replyQueue = session.createTemporaryQueue();
message.setJMSReplyTo(replyQueue);
MessageConsumer responseConsumer = session.createConsumer(replyQueue);
BlockingQueue&lt;Message&gt; queue = new ArrayBlockingQueue&lt;&gt;(1);
responseConsumer.setMessageListener(msg -&gt; queue.add(msg));
// send request message
MessageProducer producer = session.createProducer("request.queue");
producer.send(request);
// wait response for 5 seconds
Message response = queue.poll(5, TimeUnit.SECONDS);
// close the response consumer
responseConsumer.close();
</pre>

<p>It's also possible to create a single reply-to destination instead of
a temporary destination for each request. This is more efficient but requires
to properly correlate the response with the request, by using e.g.
a correlation ID header. RabbitMQ's <a href="direct-reply-to.html">direct reply-to</a>
is another alternative (see below).</p>
<p>Note this sample uses a <span class="code ">MessageListener</span> and a <span class="code ">BlockingQueue</span> to wait
for the response. This implies a network roundtrip to register an AMQP
consumer and another one to close the consumer.
<span class="code ">MessageConsumer#receive</span> could have been used as well, in this case the JMS
client internally polls the reply destination to get the response, which can result in several
network roundtrips if the response takes some time to come. The request
call will also incur a constant penalty equals to the polling interval (100 milliseconds
by default).</p>
<p>The server part looks like the following:</p>
<pre class="lang-java">
// this is necessary when using temporary reply-to destinations
connectionFactory.setDeclareReplyToDestination(false);
...
MessageProducer replyProducer = session.createProducer(null);
MessageConsumer consumer = session.createConsumer("request.queue");
consumer.setMessageListener(message -&gt; {
    try {
        Destination replyQueue = message.getJMSReplyTo();
        if (replyQueue != null) {
            // create response and send it
            Message response = ...
            replyProducer.send(replyQueue, response);
        }
    } catch (JMSException e) {
        // deal with exception
    }
});
</pre>

<p>Note the <span class="code ">connectionFactory.setDeclareReplyToDestination(false)</span>
statement: it is necessary when using temporary reply-to destinations.
If this flag is not set to <span class="code ">false</span> on the RPC server side, the JMS
client will try to re-create the temporary reply-to destination, which will
interfere with the client-side declaration.</p>
<p>See <a href="https://github.com/rabbitmq/rabbitmq-jms-client/blob/master/src/test/java/com/rabbitmq/integration/tests/RpcIT.java">this test</a>
for a full RPC example.</p>
<p>The JMS client also supports <a href="direct-reply-to.html">direct reply-to</a>, which is faster as it doesn't imply
creating a temporary reply destination:</p>
<pre class="lang-java">
Message request = ...
// use direct reply-to
RMQDestination replyQueue = new RMQDestination(
    "amq.rabbitmq.reply-to", "", "amq.rabbitmq.reply-to", "amq.rabbitmq.reply-to"
);
replyQueue.setDeclared(true); // don't need to create this destination
message.setJMSReplyTo(replyQueue);
MessageConsumer responseConsumer = session.createConsumer(replyQueue);
BlockingQueue&lt;Message&gt; queue = new ArrayBlockingQueue&lt;&gt;(1);
responseConsumer.setMessageListener(msg -&gt; queue.add(msg));
// send request message
MessageProducer producer = session.createProducer("request.queue");
producer.send(request);
// wait response for 5 seconds
Message response = queue.poll(5, TimeUnit.SECONDS);
// close the response consumer
responseConsumer.close();
</pre>

<p>Using direct reply-to for JMS-based RPC has the following implications:</p>
<ul>
<li>it uses automatically auto-acknowledgment</li>
<li>the response must be a <span class="code ">BytesMessage</span> or a <span class="code ">TextMessage</span> as direct reply-to
 is considered an <a href="#destination-interoperability">AMQP destination</a>. Use <span class="code ">response.setStringProperty("JMSType", "TextMessage")</span>
 on the response message in the RPC server if you want to receive a <span class="code ">TextMessage</span>
 on the client side.</li>
</ul>
<p>See <a href="https://github.com/rabbitmq/rabbitmq-jms-client/blob/master/src/test/java/com/rabbitmq/integration/tests/RpcWithAmqpDirectReplyIT.java">this test</a> for a full RPC example using direct reply-to.</p>
<h3>With Spring JMS</h3>
<p><a href="https://docs.spring.io/spring/docs/5.1.0.RELEASE/spring-framework-reference/integration.html#jms">Spring JMS</a>
is a popular way to work with JMS as it avoids most of JMS boilerplate.</p>
<p>The following sample shows how a client can perform RPC with the
<span class="code ">JmsTemplate</span>:</p>
<pre class="lang-java">
// NB: do not create a new JmsTemplate for each request
JmsTemplate tpl = new JmsTemplate(connectionFactory);
tpl.setReceiveTimeout(5000);
Message response = tpl.sendAndReceive(
    "request.queue",
    session -&gt; ... // create request message in MessageCreator
);
</pre>

<p>This is no different from any other JMS client.</p>
<p>The <span class="code ">JmsTemplate</span> uses a temporary reply-to destination,
so the call to <span class="code ">connectionFactory.setDeclareReplyToDestination(false)</span>
on the RPC server side is necessary, just like with regular JMS.</p>
<p>RPC with direct reply-to
must be implemented with a <span class="code ">SessionCallback</span>, as the reply destination
must be explicitly declared:</p>
<pre class="lang-java">
// NB: do not create a new JmsTemplate for each request
JmsTemplate tpl = new JmsTemplate(connectionFactory);
Message response = tpl.execute(session -&gt; {
    Message request = ... // create request message
    // setup direct reply-to as reply-to destination
    RMQDestination replyQueue = new RMQDestination(
        "amq.rabbitmq.reply-to", "", "amq.rabbitmq.reply-to", "amq.rabbitmq.reply-to"
    );
    replyQueue.setDeclared(true); // no need to create this destination
    message.setJMSReplyTo(replyQueue);
    MessageConsumer responseConsumer = session.createConsumer(replyQueue);
    BlockingQueue&lt;Message&gt; queue = new ArrayBlockingQueue&lt;&gt;(1);
    responseConsumer.setMessageListener(msg -&gt; queue.add(msg));
    // send request message
    MessageProducer producer = session.createProducer(session.createQueue("request.queue"));
    producer.send(message);
    try {
        // wait response for 5 seconds
        Message response = queue.poll(5, TimeUnit.SECONDS);
        // close the response consumer
        responseConsumer.close();
        return response;
    } catch (InterruptedException e) {
        // deal with exception
    }
});
</pre>

<p>See <a href="https://github.com/rabbitmq/rabbitmq-jms-client/blob/master/src/test/java/com/rabbitmq/integration/tests/RpcSpringJmsIT.java">this test</a>
for a full example of RPC with Spring JMS, including using a <span class="code ">@JmsListener</span> bean
for the server part.</p>
<h2><a id="implementation-details" class="anchor" href="#implementation-details">Implementation Details</a></h2>
<p>This section provides additional implementation details for specific
JMS API classes in the JMS Client.</p>
<p>Deviations from the specification are implemented to support common
acknowledgement behaviours.</p>
<h2><a id="jms_topic_support"></a>JMS Topic Support</h2>
<p>JMS topics are implemented using an AMQP <a href="./tutorials/amqp-concepts.html#exchange-topic">topic exchange</a>
and a dedicated AMQP queue for each JMS topic subscriber. The AMQP
topic exchange is <span class="code ">jms.temp.topic</span> or <span class="code ">jms.durable.topic</span>, depending
on whether the JMS topic is temporary or not, respectively. Let's
take an example with a subscription to a durable <span class="code ">my.jms.topic</span> JMS topic:</p>
<ul>
<li>a dedicated AMQP queue is created for this subscriber, its name
 will follow the pattern <span class="code ">jms-cons-{UUID}</span>.</li>
<li>the <span class="code ">jms-cons-{UUID}</span> AMQP queue is bound to the <span class="code ">jms.durable.topic</span>
 exchange with the <span class="code ">my.jms.topic</span> binding key.</li>
</ul>
<p>If another subscriber subscribes to <span class="code ">my.jms.topic</span>, it will have
its own AMQP queue and both subscribers will receive messages published
to the <span class="code ">jms.durable.topic</span> exchange with the <span class="code ">my.jms.topic</span> routing key.</p>
<p>The example above assumes no topic selector is used when declaring the
subscribers. If a topic selector is in use, a <span class="code ">x-jms-topic</span>-typed exchange
will sit between the <span class="code ">jms.durable.topic</span> topic exchange and the
subscriber queue. So the topology is the following when subscribing to
a durable <span class="code ">my.jms.topic</span> JMS topic with a selector:</p>
<ul>
<li>a dedicated AMQP queue is created for this subscriber, its name
 will follow the pattern <span class="code ">jms-cons-{UUID}</span>.</li>
<li>a <span class="code ">x-jms-topic</span>-typed exchange is bound to the subscriber AMQP queue with
 the <span class="code ">my.jms.topic</span> binding key and some arguments related to the selector
 expressions. Note this exchange is scoped to the JMS session and not only
 to the subscriber.</li>
<li>the <span class="code ">x-jms-topic</span>-typed exchange is bound to the <span class="code ">jms.durable.topic</span>
 exchange with the <span class="code ">my.jms.topic</span> binding key.</li>
</ul>
<p>Exchanges can be bound together thanks to a <a href="e2e.html">RabbitMQ extension</a>.
Note the <a href="#plugin">topic selector plugin</a> must be enabled for topic selectors
to work.</p>
<h2><a id="queue-browser-support" class="anchor" href="#queue-browser-support">QueueBrowser Support</a></h2>
<h3>Overview of queue browsers</h3>
<p>The JMS API includes objects and methods to browse an existing queue
destination, reading its messages <em>without</em> removing them from the
queue. Topic destinations cannot be browsed in this manner.</p>
<p>A <span class="code ">QueueBrowser</span> can be created from a (queue) <span class="code ">Destination</span>,
with or without a selector expression. The browser has a <span class="code ">getEnumeration()</span>
method, which returns a Java <span class="code ">Enumeration</span> of <span class="code ">Message</span>s copied from
the queue.</p>
<p>If no selector is supplied, then all messages in the queue appear
in the <span class="code ">Enumeration</span>. If a selector is supplied, then only those
messages that satisfy the selector appear.</p>
<h3>Implementation</h3>
<p>The destination queue is read when the <span class="code ">getEnumeration()</span> method is
called. A <em>snapshot</em> is taken of the messages in the queue; and the
selector expression, if one is supplied, is used at this time to discard
messages that do not match.</p>
<p>The message copies may now be read using the <span class="code ">Enumeration</span> interface
(<span class="code ">nextElement()</span> and <span class="code ">hasMoreElements()</span>).</p>
<p>The selector expression and the destination queue of the <span class="code ">QueueBrowser</span>
may not be adjusted after the <span class="code ">QueueBrowser</span> is created.</p>
<p>An <span class="code ">Enumeration</span> cannot be "reset", but the <span class="code ">getEnumeration()</span> method
may be re-issued, taking a <em>new</em> snapshot from the queue each time.</p>
<p>The contents of an <span class="code ">Enumeration</span> survive session and/or connection
close, but a <span class="code ">QueueBrowser</span> may not be used after the session that
created it has closed. <span class="code ">QueueBrowser.close()</span> has no effect.</p>
<h4>Which messages are included</h4>
<p>Messages that arrive, expire, are re-queued, or are removed after
the <span class="code ">getEnumeration()</span> call have no effect on the contents of the
<span class="code ">Enumeration</span> it produced. If the messages in the queue change
<em>while the</em> <span class="code ">Enumeration</span> <em>is being built</em>, they may or may not be
included. In particular, if messages from the queue are simultaneously
read by another client (or session), they may or may not appear in
the <span class="code ">Enumeration</span>.</p>
<p>Message copies do not "expire" from an <span class="code ">Enumeration</span>.</p>
<h4>Order of messages</h4>
<p>If other client sessions read from a queue that is being browsed,
then it is possible that some messages may subsequently be received out
of order.</p>
<p>Message order will not be disturbed if no other client sessions read
the queue at the same time.</p>
<h4>Memory usage</h4>
<p>When a message is read from the <span class="code ">Enumeration</span> (with <span class="code ">nextElement()</span>),
then no reference to it is retained in the Java Client. This means the
storage it occupies in the client is eligible for release
(by garbage collection) if no other references are retained.
Retaining an <span class="code ">Enumeration</span> will retain the storage for all message
copies that remain in it.</p>
<p>If the queue has many messages -- or the messages it contains are very
large -- then a <span class="code ">getEnumeration()</span> method call may consume a large
amount of memory in a very short time. This remains true even if only
a few messages are selected. There is currently limited protection
against <span class="code ">OutOfMemoryError</span> conditions that may arise because of this.
See the next section.</p>
<h4>Setting a maximum number of messages to browse</h4>
<p>Each connection is created with a limit on the number of messages that
are examined by a <span class="code ">QueueBrowser</span>. The limit is set on the
<span class="code ">RMQConnectionFactory</span> by <span class="code ">RMQConnectionFactory.setQueueBrowserReadMax(int)</span>
and is passed to each <span class="code ">Connection</span> subsequently created
by <span class="code ">ConnectionFactory.createConnection()</span>.</p>
<p>The limit is an integer that, if positive, stops the queue browser from
reading more than this number of messages when building an enumeration.
If it is zero or negative, it is interpreted as imposing no limit on
the browser, and all of the messages on the queue are scanned.</p>
<p>The default limit for a factory is determined by the
<span class="code ">rabbit.jms.queueBrowserReadMax</span> system property, if set, and the value
is specified as <span class="code ">0</span> if this property is not set or is not an integer.</p>
<p>If a <span class="code ">RMQConnectionFactory</span> value is obtained from a JNDI provider,
then the limit set when the factory object was created is preserved.</p>
<h4>Release Support</h4>
<p>Support for <span class="code ">QueueBrowser</span>s is introduced in the JMS Client 1.2.0.
Prior to that release, calling <span class="code ">Session.createBrowser(Queue queue[, String selector])</span>
resulted in an <span class="code ">UnsupportedOperationException</span>.</p>
<h3>Group and individual acknowledgement</h3>
<p>Prior to version 1.2.0 of the JMS client, in client acknowledgement mode
(<span class="code ">Session.CLIENT_ACKNOWLEDGE</span>), acknowledging any message from an open
session would acknowledge <em>every</em> unacknowledged message of that session,
whether they were received before or after the message being acknowledged.</p>
<p>Currently, the behaviour of <span class="code ">Session.CLIENT_ACKNOWLEDGE</span> mode is
modified so that, when calling <span class="code ">msg.acknowledge()</span>, only the message
<span class="code ">msg</span> <em>and all</em> previously received <em>unacknowledged messages on that
session</em> are acknowledged. Messages received <em>after</em> <span class="code ">msg</span> was received
are not affected. This is a form of <em>group acknowledgement</em>,
which differs slightly from the JMS 1.1 specification but is likely to
be more useful, and is compatible with the vast majority of uses of
the existing acknowledge function.</p>
<p>For even finer control, a new acknowledgement mode may be set when
creating a session, called <span class="code ">RMQSession.CLIENT_INDIVIDUAL_ACKNOWLEDGE</span>.</p>
<p>A session created with this acknowledgement mode will mean that messages
received on that session will be acknowledged individually. That is,
the call <span class="code ">msg.acknowledge()</span> will acknowledge only the message <span class="code ">msg</span>
and not affect any other messages of that session.</p>
<p>The acknowledgement mode <span class="code ">RMQSession.CLIENT_INDIVIDUAL_ACKNOWLEDGE</span>
is equivalent to <span class="code ">Session.CLIENT_ACKNOWLEDGE</span> in all other respects.
In particular the <span class="code ">getAcknowledgeMode()</span> method returns
<span class="code ">Session.CLIENT_ACKNOWLEDGE</span> even if
<span class="code ">RMQSession.CLIENT_INDIVIDUAL_ACKNOWLEDGE</span> has been set.</p>
<h3>Arbitrary Message support</h3>
<p>Any instance of a class that implements the <span class="code ">javax.jms.Message</span>
interface can be <em>sent</em> by a JMS message producer.</p>
<p>All properties of the message required by <span class="code ">send()</span> are correctly
interpreted except that the <span class="code ">JMSReplyTo</span> header and objects
(as property values or the body of an <span class="code ">ObjectMessage</span>) that
cannot be deserialized are ignored.</p>
<p>The implementation extracts the properties and body from the <span class="code ">Message</span>
instance using interface methods and recreates it as a message of
the right (<span class="code ">RMQMessage</span>) type (<span class="code ">BytesMessage</span>, <span class="code ">MapMessage</span>, <span class="code ">ObjectMessage</span>,
<span class="code ">TextMessage</span>, or <span class="code ">StreamMessage</span>) before sending it. This means
that there is some performance loss due to the copying; but in the
normal case, when the message is an instance of
<span class="code ">com.rabbitmq.jms.client.RMQMessage</span>, no copying is done.</p>
<h2><a id="further-reading" class="anchor" href="#further-reading">Further Reading</a></h2>
<p>To gain better understanding of AMQP 0-9-1 concepts and interoperability of
the RabbitMQ JMS client with AMQP 0-9-1 clients, you may wish to read an
<a href="./tutorials/amqp-concepts.html">Introduction to RabbitMQ Concepts</a>
and browse our
<a href="amqp-0-9-1-quickref.html">AMQP 0-9-1 Quick Reference Guide</a>.</p><div id="help-and-feedback"><h2>Getting Help and Providing Feedback</h2><p>
                    If you have questions about the contents of this guide or
                    any other topic related to RabbitMQ, don't hesitate to ask them
                    on the <a href="https://groups.google.com/forum/#!forum/rabbitmq-users">RabbitMQ mailing list</a>.
                  </p></div><div id="contribute"><h2>Help Us Improve the Docs &lt;3</h2><p>
                    If you'd like to contribute an improvement to the site,
                    its source is <a href="https://github.com/rabbitmq/rabbitmq-website">available on GitHub</a>.
                    Simply fork the repository and submit a pull request. Thank you!
                  </p></div></div><div id="right-nav"><div id="in-this-section"><h4>In This Section</h4><ul>
     <li><a href="/admin-guide.html">Server Documentation</a></li>
     <li><a href="/clients.html" class="selected">Client Documentation</a><ul>
       <li><a href="/api-guide.html">Java Client Guide</a></li>
       <li><a href="/jms-client.html" class="selected">JMS Client</a><ul>
         <li><a href="/jms-client-compliance.html">JMS Client Spec Compliance</a></li>
       </ul></li>
       <li><a href="/dotnet-api-guide.html">.NET Client Guide</a></li>
       <li><a href="/erlang-client-user-guide.html">Erlang Client Guide</a></li>
       <li><a href="/heartbeats.html">Heartbeats</a></li>
       <li><a href="/amqp-0-9-1-reference.html">AMQP 0-9-1 Reference</a></li>
       <li><a href="/uri-spec.html">AMQP 0-9-1 URI Spec</a></li>
       
       
       
     </ul></li>
     <li><a href="/plugins.html">Plugins</a></li>
     <li><a href="/news.html">News</a></li>
     <li><a href="/protocol.html">Protocol</a></li>
     <li><a href="/extensions.html">Our Extensions</a></li>
     <li><a href="/build.html">Building</a></li>
     
     <li><a href="/mpl.html">License</a></li>
   </ul></div></div></div><div class="clear"></div><div class="pageFooter"><div class="container"></div><div class="container"><div class="rabbit-logo"><a href="/"><img src="/img/logo-rabbitmq-white.svg" alt="RabbitMQ" /></a></div><ul class="footerNav"><li><a href="/#features">Features</a></li><li><a href="/#getstarted">Get Started</a></li><li><a href="/#support">Support</a></li><li><a href="/#community">Community</a></li><li><a href="/documentation.html">Docs</a></li></ul><p id="copyright">
          Copyright © 2007-2022 <a href="https://tanzu.vmware.com/">VMware</a>, Inc. or its affiliates. All rights reserved.
          <a href="https://www.vmware.com/help/legal.html">Terms of Use</a> •
          <a href="https://www.vmware.com/help/privacy.html">Privacy</a> •
          <a href="/trademark-guidelines.html">Trademark Guidelines</a> •
          <a href="https://www.vmware.com/help/privacy/california-privacy-rights.html">Your California Privacy Rights</a> •
          <a class="ot-sdk-show-settings">Cookie Settings</a><br /><a id="teconsent"></a></p></div></div></div><script type="text/javascript" src="/js/highlight.pack.js"></script><script type="text/javascript">
        // code highlighting
        window.addEventListener("load", function() {
          const selectors = "pre.lang-bash, \
                             pre.lang-csharp, \
                             pre.lang-elixir, \
                             pre.lang-erlang, \
                             pre.lang-go, \
                             pre.lang-groovy, \
                             pre.lang-haskell, \
                             pre.lang-html, \
                             pre.lang-ini, \
                             pre.lang-java, \
                             pre.lang-javascript, \
                             pre.lang-json, \
                             pre.lang-makefile, \
                             pre.lang-objectivec, \
                             pre.lang-php, \
                             pre.lang-plaintext, \
                             pre.lang-powershell, \
                             pre.lang-python, \
                             pre.lang-ruby, \
                             pre.lang-swift, \
                             pre.lang-yaml, \
                             pre.lang-xml";
          document.querySelectorAll(selectors).forEach(function(el) {
            hljs.highlightBlock(el);
          });
        });
      </script></body>
</html>
