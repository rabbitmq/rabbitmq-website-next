<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="73d8ba46-8c12-43f6-8c22-24aa21b8d93d" name="onetrust-data-domain" /><meta content="https://tags.tiqcdn.com/utag/vmware/microsites-privacy/prod/utag.js" name="microsites-utag" /><script src="https://d1fto35gcfffzn.cloudfront.net/assets/jquery-1.11.2.min.js"></script><script src="//www.vmware.com/files/templates/inc/utag_data.js"></script><script src="//tags.tiqcdn.com/utag/vmware/microsites-privacy/prod/utag.sync.js"></script><script>function OptanonWrapper() { { window.dataLayer.push({ event: 'OneTrustGroupsUpdated' }); } }</script><script src="/js/gtm.js"></script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="googlebot" content="NOODP" /><meta name="google-site-verification" content="nSYeDgyKM9mw5CWcZuD0xu7iSWXlJijAlg9rcxVOYf4" /><meta name="google-site-verification" content="6UEaC3SWhpGQvqRnSJIEm2swxXpM5Adn4dxZhFsNdw0" /><meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="viewport" name="viewport" /><link href="https://fonts.googleapis.com/css?family=Raleway:400,500,600,700" rel="stylesheet" /><link rel="stylesheet" href="/css/rabbit.css" type="text/css" /><link rel="stylesheet" href="/css/highlightjs_style.css" type="text/css" /><link rel="stylesheet" href="/css/rabbit-next.css" type="text/css" /><!--[if IE 6]>
      <link rel="stylesheet" href="/css/rabbit-ie6.css" type="text/css" />
      <![endif]--><link rel="icon" type="/image/vnd.microsoft.icon" href="/favicon.ico" /><link rel="stylesheet" href="/css/tutorial.css" type="text/css" /><script async="true" type="text/javascript" src="/js/site.js"></script><title> RabbitMQ OAuth 2.0 Auth Backend Examples
 â€” RabbitMQ</title></head>
  <body id="oauth2-examples"><div id="outerContainer"><div class="container"><div class="rabbit-logo"><a href="/"><img src="/img/logo-rabbitmq.svg" alt="RabbitMQ" /></a></div><a class="btn menubtn" onclick="showHide()">Menu <img src="/img/carrot-down-white.svg" /></a><div class="mobilemenuicon" onclick="showHide()"><img src="/img/mobile-menu-icon.svg" /></div><div id="nav"><ul id="mainNav"><li><a href="/#features">Features</a></li><li><a href="/#getstarted">Get Started</a></li><li><a href="/#support">Support</a></li><li><a href="/#community">Community</a></li><li><a href="/documentation.html">Docs</a></li></ul></div></div><div class="nav-separator"></div><div id="innerContainer" class="container"><div id="left-content"><h1> RabbitMQ OAuth 2.0 Auth Backend Examples
</h1>


<h2><a id="overview" class="anchor" href="#overview">Overview</a></h2>
<p>This tutorial-style guide has two primary goals:</p>
<ol>
<li>Explore how applications and end users can <a href="./access-control.html">authenticate</a> with RabbitMQ server using OAuth 2.0 protocol rather than
   the traditional username/password pairs or x.509 certificates.</li>
<li>Explore what it takes to set up RabbitMQ Server with OAuth 2.0 authentication mechanism.
   Additionally it explains how to stand up (<a href="https://github.com/cloudfoundry/uaa">UAA</a>) as an OAuth 2.0 Authorization Server and all the operations to create OAuth clients, users and obtain their tokens.</li>
</ol>
<p>The guide covers several OAuth 2 usage scenarios in the context of RabbitMQ and is
accompanied by <a href="https://github.com/rabbitmq/rabbitmq-oauth2-tutorial">a public GitHub repository</a>.
The GitHub repository includes RabbitMQ and UAA configuration files, as well as Make targets
that make it easier to</p>
<p>To understand the details of how to configure RabbitMQ with Oauth2, go to the <a href="#understand-the-environment">Understand the environment</a> section.</p>
<h2><a id="toc" class="anchor" href="#toc">Table of Content</a></h2>


<ul>
<li><a href="#prerequisites">Prerequisites to follow this guide</a></li>
<li><a href="#getting-started-with-uaa-and-rabbitmq">Getting started with UAA and RabbitMQ</a></li>
<li><a href="#access-management-ui">Access Management UI using OAuth 2.0 tokens</a><ul>
<li><a href="#service-provider-initiated-logon">Service-Provider initiated logon</a></li>
<li><a href="#identity-provider-initiated-logon">Identity-Provider initiated logon</a></li>
</ul>
</li>
<li><a href="#access-other-protocols">Access other protocols using OAuth 2.0 tokens</a></li>
<li><a href="#monitoring-agent-accessing-management-rest-api">Management REST api</a><ul>
<li><a href="#amqp-protocol">AMQP protocol</a></li>
<li><a href="#jms-protocol">JMS protocol</a></li>
<li><a href="#mqtt-protocol">MQTT protocol</a></li>
</ul>
</li>
<li><a href="#advanced-configuration">Use advanced OAuth 2.0 configuration</a><ul>
<li><a href="#use-custom-scope-field">Use custom scope field</a></li>
<li><a href="#use-multiple-asymmetrical-signing-keys">Use multiple asymmetrical signing keys</a></li>
<li><a href="#use-scope-aliases">Use Scope Aliases</a></li>
<li><a href="#preferred-username-claims">Preferred username claims</a></li>
<li><a href="#use-rar-tokens">Use Rich Authorization Requests tokens</a></li>
</ul>
</li>
<li>Use different OAuth 2.0 servers<ul>
<li><a href="oauth2-examples-keycloak.html">KeyCloak</a></li>
<li><a href="oauth2-examples-oauth0.html">https://auth0.com/</a></li>
<li><a href="oauth2-examples-azure.html">Azure Active Directory</a></li>
<li><a href="./oauth2-examples-proxy.html">OAuth2 Proxy</a></li>
</ul>
</li>
<li><a href="#understand-the-environment">Understanding the environment</a><ul>
<li><a href="#rabbitmq-server">RabbitMQ server</a></li>
<li><a href="#uaa-server">UAA server</a></li>
<li><a href="#uaa-client">UAA client</a></li>
<li><a href="#clients-users-permissions-in-uaa">Clients, Users &amp; Permissions in UAA</a></li>
</ul>
</li>
<li><a href="#deeper-dive">Deeper Dive</a><ul>
<li>About Users and Clients</li>
<li>About Permissions</li>
<li>About signing key required to configure RabbitMQ</li>
<li>About rotating UAA signing key</li>
<li>Understanding Access tokens and how RabbitMQ uses it</li>
</ul>
</li>
</ul>


<h2><a id="prerequisites" class="anchor" href="#prerequisites">Prerequisites Used by the Examples in This Guide</a></h2>
<ul>
<li>Docker must be installed</li>
<li>Ruby must be installed</li>
<li>make</li>
</ul>
<h2><a id="getting-started-with-uaa-and-rabbitmq" class="anchor" href="#getting-started-with-uaa-and-rabbitmq">Getting started with UAA and RabbitMQ</a></h2>
<p>Before proceeding with other more sophisticated examples, let's start RabbitMQ configured with OAuth 2.0 plugin and
<a href="https://docs.cloudfoundry.org/concepts/architecture/uaa.html">UAA</a> as the OAuth 2.0 Authorization Server.</p>
<p>In the next section, you
will see how to set up UAA and RabbitMQ. If you are new to OAuth 2.0, it is a good starting point. If you already know OAuth 2.0
and you want to learn how to configure RabbitMQ to talk to one of OAuth 2.0 server tested on this tutorial, you can jump
straight to them. They are:</p>
<ul>
<li><a href="./oauth2-examples-keycloak.html">KeyCloak</a></li>
<li><a href="./oauth2-examples-oauth0.html">https://auth0.com/</a></li>
<li><a href="./oauth2-examples-azure.html">Azure Active Directory</a></li>
<li><a href="#uaa-asymmetrical-signing-keys">UAA</a></li>
</ul>
<h4><a id="uaa-asymmetrical-signing-keys" class="anchor" href="#uaa-asymmetrical-signing-keys">Use Asymmetrical Digital Singing Keys</a></h4>
<p>There are two ways to set up OAuth 2.0 in RabbitMQ. One uses symmetrical signing keys. And the other uses
asymmetrical signing keys. The Authorization server is who digitally signs the Access tokens and RabbitMQ
has to be configured to validate any of the two types of digital signatures.</p>
<p>Given that asymmetrical keys is the most widely used option, you are going to focus on how to
configure RabbitMQ with them.</p>
<p>Run the following 2 commands to get the environment ready to see Oauth 2.0 plugin in action:</p>
<ol>
<li><span class="code ">make start-uaa</span> to get UAA server running</li>
<li><span class="code ">make start-rabbitmq</span> to start RabbitMQ server</li>
</ol>
<p>The last command starts a RabbitMQ server with <a href="https://github.com/rabbitmq/rabbitmq-oauth2-tutorial/blob/main/conf/uaa/rabbitmq.config">specific configuration file</a>.</p>
<h2><a id="access-management-ui" class="anchor" href="#access-management-ui">Access Management UI using OAuth 2.0 tokens</a></h2>
<p>The RabbitMQ Management UI can be configured with one of these two login modes:</p>
<ul>
<li><a href="#service-provider-initiated-logon">Service-Provider initiated logon</a>: this is the default and traditional OAuth 2.0 logon mode.
  When the user visits the RabbitMQ Management UI, it shows a button with the label <span class="code ">Click here to logon</span>. When the user clicks it,
  the logon process starts by redirecting to the configured <strong>Authorization Server</strong>.</li>
<li><a href="#identity-provider-initiated-logon">Identity-Provider initiated logon</a>: this mode is opposite to the previous mode.
  The user must first access the RabbitMQ Management's <span class="code ">/login</span> endpoint with a token. If the token is valid, the user is allowed to access the RabbitMQ Management UI.
  This mode is very useful for Web sites which allow users to access the RabbitMQ Management UI with a single click.
  The original Web site get a token on user's behalf and redirects the user to the RabbitMQ Management's <span class="code ">/login</span> endpoint.</li>
</ul>
<h3><a id="service-provider-initiated-logon" class="anchor" href="#service-provider-initiated-logon">Service-Provider initiated logon</a></h3>
<p>The first time an end user arrives to the management UI, they are redirected to the configured OAuth 2.0 provider to authenticate.
Once they successfully authenticate, the user is redirected back to RabbitMQ
with a valid access token. RabbitMQ validates it and identify the user and its permissions from the token.</p>
<pre class="lang-plain">
    [ UAA ] &lt;----2. auth----    [ RabbitMQ ]
            ----3. redirect--&gt;  [  http    ]
                                  /|\
                                   |
                            1. rabbit_admin from a browser
</pre>

<p>At step 2, if this is the first time the user is accessing RabbitMQ resource, UAA will prompt the user to
authorize RabbitMQ application as shown on the screenshot below.</p>
<p><img alt="authorize application" src="./img/oauth2/authorize-app.png" /></p>
<p>UAA has previously been configured and seeded with two users:</p>
<ul>
<li><span class="code ">rabbit_admin:rabbit_admin</span></li>
<li>and <span class="code ">rabbit_monitor:rabbit_monitor</span></li>
</ul>
<p>Now navigating to the <a href="http://localhost:15672">local node's management UI</a> and login using any of those two users.</p>
<p>This is a token issued by UAA for the <span class="code ">rabbit_admin</span> user thru the redirect flow you just saw above.
It was signed with the symmetric key.</p>
<p><img alt="JWT token" src="./img/oauth2/admin-token-signed-sym-key.png" /></p>
<p>To configure the RabbitMQ Management UI with OAuth 2.0, the following configuration entries are required
in <span class="code ">advanced.config</span>:</p>
<pre class="lang-erlang">
 ...
 {rabbitmq_management, [
    {oauth_enabled, true},
    {oauth_client_id, "rabbit_client_code"},
    {oauth_provider_url, "http://localhost:8080"},
    ...
  ]},
</pre>

<h3><a id="identity-provider-initiated-logon" class="anchor" href="#identity-provider-initiated-logon">Identity-Provider initiated logon</a></h3>
<p>Like Service-Provider initiated logon, with Idp-initiated logon users get to the RabbitMQ Management UI with a valid token.
The following scenarios are examples of Idp-initiated logon:</p>
<ul>
<li>RabbitMQ is behind a web portal which conveniently allow users to navigate directly to RabbitMQ fully authenticated.</li>
<li>There is an OAuth2 proxy in between users and RabbitMQ which intercepts their requests and forwards them to RabbitMQ inserting the token into the HTTP <span class="code ">Authorization</span> header.</li>
</ul>
<p>The latter scenario is demonstrated <a href="./oauth2-examples-proxy.html">here</a>. The former scenario is covered in the following section.</p>
<h4>Idp-initiated Logon using the Login Endpoint</h4>
<p>A Web portal offers their authenticated users the option to navigate to RabbitMQ
by submitting a form with their OAuth token in the <span class="code ">access_token</span> form field as provided below:</p>
<pre class="lang-plain">
    [ Idp | WebPortal ] ----&gt; 2. /login [access_token: TOKEN]----   [ RabbitMQ Cluster ]
              /|\                                                        |       /|\
               |                                                         +--------+
      1. rabbit_admin from a browser                                   3. validate token
</pre>

<p>If the access token is valid, RabbitMQ redirects the user to the <strong>Overview</strong> page.</p>
<p>By default, the RabbitMQ Management UI is configured with <strong>service-provider initiated logon</strong>, to configure <strong>Identity-Provider initiated logon</strong>,
add one entry to <span class="code ">advanced.config</span>. For example:</p>
<pre class="lang-erlang">
 ...
 {rabbitmq_management, [
    {oauth_enabled, true},
    {oauth_provider_url, "http://localhost:8080"},
    {oauth_initiated_logon_type, idp_initiated},
    ...
  ]},
</pre>

<p><strong>Important</strong>: when the user logs out, or its RabbitMQ session expired, or the token expired, the user is directed to the
RabbitMQ Management landing page which has a <strong>Click here to login</strong> button.
The user is never automatically redirected back to the url configured in the <span class="code ">oauth_provider_url</span>.
It is only when the user clicks <strong>Click here to login</strong> , the user is redirected to the configured url in <span class="code ">oauth_provider_url</span>.</p>
<h2><a id="access-other-protocols" class="anchor" href="#access-other-protocols">Access other protocols using OAuth 2.0 tokens</a></h2>
<p>The following subsections demonstrate how to use access tokens with any messaging protocol and also to access the management rest api.</p>
<h3><a id="monitoring-agent-accessing-management-rest-api" class="anchor" href="#monitoring-agent-accessing-management-rest-api-2">Management REST api</a></h3>
<p>In this scenario a monitoring agent uses RabbitMQ HTTP API to collect monitoring information.
Because it is not an end user, or human, you refer to it as a <em>service account</em>.
This <em>service account</em> could be our <span class="code ">mgt_api_client</span> client you created in UAA with the <span class="code ">monitoring</span> <em>user tag</em>.</p>
<p>This <em>monitoring agent</em> would use the <em>client credentials</em> or <em>password</em> grant flow to authenticate (1) with
UAA and get back a JWT token (2). Once it gets the token, it sends (3) a HTTP request
to the RabbitMQ management endpoint passing the JWT token within the <span class="code ">Authorization</span> header as a <em>Bearer token</em>.</p>
<pre class="lang-plain">
[ UAA ]                  [ RabbitMQ ]
  /|\                    [  http    ]
    |                          /|\
    |                       3.http://broker:15672/api/overview passing JWT token
    |                           |
    +-----1.auth---------  monitoring agent
    --------2.JWT--------&gt;
</pre>

<p>The following command launches the browser with <span class="code ">mgt_api_client</span> client with a JWT token previously obtained from UAA:</p>
<pre class="lang-bash">
make curl-uaa url=http://localhost:15672/api/overview client_id=mgt_api_client secret=mgt_api_client
</pre>

<h3><a id="amqp-protocol" class="anchor" href="#amqp-protocol">AMQP protocol</a></h3>
<p>An application connects to RabbitMQ using AMQP protocol and presents a JWT Token as a credential.
The application you are going to use is <a href="https://github.com/rabbitmq/rabbitmq-perf-test">PerfTest</a> which is not an OAuth 2.0 aware application.
OAuth 2.0-aware application is covered in <a href="#scenario-4">scenario four</a>.</p>
<p>Instead you are launching the application with a token that you have previously obtained from UAA. This is just to probe AMQP access with a JWT Token. Needless to say that the application should instead obtain the JWT Token prior to connecting to RabbitMQ and it should also be able to refresh it before reconnecting. RabbitMQ validates the token before accepting it. If the token has expired, RabbitMQ will reject the connection.</p>
<p>First of all, an application which wants to connect to RabbitMQ using Oauth 2.0 must present a
valid JWT token. To obtain the token, the application must first authenticate (<span class="code ">1.</span>) with UAA. In case of a successful
authentication, it gets back a JWT token (<span class="code ">2.</span>) which uses it to connect (<span class="code ">3.</span>) to RabbitMQ.</p>
<pre class="lang-plain">
[ UAA ]                  [ RabbitMQ ]
  /|\                    [  amqp    ]
    |                          /|\
    |                       3.connect passing JWT
    |                           |
    +-----1.auth---------  amqp application
    --------2.JWT--------&gt;
</pre>

<p>You have previously configured UAA with these 2 OAuth 2.0 clients:</p>
<ul>
<li><span class="code ">consumer</span></li>
<li><span class="code ">producer</span></li>
</ul>
<p>In order to get a JWT token, an OAuth 2.0 client must be used.
Applications use the <span class="code ">Oauth client grant flow</span> to obtain a JWT token.</p>
<p>This the token issued by UAA for the <span class="code ">consumer</span> OAuth 2.0 client.</p>
<p><img alt="JWT token" src="./img/oauth2/consumer-token-signed-with-sym-key.png" /></p>
<p>To launch the consumer application invoke the following command:</p>
<pre class="lang-bash">
make start-perftest-consumer
</pre>

<p>To see consumer logs:</p>
<pre class="lang-bash">
docker logs consumer -f
</pre>

<p>To launch the producer application invoke the following command:</p>
<pre class="lang-bash">
make start-perftest-producer
</pre>

<p>To inspect producer logs:</p>
<pre class="lang-bash">
docker logs producer -f
</pre>

<p>To stop all the applications call the following command:</p>
<pre class="lang-bash">
make stop-all-apps
</pre>

<h3><a id="jms-protocol" class="anchor" href="#jms-protocol">JMS protocol</a></h3>
<p>In this use case you are demonstrating a basic JMS application which reads, via an environment variable (<span class="code ">TOKEN</span>),
the JWT token that will use as password when authenticating with RabbitMQ.</p>
<p>It is <strong>critically important</strong> to grant the required permission to the <em>exchange</em> <span class="code ">jms.durable.queues</span>.</p>
<p>Applications which send JMS messages require of these permissions:</p>
<ul>
<li><span class="code ">rabbitmq.configure:*/jms.durable.queues</span></li>
<li><span class="code ">rabbitmq.write:*/jms.durable.queues</span></li>
<li><span class="code ">rabbitmq.read:*/jms.durable.queues</span></li>
</ul>
<p>Those permissions grant access on all virtual hosts.</p>
<p>Before testing a publisher and a subscriber application you need to build a local image for the
basic jms application by invoking this command:</p>
<pre class="la">
make build-jms-client
</pre>

<p>To test a JMS application sending a message and authenticating via OAuth 2.0 run this command:</p>
<pre class="lang-bash">
make start-jms-publisher
</pre>

<p>It sends a message to a queue called <span class="code ">q-test-queue</span></p>
<p>Applications which subscribe to a JMS queue require of these permissions:</p>
<ul>
<li><span class="code ">rabbitmq.write:*/jms.durable.queues</span></li>
</ul>
<p>Those permissions grant access to all virtual hosts.</p>
<p>To test a JMS application subscribing to a queue and authenticating via OAuth 2.0 run this command:</p>
<pre class="lang-bash">
make start-jms-subscriber
</pre>

<p>It subscribes to a queue called <span class="code ">q-test-queue</span></p>
<h3><a id="mqtt-protocol" class="anchor" href="#mqtt-protocol">MQTT protocol</a></h3>
<p>This scenario explores the use case where you authenticate with a JWT token to RabbitMQ MQTT port.</p>
<p>Note: in this example, RabbitMQ is already configured with the <a href="./mqtt.html"><span class="code ">rabbitmq_mqtt</span> plugin</a>.</p>
<p>This is no different than using AMQP or JMS protocols, all that matters is to pass an empty username and a JWT token as password.
However, <strong>what it is really different</strong> is how you encode the permissions. In this use case you are going to proceed as you did it in the previous use case where you handcrafted the JWT token rather than requesting it to UAA. Here is the the scopes required to publish
a message to a mqtt topic (<a href="https://github.com/rabbitmq/rabbitmq-oauth2-tutorial/blob/main/jwts/scopes-for-mqtt.json">scopes-for-mqtt.json</a>)</p>
<pre class="lang-javascript">
{
  "scope": [
    "rabbitmq.write:*/*/*",
    "rabbitmq.configure:*/*/*",
    "rabbitmq.read:*/*/*"

  ],
  "extra_scope": "rabbitmq.tag:management",
  "aud": [
    "rabbitmq"
  ]
}
</pre>

<p><span class="code ">rabbitmq.write:*/*/*</span> means allow write operation on a any vhost, on any exchange and any topic. In fact,
it is any "routing-key" because that is translated to a topic/queue.</p>
<p>You are going to publish a mqtt message by running the following command. If you have not run any of the
previous use cases, you need to launch rabbitmq first like this <span class="code ">make start-rabbitmq</span>.</p>
<pre class="lang-bash">
make start-mqtt-publish TOKEN=$(bin/jwt_token scopes-for-mqtt.json legacy-token-key private.pem public.pem)
</pre>

<blockquote>
<p>IMPORTANT: If you try to access the Management UI and authenticate with UAA using rabbit_admin you
wont be able to do bind a queue with routing_key <span class="code ">test</span> to the <span class="code ">amq.topic</span> exchange because that user
in UAA does not have the required permissions. In our handcrafted token, you have granted ourselves the right permissions/scopes.</p>
</blockquote>
<h2><a id="advanced-configuration" class="anchor" href="#advanced-configuration">Use advanced OAuth 2.0 configuration</a></h2>
<h3><a id="use-custom-scope-field" class="anchor" href="#use-custom-scope-field">Use a Custom Scope Field</a></h3>
<p>There are some Authorization servers which cannot include RabbitMQ scopes into the standard
JWT <span class="code ">scope</span> field. Instead, they can include RabbitMQ scopes in a custom JWT scope of their choice.</p>
<p>It is possible to configure RabbitMQ with a different field to look for scopes as shown below:</p>
<pre class="lang-erlang">
[
  {rabbitmq_auth_backend_oauth2, [
    ...
    {extra_scopes_source, &lt;&lt;"extra_scope"&gt;&gt;},
    ...
    ]}
  ]},
].
</pre>

<p>To test this feature you are going to build a token, sign it and use it to hit one of the RabbitMQ management endpoints.
The command below allows us to hit any management endpoint, in this case it is the <span class="code ">overview</span>, with a token.</p>
<pre class="lang-bash">
make curl-with-token URL=http://localhost:15672/api/overview TOKEN=$(bin/jwt_token scope-and-extra-scope.json legacy-token-key private.pem public.pem)
</pre>

<p>You use the python script <span class="code ">bin/jwt_token.py</span> to build the minimal JWT token possible that RabbitMQ is able to
validate which is:</p>
<pre class="lang-javascript">
{
  "scope": [

  ],
  "extra_scope": [
    "rabbitmq.tag:management"
  ],
  "aud": [
    "rabbitmq"
  ]
}
</pre>

<h3><a id="use-multiple-asymmetrical-signing-keys" class="anchor" href="#use-multiple-asymmetrical-signing-keys">Use multiple asymmetrical signing keys</a></h3>
<p>This scenario explores the use case where JWT tokens may be signed by different asymmetrical signing keys.</p>
<p>There are two ways to configure RabbitMQ with multiple signing keys:</p>
<ul>
<li><strong>Statically</strong> configure them via <span class="code ">rabbitmq.conf</span> as shown in the <a href="https://github.com/rabbitmq/rabbitmq-server/tree/main/deps/rabbitmq_auth_backend_oauth2#variables-configurable-in-rabbitmqconf">plugin documentation page</a>.</li>
<li><strong>Dynamically</strong> add the keys to a running RabbitMQ node without having to restart it.
   This alternative is explained in more detail in the section <a href="#about-rotating-uaa-signing-key">About rotating UAA signing key</a>.
   This section will also use this option.</li>
</ul>
<p>First you add a second signing key called <span class="code ">legacy-token-2-key</span> whose public key is <span class="code ">conf/public-2.pem</span>:</p>
<pre class="lang-bash">
docker exec -it rabbitmq rabbitmqctl add_uaa_key legacy-token-2-key --pem-file=/conf/public-2.pem
Adding UAA signing key "legacy-token-2-key" filename: "/conf/public-2.pem"
</pre>

<p>And then you issue a token using the corresponding private key and use it to access the management endpoint <span class="code ">/api/overview</span>.</p>
<pre class="lang-bash">
make curl-with-token URL=http://localhost:15672/api/overview TOKEN=$(bin/jwt_token scope-and-extra-scope.json legacy-token-2-key private-2.pem public-2.pem)
</pre>

<p><span class="code ">bin/jwt_token</span> searches for private and public key files under the <span class="code ">conf</span> directory and jwt files under <span class="code ">jwts</span>.</p>
<h3><a id="use-scope-aliases" class="anchor" href="#use-scope-aliases">Using Scope Aliases</a></h3>
<p>In this use case you are going to demonstrate how to configure RabbitMQ to handle
<em>custom scopes</em>. But what are <em>custom scopes</em>? They are any
scope whose format is not compliant with RabbitMQ format. For instance, <span class="code ">api://rabbitmq:Read.All</span>
is one of the custom scopes you will use in this use case.</p>
<h4>How to configure RabbitMQ with custom scope mapping</h4>
<p>Starting with <a href="https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.10.0">RabbitMQ <span class="code ">3.10.0</span></a>,
the OAuth 2.0 plugin supports mapping of a scope aliases (arbitrary scope values or "names") to one or more scopes
in the format that follows the RabbitMQ OAuth 2.0 plugin conventions.</p>
<p>See below a sample RabbitMQ configuration where you map <span class="code ">api://rabbitmq:Read.All</span>
custom scope to <span class="code ">rabbitmq.read:*/*</span> RabbitMQ scope.</p>
<pre class="lang-erlang">
{rabbitmq_auth_backend_oauth2, [
 ...,
    {scope_aliases, #{
        &lt;&lt;"api://rabbitmq:Read.All"&gt;&gt;      =&gt; [&lt;&lt;"rabbitmq.read:*/*"&gt;&gt;],
      ...
    },
    ...
]}
</pre>

<p>Additionally, you can map a custom scope to many RabbitMQ scopes. For instance below you
are mapping the role <span class="code ">api://rabbitmq:producer</span> to 3 RabbitMQ scopes which grants
<span class="code ">read</span>, <span class="code ">write</span> and <span class="code ">configure</span> access on any resource and on any vhost:</p>
<pre class="lang-erlang">
{rabbitmq_auth_backend_oauth2, [
 ...,

    {scope_aliases, #{
        &lt;&lt;"api://rabbitmq:producer"&gt;&gt; =&gt; [
            &lt;&lt;"rabbitmq.read:*/*"&gt;&gt;,
            &lt;&lt;"rabbitmq.write:*/*"&gt;&gt;,
            &lt;&lt;"rabbitmq.configure:*/*"&gt;&gt;
        ]
    }},
    ...
]}
</pre>

<h4>Scopes Aliases in JWT Tokens</h4>
<p>If you do not configure RabbitMQ OAuth 2.0 plugin with <span class="code ">extra_scopes_source</span>, RabbitMQ
expects the <span class="code ">scope</span> token's field to carry <em>custom scopes</em>. For instance, below you have a sample JWT
token where the custom scopes are in the <span class="code ">scope</span> field :</p>
<pre class="lang-javascript">
{
  "sub": "producer",
  "scope": [
    "api://rabbitmq:producer",
    "api://rabbitmq:Administrator"
  ],
  "aud": [
    "rabbitmq"
  ]
}
</pre>

<p>Now, let's say you do configure RabbitMQ OAuth 2.0 plugin with <span class="code ">extra_scopes_source</span> as shown below:</p>
<pre class="lang-erlang">
  {rabbitmq_auth_backend_oauth2, [
    {resource_server_id, &lt;&lt;"rabbitmq"&gt;&gt;},
    {extra_scopes_source, &lt;&lt;"roles"&gt;&gt;},
    ...
</pre>

<p>With this configuration, RabbitMQ expects <em>custom scopes</em> in the field <span class="code ">roles</span> and
the <span class="code ">scope</span> field is ignored.</p>
<pre class="lang-javascript">
{
  "sub": "rabbitmq-client-code",
  "roles": "api://rabbitmq:Administrator.All",
  "aud": [
    "rabbitmq"
  ]
}
</pre>

<h4>UAA Configuration</h4>
<p>To demonstrate this new capability you have configured UAA with two Oauth 2.0 clients. One
called <span class="code ">producer_with_roles</span> with the <em>custom scope</em> <span class="code ">api://rabbitmq:producer</span> and <span class="code ">consumer_with_roles</span> with
<span class="code ">api://rabbitmq:Read:All,api://rabbitmq:Configure:All,api://rabbitmq:Write:All</span>.</p>
<blockquote>
<p>You are granting configure and write permissions to the consumer because you have configured perf-test to declare
resources regardless whether it is a producer or consumer application.</p>
</blockquote>
<p>These two uaac commands declare the two OAuth 2.0 clients above. You are adding an extra scope called <span class="code ">rabbitmq.*</span> so
that UAA populates the JWT claim <span class="code ">aud</span> with the value <span class="code ">rabbitmq</span>. RabbitMQ expects <span class="code ">aud</span> to match the value you
configure RabbitMQ with in the <span class="code ">resource_server_id</span> field.</p>
<pre class="lang-bash">
uaac client add producer_with_roles --name producer_with_roles \
    --authorities "rabbitmq.*,api://rabbitmq:producer,api://rabbitmq:Administrator" \
    --authorized_grant_types client_credentials \
    --secret producer_with_roles_secret
uaac client add consumer_with_roles --name consumer_with_roles \
    --authorities "rabbitmq.* api://rabbitmq:read:All" \
    --authorized_grant_types client_credentials \
    --secret consumer_with_roles_secret
</pre>

<h4>RabbitMQ Configuration</h4>
<p>In the OAuth 2.0 tutorial repository, there are two RabbitMQ configuration files ready to be used, for UAA:</p>
<ul>
<li><a href="https://github.com/rabbitmq/rabbitmq-oauth2-tutorial/blob/main/conf/uaa/rabbitmq-scope-aliases.config">conf/uaa/rabbitmq-scope-aliases.config</a>: configures a set of scope aliases.</li>
<li><a href="https://github.com/rabbitmq/rabbitmq-oauth2-tutorial/blob/main/conf/uaa/rabbitmq-scope-aliases-and-extra-scope.config">conf/uaa/rabbitmq-scope-aliases-and-extra-scope.config</a>: configures a <span class="code ">extra_scopes_source</span> and a set of scope aliases.</li>
</ul>
<h4>Demo 1: Launch RabbitMQ with custom scopes in scope field</h4>
<p>To launch RabbitMq with scope mappings and with <em>custom scopes</em> in the <span class="code ">scope</span> field you run the following command:</p>
<pre class="lang-bash">
CONFIG=rabbitmq-scope-aliases.config make start-rabbitmq
</pre>

<p>This command will stop RabbitMQ if it is already running.</p>
<p>Launch a producer application with the client <span class="code ">producer_with_roles</span></p>
<pre class="lang-bash">
make start-perftest-producer PRODUCER=producer_with_roles
</pre>

<p>To inspect the logs:</p>
<pre class="lang-bash">
docker logs producer_with_roles -f
</pre>

<p>Launch a consumer application with the client <span class="code ">consumer_with_roles</span></p>
<pre class="lang-bash">
make start-perftest-consumer CONSUMER=consumer_with_roles
</pre>

<p>To check the logs : docker logs consumer_with_roles -f</p>
<p>Access management api with the client <span class="code ">producer_with_roles</span></p>
<pre class="lang-bash">
make curl url=http://localhost:15672/api/overview client_id=producer_with_roles secret=producer_with_roles_secret
</pre>

<p>To stop the perf-test applications run :</p>
<pre class="lang-bash">
make stop-perftest-producer PRODUCER=producer_with_roles
make stop-perftest-consumer CONSUMER=consumer_with_roles
</pre>

<h4>Demo 2: Launch RabbitMQ with custom scopes in extra scope field</h4>
<p>To launch RabbitMq with scope mappings and with <em>custom scopes</em> in the <span class="code ">extra_scope</span> you run the following command:</p>
<pre class="lang-bash">
CONFIG=rabbitmq-scope-aliases-and-extra-scope.config make start-rabbitmq
</pre>

<p>This command will stop RabbitMQ if it is already running</p>
<p>You cannot use UAA to issue the tokens because you cannot configure UAA to use a custom field for scopes.
Instead you are going to issue the token ourselves with the command <span class="code ">bin/jwt_token</span>.</p>
<p>Launch a producer application with the token <a href="https://github.com/rabbitmq/rabbitmq-oauth2-tutorial/blob/main/jwts/producer-roles-in-extra-scope.json">producer-role-in-scope.json</a>:</p>
<pre class="lang-bash">
make start-perftest-producer-with-token PRODUCER=producer_with_roles TOKEN=$(bin/jwt_token producer-role-in-extra-scope.json legacy-token-key private.pem public.pem)
</pre>

<p>To inspect the logs:</p>
<pre class="lang-bash">
docker logs producer_with_roles -f
</pre>

<p>Launch a consumer application with the token <a href="https://github.com/rabbitmq/rabbitmq-oauth2-tutorial/blob/main/jwts/consumer-roles-in-extra-scope.json">consumer-roles-in-extra-scope.json</a>:</p>
<pre class="lang-bash">
make start-perftest-consumer-with-token CONSUMER=consumer_with_roles TOKEN=$(bin/jwt_token consumer-roles-in-extra-scope.json legacy-token-key private.pem public.pem)
</pre>

<p>Access management api with the token <a href="https://github.com/rabbitmq/rabbitmq-oauth2-tutorial/blob/main/jwts/producer-roles-in-extra-scope.json">producer-roles-in-extra-scope.json</a></p>
<pre class="lang-bash">
make curl-with-token URL="http://localhost:15672/api/overview" TOKEN=$(bin/jwt_token producer-roles-in-extra-scope.json legacy-token-key private.pem public.pem)
</pre>

<p>To stop the <span class="code ">perf-test</span> applications, run:</p>
<pre class="lang-bash">
make stop-perftest-producer PRODUCER=producer_with_roles
make stop-perftest-consumer CONSUMER=consumer_with_roles
</pre>

<h3><a id="preferred-username-claims" class="anchor" href="#preferred-username-claims">Preferred username claims</a></h3>
<p>RabbitMQ needs to figure out the username associated to the token so that it can display it in the Management UI.
By default, RabbitMQ will first look for the <span class="code ">sub</span> claim and if it is not found it uses the <span class="code ">client_id</span>.</p>
<p>Most authorization servers return the user's GUID in the <span class="code ">sub</span> claim rather than the actual user's username or email address, anything the user can relate to. When the <span class="code ">sub</span> claim does not carry a <em>user-friendly username</em>, you can configure one or several claims to extract the username from the token.</p>
<p>Given this configuration:</p>
<pre class="lang-erlang">
  ...
  {rabbitmq_auth_backend_oauth2, [
    {resource_server_id, &lt;&lt;"rabbitmq"&gt;&gt;},
    {preferred_username_claims, [&lt;&lt;"user_name"&gt;&gt; ,&lt;&lt;"email"&gt;&gt;]},
  ...
</pre>

<p>RabbitMQ would first look for the <span class="code ">user_name</span> claim and if it is not found it looks for <span class="code ">email</span>. Else it uses its default lookup mechanism which first looks for <span class="code ">sub</span> and then <span class="code ">client_id</span>.</p>
<h3><a id="use-rar-tokens" class="anchor" href="#use-rar-tokens">Use Rich Authorization Request Tokens</a></h3>
<p>The <a href="https://oauth.net/2/rich-authorization-requests/">Rich Authorization Request</a> extension provides a way for
OAuth 2.0 clients to request fine-grained permissions during an authorization request.
It moves away from the concept of scopes that are text labels and instead
defines a more sophisticated permission model.</p>
<p>RabbitMQ supports JWT tokens compliant with the extension. Below is a sample example section of JWT token:</p>
<pre class="lang-javascript">
{
  "authorization_details": [
    { "type" : "rabbitmq",
      "locations": ["cluster:finance/vhost:primary-*"],
      "actions": [ "read", "write", "configure"  ]
    },
    { "type" : "rabbitmq",
      "locations": ["cluster:finance", "cluster:inventory", ],
      "actions": ["tag:administrator" ]
    }
  ]
}
</pre>

<p><em>Get the environment ready</em></p>
<p>To demonstrate this new capability you have to deploy RabbitMQ with the appropriate configuration file
under <a href="https://github.com/rabbitmq/rabbitmq-oauth2-tutorial/blob/main/conf/uaa/rabbitmq-for-rar-tokens.config">conf/uaa/rabbitmq-for-rar-tokens.config</a>.</p>
<pre class="lang-bash">
export CONFIG=rabbitmq-for-rar-tokens.config
make start-rabbitmq
</pre>

<p><strong>NOTE</strong>: You do not need to run any OAuth 2.0 server like UAA. This is because you are creating a token and signing it using the same
private-public key pair RabbitMQ is configured with.</p>
<p><em>Use a Rich Authorization Token to access the management rest api</em></p>
<p>You are going use this token <a href="https://github.com/rabbitmq/rabbitmq-oauth2-tutorial/blob/main/jwts/rar-token.json">jwts/rar-token.json</a> to access an endpoint of the management rest api.</p>
<pre class="lang-bash">
make curl-with-token URL=http://localhost:15672/api/overview TOKEN=$(bin/jwt_token rar-token.json legacy-token-key private.pem public.pem)
</pre>

<p>Note: You are using curl to go to the URL using a TOKEN which you have built using the command bin/jwt_token which takes the JWT payload, the name of the signing key and the private and public certificates to sign the token</p>
<p><em>Use a Rich Authorization Token to access AMQP protocol</em></p>
<p>This time, You are going to use the same token you used in the previous section to access the AMQP protocol via the PerfTest tool which acts as a AMQP producer application:</p>
<pre class="lang-bash">
make start-perftest-producer-with-token PRODUCER=producer_with_roles TOKEN=$(bin/jwt_token rar-token.json legacy-token-key private.pem public.pem)
</pre>

<p>The command above launches the application in the background, you can check the logs by running this command:</p>
<pre class="lang-bash">
docker logs producer_with_roles -f
</pre>

<p>For more information on this new capability check out the <a href="./oauth2.html#rich-authorization-request">OAuth 2 guide</a>.</p>
<h2><a id="understanding-environment" class="anchor" href="#understanding-environment">Understand the Environment</a></h2>
<h3>RabbitMQ Server</h3>
<p>You need to launch RabbitMQ with the following prerequisites:</p>
<ul>
<li>Like with all other <a href="./plugins.html">plugins</a>, the OAuth 2.0 plugin must be enabled.</li>
<li>Plugin is configured with the <a href="#about-signing-key-required-to-configure-rabbitmq">same signing key as used by UAA</a></li>
<li>The node is configured to use OAuth 2.0 <a href="./access-control.html">authN and authZ backend</a></li>
<li><a href="./management.html">Management plugin</a> is configured to use UAA</li>
</ul>
<p>The following configuration snippets demonstrate these steps:</p>
<pre class="lang-erlang">
  {rabbitmq_auth_backend_oauth2, [
    {resource_server_id, &lt;&lt;"rabbitmq"&gt;&gt;}
    {key_config, [
      {default_key, &lt;&lt;"legacy-token-key"&gt;&gt;},
      {signing_keys, #{
        &lt;&lt;"legacy-token-key"&gt;&gt; =&gt; {map, #{&lt;&lt;"kty"&gt;&gt; =&gt; &lt;&lt;"MAC"&gt;&gt;,
                                  &lt;&lt;"alg"&gt;&gt; =&gt; &lt;&lt;"HS256"&gt;&gt;,
                                  &lt;&lt;"use"&gt;&gt; =&gt; &lt;&lt;"sig"&gt;&gt;,
                                  &lt;&lt;"value"&gt;&gt; =&gt; &lt;&lt;"tokenKey"&gt;&gt;}}
      }}
    ]}
  ]},
</pre>

<pre class="lang-erlang">
[
  % Instruct the node to use OAuth 2.0 backend first, then internal if necessary
  {rabbit, [
     {auth_backends, [rabbit_auth_backend_oauth2, rabbit_auth_backend_internal]}
  ]},
].
</pre>

<pre class="lang-erlang">
[
  {rabbitmq_management, [
    %% eanble Oauth
    {oauth_enabled,    true},
    %% use UAA
    {enable_uaa,    true},
    %% OAuth 2 identity server client ID
    {oauth_client_id, "rabbit_client"},
    %% UAA endpoint location
    {oauth_provider_url, "http://localhost:8080"}
  ]},
].
</pre>

<p>Find a complete example in the <a href="https://github.com/rabbitmq/rabbitmq-oauth2-tutorial/blob/master/conf/symmetric_key/rabbitmq.config">GitHub repository</a>.</p>
<h3>UAA Server</h3>
<p>Standalone OAuth 2.0 server (https://github.com/cloudfoundry/uaa). Its primary role is as an OAuth 2.0 provider, issuing tokens for client applications to use when they act on behalf of Cloud Foundry users. It can also authenticate users with their Cloud Foundry credentials, and can act as an SSO service using those credentials. It has endpoints for managing user accounts and for registering OAuth 2.0 clients, as well as various other management functions</p>
<p><strong>Important note</strong>: UAA can use an external database such PostgreSQL or MySQL.
For the demonstration purposes of this tutorial, the internal database is sufficient.</p>
<p>To verify that UAA is running and accessible on <span class="code ">localhost:8080</span>:</p>
<pre class="lang-bash">
curl -k  -H 'Accept: application/json' http://localhost:8080/uaa/info | jq .
</pre>

<p>Currently RabbitMQ Management plugin does not support latest version of UAA. That is
why in order to run the use cases you use the image built from the folder <span class="code ">uaa-4.24</span>. This has to do
with the javascript library that comes with the management plugin.</p>
<h3>UAA client</h3>
<p>In order to interact with UAA server there is a convenient command-line application called <span class="code ">uaac</span>. To install it and get it ready run the following command:</p>
<pre class="lang-bash">
make install-uaac
</pre>

<p>In order to operate with uaa you need to "authenticate". There is an OAuth 2.0 client preconfigured with the following credentials <span class="code ">admin:adminsecret</span>.
This user is configured under <span class="code ">{uaa_repo}/uaa/src/main/webapp/WEB-INF/spring/oauth-clients.xml</span>. The above command takes care of this.</p>
<h3>Clients, Users and Permissions in UAA</h3>
<p>The Make target <span class="code ">make setup-users-and-clients</span> accomplishes a few things:</p>
<ul>
<li>Created <span class="code ">rabbit_client</span> client -in UAA- which is going to be used by RabbitMQ server to authenticate management users coming to the Management UI.</li>
<li>Created <span class="code ">rabbit_admin</span> user -in UAA- which is going to be the full administrator user with full access.</li>
<li>Created <span class="code ">rabbit_monitor</span> user -in UAA- which is going to be the monitoring user with just the <em>monitoring</em> <em>user tag</em>.</li>
<li>Created <span class="code ">consumer</span> client -in UAA- which is going to be the RabbitMQ User for the consumer application.</li>
<li>Created <span class="code ">producer</span> client -in UAA- which is going to be the RabbitMQ User for the producer application.</li>
<li>Obtained tokens -from UAA- for the two end users and for the two clients.</li>
</ul>
<h2><a id="deeper-dive" class="anchor" href="#deeper-dive">Deeper Dive</a></h2>
<h3>About Users and Clients</h3>
<p>First of all, you need to clarify the distinction between <em>users</em> and <em>clients</em>.
- A <em>user</em> is often represented as a live person. This is typically the user who wants to access the RabbitMQ Management UI/API.
- A <em>client</em> (a.k.a. <em>service account</em>) is an application that acts on behalf of a user or act on its own. This is typically an AMQP application.</p>
<h3>About Permissions</h3>
<p><em>Users</em> and <em>clients</em> will both need to get granted permissions. In OAuth 2.0, permissions/roles are named <em>scopes</em>. They are free form strings. When a RabbitMQ user connects to RabbitMQ, it must provide a JWT token with those <em>scopes</em> as a password (and empty username). And RabbitMQ determines from those <em>scopes</em> what permissions it has.</p>
<p>The <em>scope</em> format recognized by RabbitMQ is as follows</p>
<pre class="lang-plaintext">
{resource_server_id}.{permission}:{vhost_pattern}/{name_pattern}/{routing_key_pattern}
</pre>

<p>where:</p>
<ul>
<li><span class="code ">{resource_server_id}</span> is a prefix used for <em>scopes</em> in UAA to avoid scope collisions (or unintended overlap)</li>
<li><span class="code ">{permission}</span> is an access permission (configure, read, write, tag)</li>
<li><span class="code ">{vhost_pattern}</span> is a wildcard pattern for vhosts token has access to</li>
<li><span class="code ">{name_pattern}</span> is a wildcard pattern for resource name</li>
<li><span class="code ">{routing_key_pattern}</span> is an optional wildcard pattern for routing key in topic authorization</li>
</ul>
<p>For more information, see <a href="https://github.com/rabbitmq/rabbitmq-auth-backend-oauth2#scope-to-permission-translation">how scopes are translated to RabbitMQ permissions</a>
and <a href="https://www.rabbitmq.com/access-control.html#permissions">RabbitMQ permissions</a> documentation.</p>
<p>Sample <em>scope</em>(s):</p>
<ul>
<li><span class="code ">rabbitmq.read:*/*</span> grants <span class="code ">read</span> permission on any <em>vhost</em> and on any <em>resource</em></li>
<li><span class="code ">rabbitmq.write:uaa_vhost/x-*</span> grants <span class="code ">write</span> permissions on <span class="code ">uaa_vhost</span> on any <em>resource</em> that starts with <span class="code ">x-</span></li>
<li><span class="code ">rabbitmq.tag:monitoring</span> grants <span class="code ">monitoring</span> <em>user tag</em></li>
</ul>
<blockquote>
<p>Be aware that you have used <span class="code ">rabbitmq</span> resource_server_id in the sample scopes. RabbitMQ must be configured with this same <span class="code ">resource_server_id</span>. Check out <a href="https://github.com/rabbitmq/rabbitmq-oauth2-tutorial/blob/main/conf/uaa-symmetrical/rabbitmq.config">conf/symmetric_keys/rabbitmq.config</a></p>
</blockquote>
<h3>About signing key required to configure RabbitMQ</h3>
<p>This section is only to explain one of things you need to take care to configure RabbitMQ with OAuth 2.0 auth-backend. Do not run any of the commands explained on this section. They are all included in the <span class="code ">make</span> commands you will cover in the following sections.</p>
<p>To configure OAuth 2.0 plugin in RabbitMQ you need to obtain the JWT signing key used by UAA when it issues JWT tokens.
But our <span class="code ">admin</span> client does not have yet the right <em>authority</em> (<span class="code ">uaa.resource</span>) to get that signing key. You are going to "auto" grant it ourselves:</p>
<pre class="lang-bash">
uaac client update admin --authorities "clients.read clients.secret clients.write uaa.admin clients.admin scim.write scim.read uaa.resource"
</pre>

<p>And now you retrieve the signing key:</p>
<pre class="lang-bash">
uaac signing key -c admin -s adminsecret
</pre>

<p>which outputs:</p>
<pre class="lang-plaintext">
kty: MAC
alg: HS256
value: tokenKey
use: sig
kid: legacy-token-key
</pre>

<p>Another way to retrieve it is via the UAA REST API:</p>
<pre class="lang-bash">
curl 'http://localhost:8080/uaa/token_key' -i  -H 'Accept: application/json' -u admin:adminsecret
</pre>

<h3>About Rotating UAA signing key</h3>
<p>When UAA rotates the signing key you need to reconfigure RabbitMQ with that key. You don't need to edit the configuration and restart RabbitMQ.</p>
<p>Instead, thru the <span class="code ">rabbitmqctl add_uaa_key</span> command you can add more keys. This is more or less what could happen.</p>
<ol>
<li>UAA starts up with a signing key called "key-1"</li>
<li>You configure RabbitMQ with the signing key "key-1" following the procedure explained in the previous section</li>
<li>RabbitMQ starts</li>
<li>An application obtains a token from UAA signed with that "key-1" signing key and connects to RabbitMQ using the token</li>
<li>RabbitMQ can validate it because it has the signing key</li>
<li>UAA rotates the signing key. It has a new key "key-2"</li>
<li>An application obtains a new token from UAA. This time it is signed using "key-2". The application connect to RabbitMQ using the new token</li>
<li>RabbitMQ fails to validate it because it does not have "key-2" signing key. Later on you will see how RabbitMQ finds out the signing key name for the JWT</li>
<li>You add the new signing key via the <span class="code ">rabbitmqctl</span> command</li>
<li>This time RabbitMQ can validate tokens signed with "key-2"</li>
</ol>
<p>One way to keep RabbitMQ up-to-date is to periodically check with <a href="https://docs.cloudfoundry.org/api/uaa/version/4.28.0/index.html#token-keys">token keys endpoint</a> (using the <span class="code ">E-tag</span> header). When the list of active tokens key has changed, you retrieve them and add them using <span class="code ">rabbitmqctl add_uaa_key</span>.</p>
<p>You are probably missing the ability to remove deprecated/obsolete signing keys.
The <a href="https://github.com/rabbitmq/rabbitmq-auth-backend-oauth2/blob/master/src/uaa_jwt.erl">function</a> is there so you could potentially invoke it via <span class="code ">rabbitmqctl eval</span> command.</p>
<h3>Understanding Access tokens and how RabbitMQ uses it</h3>
<p>First of all, lets quickly go thru how RabbitMQ uses the OAuth Access Tokens; how RabbitMQ users/clients pass the token; whats inside the token and what information in the token is relevant for RabbitMQ and how it uses it.</p>
<h4>How Clients Pass JWT Tokens to RabbitMQ</h4>
<p>RabbitMQ expects a <a href="https://tools.ietf.org/html/rfc7515">JWS</a> in the password field.</p>
<p>For end users, the best way to come to the Management UI is by the following url, replacing <span class="code ">{token}</span> with an actual encoded JWT.
This is how <span class="code ">make open</span> command is able to open the browser and login the user using a JWT.</p>
<pre class="lang-bash">
http://localhost:15672/#/login/{token}
</pre>

<h4>Signed Tokens</h4>
<p>RabbitMQ expects a JWS, i.e. signed JWT. There are three parts to a signed token (JWS):</p>
<ul>
<li>a header which describes the signing algorithm and the signing key identifier used to sign the JWT</li>
<li>a body with the actual token</li>
<li>a signature.</li>
</ul>
<p>This is a example of the header of a JWT issued by UAA:</p>
<pre class="lang-javascript">
{
  "alg": "HS256",
  "jku": "https://localhost:8080/uaa/token_keys",
  "kid": "legacy-token-key",
  "typ": "JWT"
}
</pre>

<p>where:</p>
<ul>
<li><a href="https://tools.ietf.org/html/rfc7515#page-8">typ</a> is the media type which in this case is JWT. However the JWT protected header and JWT payload are secured using HMAC SHA-256 algorithm</li>
<li><a href="https://tools.ietf.org/html/rfc7515#page-10">alg</a> is the signature algorithm</li>
<li><a href="https://tools.ietf.org/html/rfc7515#page-10">jku</a> is the HTTP GET resource that returns the signing keys supported by the server that issued this token</li>
<li><a href="https://tools.ietf.org/html/rfc7515#page-11">kid</a> identifies the signing key used to sign this token</li>
</ul>
<p>Note that <span class="code ">uaac token decode</span> does not print the header only the actual token.
One simple way to get this information is via <a href="https://jwt.io">jwt.io</a>.</p>
<p>To get the signing key used by UAA you access the <em>token key</em> access point with the credentials of the <span class="code ">admin</span> UAA client; or a client which has the permission to get it.</p>
<pre class="lang-bash">
curl http://localhost:8080/uaa/token_key \
 -H 'Accept: application/json' \
 -u admin:adminsecret  | jq .
</pre>

<p>It should print out:</p>
<pre class="lang-javascript">
{
  "kty": "MAC",
  "alg": "HS256",
  "value": "tokenKey",
  "use": "sig",
  "kid": "legacy-token-key"
}
</pre>

<p>You can see that the <span class="code ">kid</span>s value above matches the <span class="code ">kid</span>'s in the JWT.</p>
<p><strong>Relevant token information for RabbitMQ</strong></p>
<p>Let's examine the following token which corresponds to end-user <span class="code ">rabbit_admin</span>.</p>
<pre class="lang-javascript">
{
  "jti": "dfb5f6a0d8d54be1b960e5ffc996f7aa",
  "sub": "71bde130-7738-47b8-8c7d-ad98fbebce4a",
  "scope": [
    "rabbitmq.read:*/*",
    "rabbitmq.write:*/*",
    "rabbitmq.tag:administrator",
    "rabbitmq.configure:*/*"
  ],
  "client_id": "rabbit_client",
  "cid": "rabbit_client",
  "azp": "rabbit_client",
  "grant_type": "password",
  "user_id": "71bde130-7738-47b8-8c7d-ad98fbebce4a",
  "origin": "uaa",
  "user_name": "rabbit_admin",
  "email": "rabbit_admin@example.com",
  "auth_time": 1551957721,
  "rev_sig": "d5cf8503",
  "iat": 1551957721,
  "exp": 1552000921,
  "iss": "http://localhost:8080/uaa/oauth/token",
  "zid": "uaa",
  "aud": [
    "rabbitmq",
    "rabbit_client"
  ]
}
</pre>

<p>These are the fields relevant for RabbitMQ:
- <span class="code ">sub</span> (<a href="https://tools.ietf.org/html/rfc7519#page-9">Subject</a>) this is the identify of the subject of the token. <strong>RabbitMQ uses this field to identify the user</strong>. This token corresponds to the <span class="code ">rabbit_admin</span> end user. If you logged into the Management UI, you would see it in the top-right corner. If this were an AMPQ user, you would see it on each connection listed in the connections tab.
  UAA would add 2 more fields relative to the <em>subject</em>: a <span class="code ">user_id</span> with the same value as the <span class="code ">sub</span> field, and <span class="code ">user_name</span> with user's name. In UAA, the <span class="code ">sub</span>/<span class="code ">user_id</span> fields contains the user identifier, which is a GUID.</p>
<ul>
<li>
<p><span class="code ">client_id</span> (not part of the RFC-7662) identifies the OAuth client that obtained the JWT. You used <span class="code ">rabbit_client</span> client to obtain the JWT for <span class="code ">rabbit_admin</span> user. <strong>RabbitMQ also <a href="https://github.com/rabbitmq/rabbitmq-auth-backend-oauth2/blob/master/src/rabbit_auth_backend_oauth2.erl#L169">uses</a> this field to identify the user</strong>.</p>
</li>
<li>
<p><span class="code ">aud</span> (<a href="https://tools.ietf.org/html/rfc7519#page-9">Audience</a>) this identifies the recipients and/or resource_server of the JWT. <strong>RabbitMQ uses this field to validate the token</strong>. When you configured RabbitMQ OAuth plugin, you set <span class="code ">resource_server_id</span> attribute with the value <span class="code ">rabbitmq</span>. The list of audience must have the <span class="code ">rabbitmq</span> otherwise RabbitMQ rejects the token.</p>
</li>
<li>
<p><span class="code ">jti</span> (<a href="https://tools.ietf.org/html/rfc7662#section-2.2">JWT ID</a>) this is just an identifier for the JWT</p>
</li>
<li>
<p><span class="code ">iss</span> (<a href="https://tools.ietf.org/html/rfc7662#section-2.2">Issuer</a>) identifies who issued the JWT. UAA will set it to end-point that returned the token.</p>
</li>
<li>
<p><span class="code ">scope</span> is an array of <a href="https://tools.ietf.org/html/rfc7523#page-4">OAuth Scope</a>. <strong>This is what RabbitMQ uses to determine the user's permissions</strong>. However, RabbitMQ will only use the <em>scopes</em> which belong to this RabbitMQ identified by the plugin configuration parameter <span class="code ">resource_server_id</span>. In other words, if the <span class="code ">resource_server_id</span> is <span class="code ">rabbitmq</span>, RabbitMQ will only use the <em>scopes</em> which start with <span class="code ">rabbimq.</span>.</p>
</li>
<li>
<p><span class="code ">exp</span> (<a href="https://tools.ietf.org/html/rfc7519#page-9">exp</a>) identifies the expiration time on
   or after which the JWT MUST NOT be accepted for processing. RabbitMQ uses this field to validate the token if it is present.</p>
<blockquote>
<p>Implementers MAY provide for some small leeway, usually no more than
   a few minutes, to account for clock skew. However, RabbitMQ does not add any leeway.</p>
</blockquote>
</li>
</ul><div id="help-and-feedback"><h2>Getting Help and Providing Feedback</h2><p>
                    If you have questions about the contents of this guide or
                    any other topic related to RabbitMQ, don't hesitate to ask them
                    using <a href="https://github.com/rabbitmq/rabbitmq-server/discussions">GitHub Discussions</a>
                    or our community <a href="https://rabbitmq.com/discord">Discord server</a>.
                  </p></div><div id="contribute"><h2>Help Us Improve the Docs &lt;3</h2><p>
                    If you'd like to contribute an improvement to the site,
                    its source is <a href="https://github.com/rabbitmq/rabbitmq-website">available on GitHub</a>.
                    Simply fork the repository and submit a pull request. Thank you!
                  </p></div></div><div id="right-nav"></div></div><div class="clear"></div><div class="pageFooter"><div class="container"></div><div class="container"><div class="rabbit-logo"><a href="/"><img src="/img/logo-rabbitmq-white.svg" alt="RabbitMQ" /></a></div><ul class="footerNav"><li><a href="/#features">Features</a></li><li><a href="/#getstarted">Get Started</a></li><li><a href="/#support">Support</a></li><li><a href="/#community">Community</a></li><li><a href="/documentation.html">Docs</a></li></ul><p id="copyright">
          Copyright Â© 2005-2023 <a href="https://tanzu.vmware.com/">Broadcom</a>. All Rights Reserved. The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
          <a href="https://www.vmware.com/help/legal.html">Terms of Use</a> â€¢
          <a href="https://www.vmware.com/help/privacy.html">Privacy</a> â€¢
          <a href="/trademark-guidelines.html">Trademark Guidelines</a> â€¢
          <a href="https://www.vmware.com/help/privacy/california-privacy-rights.html">Your California Privacy Rights</a> â€¢
          <a class="ot-sdk-show-settings">Cookie Settings</a><br /><a id="teconsent"></a></p></div></div></div><script type="text/javascript" src="/js/highlight.pack.js"></script><script type="text/javascript">
        // code highlighting
        window.addEventListener("load", function() {
          const selectors = "pre.lang-apacheconf, \
                             pre.lang-bash, \
                             pre.lang-csharp, \
                             pre.lang-clojure, \
                             pre.lang-elixir, \
                             pre.lang-erlang, \
                             pre.lang-go, \
                             pre.lang-groovy, \
                             pre.lang-haskell, \
                             pre.lang-ini, \
                             pre.lang-java, \
                             pre.lang-javascript, \
                             pre.lang-json, \
                             pre.lang-makefile, \
                             pre.lang-nginxconf, \
                             pre.lang-objectivec, \
                             pre.lang-php, \
                             pre.lang-plaintext, \
                             pre.lang-powershell, \
                             pre.lang-python, \
                             pre.lang-ruby, \
                             pre.lang-swift, \
                             pre.lang-yaml, \
                             pre.lang-xml";
          document.querySelectorAll(selectors).forEach(function(el) {
            hljs.highlightBlock(el);
          });
        });
      </script></body>
</html>
